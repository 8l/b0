proc getChar(){
	push r0,r1,r2,r3;
	r0 = look_ahead_ch;
	ch = r0;
	r1 = CHAR_LF;            /// UNIX '\n' is really LINE FEED and NOT Carriage RETURN
	r2 = file_stack_ptr;
	
	if (r0 == r1){
		r1 = file[r2].line_count;
		r1 = r1 + 1;
		file[r2].line_count = r1;
		
		// handle callback function;
		push r1, r1, r2, r3, r4, r5, r6, r8, r9, r10, r11, r12, r13, r14, r15;
		r0 = ptr_callback;
		if(r0){
			r1 = r0;
			#ifdef WIN_DLL;
				push r6;
				r6 = r7;
				r7 = r7 && -16;			// Re-align stack to rsp mod 16 = 0
				r7 = r7 - 20h;
				r0 = 0;
				[r7] = r0;
				[r7+08h] = r0;
				[r7+10h] = r0;
				[r7+18h] = r0;
			#endif;
			call r1;
			#ifdef WIN_DLL;
				r7 = r6;
				pop r6;
			#endif;
		};
		pop r15, r14, r13, r12, r11, r10, r9, r8, r6, r5, r4, r3, r2, r1, r0;
		
		r3 = DEBUG;
		if (r3){ //DEBUG
			push r0;
			echo_string(STDOUT, 'NEW LINE - ');
			echo_integer(STDOUT, r1);
			echo_string(STDOUT, '\n');
			pop r0;
		}
	}
	
	r1 = file[r2].handle;
	r1 = _fgetc(r1);
	r3 = 0ffffffffh;		// Convert EOF to -1;
	if(r1 == r3){
		r1 = EOF;
	}
	look_ahead_ch = r1;	// Get our next character
	
	r3 = DEBUG;
	r2 = r0;
	//echo_string(STDOUT, 'getChar() Start\n');
	if (r3){
		echo_string(STDOUT, 'ch = ');
		echo_character(STDOUT, r2);
		echo_string(STDOUT, ', ');
		echo_hex(STDOUT, r2);
		echo_string(STDOUT, ' lch = ');
		echo_character(STDOUT, r1);
		echo_string(STDOUT, ', ');
		echo_hex(STDOUT, r1);
		echo_string(STDOUT, '\n');
	}
	//echo_string(STDOUT, 'getChar() Complete\n');
	pop r3, r2, r1, r0;
};

// Both of these targets provid their own abort_b0 calls to pass info back to the application.
#ifndef SYSV_ELFO;
#ifndef WIN_DLL;

proc abort_b0(s){
	push r0, r1, r2;
	r0 = HeaderPrinted;
	if (r0) {
		PrintHeader();
	}
	echo_string(STDOUT, 'Error: ');
	r0 = s;
	echo_string(STDOUT, r0);
	echo_cr(STDOUT);
	r0 = DEBUG;
	if (r0){
		echo_string(STDOUT, 'Char: ');
		r0 = ch;
		echo_character(STDOUT, r0);
		echo_string(STDOUT, ' Token: ');
		r0 = token;
		echo_hex(STDOUT, r0);
		echo_cr(STDOUT);
	}
	echo_string(STDOUT, 'Filename: ');
	r1 = file_stack_ptr;
	r0 = &file[r1].filename;
	echo_string(STDOUT, r0);
	echo_string(STDOUT, ' Line: ');
	r0 = file[r1].line_count;
	r2 = CHAR_LF;
	r1 = ch;
	if(r1 == r2){
		r0 = r0 - 1;
	}
	//echo_hex(STDOUT, r0);
	echo_integer(STDOUT, r0);
	echo_string(STDOUT, '.\n');
	r0 = ContinueOnAbort;
	r1 = 0;
	if (r0 == r1){
		r0 = _clock();
		r1 = time_start;
		r0 = r0 - r1;	// r0 has our time in ticks
		r1 = r0;
		echo_string(STDOUT, 'Processing Time: ');
		echo_integer(STDOUT, r1);
		echo_string(STDOUT, ' sec\n');
		r0 = code;		// close our 3 tmp files.
		_fclose(r0);
		r0 = data;
		_fclose(r0);
		r0 = bss;
		_fclose(r0);
		close_open_files();
		r0 = DEBUG;
		r1 = 0;
		if(r0 == r1){	// If not debugging, then remove the current temp files.
			//_remove('c_output.tmp');
			//_remove('d_output.tmp');
			//_remove('b_output.tmp');
			b0_delete_temp_files();
		};
		#ifdef WIN64;
		__Exit_Win64();
		#endif;
		//exit(-1);
		r0 = -1;
		r7 = rsp_entry;
		ret;
	}
	pop r2, r1, r0;
}

#endif;
#endif;

proc insert_token(name, token_type){
	push r1, r2, r3;
	r1 = name;
	r0 = ElfHash(r1);
	r3 = 0;
	r2 = HASH_TABLE_SIZE;
	r0 = r0 % r2;  // Get the modulus
	r0 = r0 + 1; // Add one to it. (can't have a hash value of 0).
	
	r2 = r2 - 1;
	if (r0 >= r2){	// If our hash is bigger than the table size, then set the hash to 1.
		r0 = 1;
	}
	hash_table[r0].hash = r0;		// Set the hash tabel entry to used by inserting our hash.
	r2 = &hash_table[r0].token;	// get the address of the token offset in the hash table
	push r0, r1;
	r1 = r1 - 2;
	strcpy(r2, r1);				// Copy our name into the hash_table.
	pop r1, r0;
	r1 = token_type;
	hash_table[r0].token_type = r1;
	r2 = r0;
	r0 = DEBUG;
	if (r0) {
		echo_string(STDOUT, '#define HASH_');
		r0 = name;
		r0 = r0 - 2;
		echo_string(STDOUT, r0);
		echo_string(STDOUT, ' = ');
		r0 = hash_table[r2].hash;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, ';\n');
		// Neat little hack to help rebuild the b0.h.b0 file if modding the hash table size, eg HASH_TABLE_SIZE in b0.h.b0.
	};
	pop r3, r2, r1;
}

proc insert_token_stack(_token){
	push r1, r2;
	r0 = token;
	r1 = _token;
	r2 = &token_stack;  	// Need this form if building for libc, else a simple 'token_stack[r0] = r1;' could be used.
	[r2+r0*8] = r1;		// see above...
	r0 = r0 + 1;
	token = r0;
	r1 = TOKEN_STACK_SIZE;
	if (r0 >= r1) {
		abort_b0('INTERNAL: Token Stack Overflow! - Increase TOKEN_STACK_SIZE');
	}
	r0 = DEBUG;
	if(r0){
		echo_string(STDOUT, 'Insert token = ');
		r1 = _token;
		echo_hex(STDOUT, r1);
		echo_cr(STDOUT);
	}
	pop r2, r1;
}

proc atStackStart(){
	r0 = token;
	if (r0){
		abort_b0('Invalid construct');
	}
	r0 = r0 + 1;
	token = r0;
}

proc atStackEnd(i){
	push r1;
	r0 = token;
	r1 = i;
	if (r0 != r1){
		abort_b0('Unexpected expression/token');
	}
	pop r1;
}

proc TokenIsLabelType(label_type){
	push r1, r2;
	r0 = token;
	r2 = &token_stack;
	r0 = [r2+r0*8];
	r1 = HASH_OFFSET;
	if (r0 < r1){
		abort_b0('Expected Token/Label');
	}
	r0 = r0 - r1;
	r1 = hash_table[r0].token_type;	// Get our token_type for the current value being processed
	r2 = label_type;				// What it should be
	r1 = r1 && r2;
	if (r1 != r2){
		// r2 = the type it should be.
		r1 = TYPE_REG;
		#ifndef i386;
		if (r1 == r2) { abort_b0('64bit Register Expected'); }
		#else;
		if (r1 == r2) { abort_b0('32bit Register Expected'); }
		#endif;
		r1 = TYPE_REG_SHORT;
		#ifndef i386;
		if (r1 == r2) { abort_b0('non-64bit Register Expected'); }
		#else;
		if (r1 == r2) { abort_b0('non-32bit Register Expected'); }
		#endif;
		r1 = TYPE_REG_FPU;
		if (r1 == r2) { abort_b0('FPU Register Expected'); }
		r1 = TYPE_KEYWORD;
		if (r1 == r2) { abort_b0('Keyword Expected'); }
		r1 = TYPE_PROC;
		if (r1 == r2) { abort_b0('Procedure Expected'); }
		r1 = TYPE_EPROC;
		if (r1 == r2) { abort_b0('External Procedure Expected'); }
		r1 = TYPE_ELIB;
		if (r1 == r2) { abort_b0('Expected External DLL Name'); }
		r1 = TYPE_M8;
		if (r1 == r2) { abort_b0('m8 Variable Expected'); }
		r1 = TYPE_M16;
		if (r1 == r2) { abort_b0('m16 Variable Expected'); }
		r1 = TYPE_M32;
		if (r1 == r2) { abort_b0('m32 Variable Expected'); }
		#ifndef i386;
		r1 = TYPE_M64;
		if (r1 == r2) { abort_b0('m64 Variable Expected'); }
		r1 = TYPE_M128;
		if (r1 == r2) { abort_b0('m128 Variable Expected'); }
		#endif;
		r1 = TYPE_F32;
		if (r1 == r2) { abort_b0('f32 Variable Expected'); }
		r1 = TYPE_F64;
		if (r1 == r2) { abort_b0('f64 Variable Expected'); }
		r1 = TYPE_F80;
		if (r1 == r2) { abort_b0('f80 Variable Expected'); }
		r1 = TYPE_V4I;
		if (r1 == r2) { abort_b0('v4i Variable Expected'); }
		r1 = TYPE_V4F;
		if (r1 == r2) { abort_b0('v4f Variable Expected'); }		
		r1 = TYPE_V2F;
		if (r1 == r2) { abort_b0('v2f Variable Expected'); }		
		r1 = TYPE_ARRAY;
		if (r1 == r2) { abort_b0('Array Variable Expected'); }
		r1 = TYPE_LOCAL;
		if (r1 == r2) { abort_b0('Local Variable Expected'); }
		r1 = TYPE_GLOBAL;
		if (r1 == r2) { abort_b0('Global Variable Expected'); }
		r1 = TYPE_FLAG;
		if (r1 == r2) { abort_b0('CPU Flag Expected'); }
		r1 = 0;
		if (r1 == r2) { abort_b0('Unable to redefine Label/Token'); }
		abort_b0('Unknown Construct');
	}
	pop r2, r1;
}

proc IsLabelAllocated(){
	push r1, r2;
	r0 = token;
	r2 = &token_stack;
	r1 = [r2+r0*8];
	r2 = HASH_OFFSET;
	if (r1 < r2){
		abort_b0('Expected Token/Label');
	}
	r1 = r1 - r2;
	r0 = hash_table[r1].token_type;
	if (r0){
		abort_b0('Unable to redefine Label/Token');
	}
	pop r2, r1;
}

proc isHash(i){
	push r1;
	r0 = i;
	r1 = HASH_OFFSET;
	if (r0 < r1){
		abort_b0('Expected Token/Label');
	}
	pop r1;
}

proc outputString(i){
	push r1, r2, r3, r4, r9, r10, r11, r12;
	r9 = TOKEN_END_STRING;
	r0 = token;
	r1 = i;
	r10 = 0ffffh;
	r2 = 0; // Flag to exit the while statement;
	r4 = data;
	r3 = &token_stack;
	r3 = [r3+r0*8];
	if (r3 != r9){
		if (r0 != r1){
			r2 = 1;
		}
	}
	while (r2){
		push r0;
		if (r3 < r10){
			echo_hex(r4, r3);
			echo_string(r4, ',');
		} else {
			r11 = r3 >> 10;
			r11 = r11 && 03fh;
			r12 = r3 >> 16;
			r12 = r12 - 1;
			r12 = r12 << 6;
			r11 = r11 + r12;
			r11 = r11 + 0d800h;
			echo_hex(r4, r11);
			echo_string(r4, ',');
			r11 = r3 && 03ffh;
			r11 = r11 + 0fc00h;
			echo_hex(r4, r11);
			echo_string(',');
		}
		pop r0;
		r0 = r0 + 1;
		token = r0;
		r2 = 0;
		r3 = &token_stack;
		r3 = [r3+r0*8];
		if (r3 != r9){
			if (r0 != r1){
				r2 = 1;
			}
		}
	}
	echo_string(r4, '0\n');
	pop r12, r11, r10, r9, r4, r3, r2, r1;
	return(1);
}

proc outputStringUTF8(i){
	push r1, r2, r3, r4, r9, r10, r11, r12;
	r9 = TOKEN_END_STRING;
	r0 = token;
	r1 = i;
	r10 = 080h;
	r2 = 0; // Flag to exit the while statement;
	r4 = data;
	r3 = &token_stack;
	r3 = [r3+r0*8];
	if (r3 != r9){
		if (r0 != r1){
			r2 = 1;
		}
	}
	while (r2){
		push r0;
		if (r3 < r10){  // Single byte encoding
			echo_hex(r4, r3);
			echo_string(r4, ',');
		} else {
			r10 = 0800h;
			if (r3 < r10){
				// Double byte encoding
				// fprintf(data, "0%xh,", ((token_stack[token] >> 6) + 0xc0));
				r11 = r3 >> 6;
				r11 = r11 + 0ch;
				echo_hex(r4, r11);
				echo_string(r4, ',');
				// fprintf(data, "0%xh,", ((token_stack[token] & 0x3f) + 0x80));
				r11 = r3 && 03fh;
				r11 = r11 + 80h;
				echo_hex(r4, r11);
				echo_string(r4, ',');
			} else {
				r10 = 010000h;
				if (r3 < r10){
					// 3 byte encoding
					// fprintf(data, "0%xh,", ((token_stack[token] >> 12) + 0xe0));
					r11 = r3 >> 12;
					r11 = r11 + 0e0h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", (((token_stack[token] >> 6) & 0x3f) + 0x80));
					r11 = r3 >> 6;
					r11 = r11 && 03fh;
					r11 = r11 + 80h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", ((token_stack[token] & 0x3f) + 0x80));
					r11 = r3 && 03fh;
					r11 = r11 + 80h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
				} else {
					// 4 byte encoding
					// fprintf(data, "0%xh,", ((token_stack[token] >> 18) + 0xf0));
					r11 = r3 >> 18;
					r11 = r11 + 0f0h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", ((token_stack[token] >> 12) + 0xe0));
					r11 = r3 >> 12;
					r11 = r11 + 0e0h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", (((token_stack[token] >> 6) & 0x3f) + 0x80));
					r11 = r3 >> 6;
					r11 = r11 && 03fh;
					r11 = r11 + 80h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", ((token_stack[token] & 0x3f) + 0x80));
					r11 = r3 && 03fh;
					r11 = r11 + 80h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
				}
			}
		}
		pop r0;
		r0 = r0 + 1;
		token = r0;
		r2 = 0;
		r3 = &token_stack;
		r3 = [r3+r0*8];
		if (r3 != r9){
			if (r0 != r1){
				r2 = 1;
			}
		}
	}
	echo_string(r4, '0\n');
	pop r12, r11, r10, r9, r4, r3, r2, r1;
	return(1);		
}

proc outputNumber(i, dec, file_handle){
	f64 fp_val;
	push r1, r2, r3, r4;
	r0 = dec;
	r1 = NUM_INTEGER;
	r2 = &token_stack;
	r3 = token;
	r4 = file_handle;
	if(r0 == r1){
		TokenIs(TOKEN_NUM_INTEGER);
		r2 = [r2+r3*8+8];
		echo_integer(r4, r2);
	} else {
		TokenIs(TOKEN_NUM_DECIMAL);
		r2 = [r2+r3*8+8];
		r0 = &fp_val;
		[r0] = r2;
		fp0 = fp_val;
		echo_float(r4);
	}
	r3 = r3 + 2;
	token = r3;
	r0 = i;
	if(r3 > r0){
		abort_b0('Unexpected tokens');
	}
	pop r4, r3, r2, r1;
	
//	m64 dec_flag;
//	m64 flag_e;
	//echo_string(STDOUT, 'OutputNumber\n');
//	push r1, r2, r3, r4, r5, r9, r10, r11, r12;
//	r9 = TOKEN_OFFSET;
//	r0 = token;
//	r1 = i;
//	r5 = dec;
//	r2 = 0; // Flag to exit the while statement;
//	dec_flag = r2;
//	flag_e = r2;
//	r4 = file_handle;
//	r3 = &token_stack;
//	r3 = [r3+r0*8];
//	if (r3 < r9){
//		if (r0 != r1){
//			r2 = 1;
//		}
//	}
//	while (r2){
//		r12 = NUM_DECIMAL;
///		if (r5 == r12){
//			// Only allow digits and '.' in number
//			// if (((token_stack[token] >= 'a') && (token_stack[token] <= 'f')) ||	(token_stack[token] == 'h'))
//			//	abort_b0("Unexpected hexadecimal value");
//			r0 = CHAR_h;  // == 'h'
//			if (r3 == r0){
//				abort_b0('Unexpected hexadecimal value');
//			}
//			r12 = r3 - CHAR_a; 	// sub 'a' from the value to normalise the value
//			r0 = 6;				// if between 0 and 5 then we have 'a' -> 'f'.
///			if (r12 < r0){		// and a single test is all we need...
//				// Lets check for a decimal.
///				r0 = dec_flag;
//				if(r0){
//					r0 = 4;			// we still need to allow 1.0e10 type notation.
//					if(r12 != r0){
//						abort_b0('Unexpected hexadecimal value');
//					} else {
//						push r3;
//						r3 = &token_stack;
//						r0 = token;
//						r12 = [r3+r0*8-8];
//						pop r3;
//						r0 = CHAR_STOP;
///						if(r12 == r0){
							// If our previous character was a '.' then we have invalid input.
//							abort_b0('Illformed floating point value - please revise');
//						}
//						push r3;
//						r3 = &token_stack;
//						r0 = token;
//						r12 = [r3+r0*8+8];
//						pop r3;
//						r0 = TOKEN_MINUS;
//						if(r0 == r12){
							//Our exponent is a negative.
//							r0 = token;
//							r0 = r0 + 1;
//							token = r0;
//							echo_character(r4, r3);
//							r3 = CHAR_MINUS;
//						}
//					}
//				} else {
//					abort_b0('Unexpected hexadecimal value');
//				}
//			}			
			// if ((dec_flag == 1)&&(token_stack[token] == '.'))
			//	abort_b0("Unexpected second decimal");
			// if (token_stack[token] == '.')
			//	dec_flag = 1;
//			r0 = CHAR_STOP;
//			if (r3 == r0){
//				r0 = dec_flag;
//				if (r0){
//					abort_b0('Unexpected second decimal');
//				}
//				r0 = 1;
//				dec_flag = r0;
//			}
			// fprintf(code, "%c", token_stack[token] );
//			echo_character(r4, r3);
//		} else {
			// allow all xdigits except .
			// if (token_stack[token] == '.')
			//	abort_b0("Unexpected floating point value");
//			r0 = CHAR_STOP; // r0 = '.';
//			if (r3 == r0){
//				abort_b0('Unexpected floating point value');
//			}
			// fprintf(code, "%c", token_stack[token] );
//			echo_character(r4, r3);
//		}
//		r0 = token;
//		r0 = r0 + 1;
//		token = r0;
//		r2 = 0;
//		r3 = &token_stack;
//		r3 = [r3+r0*8];
//		if (r3 < r9){
//			if (r0 != r1){
//				r2 = 1;
//			}
//		}
//	}
	//if ((dec == NUM_DECIMAL) && (dec_flag == 0))
		//fprintf(data, ".0");
//	r1 = dec;
//	r0 = NUM_DECIMAL;
//	if (r0 == r1){
//		r0 = dec_flag;
//		r1 = 0;
//		if (r0 == r1) {
//			r0 = flag_e;
//			if(r0 == r1){
//				echo_string(r4, '.0');
//			}
//		}
//	}
//	pop r12, r11, r10, r9, r5, r4, r3, r2, r1;
	//echo_string(STDOUT, 'EndOutputNumber\n');
//	return(1);
}

proc SetState(){
	push r3;
	r0 = token;
	r3 = &token_stack;
	r3 = [r3+r0*8];
	r3 = r3 - HASH_OFFSET;
	r0 = hash_table[r3].token_type;
	r0 = r0 && 0fh;
	r3 = TYPE_M8;
	if (r0 == r3){
		r3 = CHAR_b; // 'b'
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_M16;
	if (r0 == r3){
		r3 = CHAR_w; // 'w'
		state = r3;
		pop r3;
		return(r0);
	}
	#ifndef i386;
	r3 = TYPE_M32;
	if (r0 == r3){
		r3 = CHAR_d; // 'd'
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_M64;
	if (r0 == r3){
		r3 = CHAR_SPACE; // ' '
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_M128;
	if (r0 == r3){
		r3 = CHAR_SPACE; // ' '
		state = r3;
		pop r3;
		return(r0);
	}
	#else;
	r3 = TYPE_M32;
	if (r0 == r3){
		r3 = CHAR_SPACE; // ' '
		state = r3;
		pop r3;
		return(r0);
	}	
	#endif;
	r3 = TYPE_F32;
	if (r0 == r3){
		r3 = CHAR_3; // '3'
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_F64;
	if (r0 == r3){
		r3 = CHAR_6; // '6'
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_F80;
	if (r0 == r3){
		r3 = CHAR_8; // '8'
		state = r3;
		pop r3;
		return(r0);
	}
	
	r3 = TYPE_V4I;
	if (r0 == r3){
		r3 = CHAR_U; // 'U' = v4i
		state = r3;
		pop r3;
		return(r0);
	}	
	r3 = TYPE_V4F;
	if (r0 == r3){
		r3 = CHAR_V; // 'V' = v4f
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_V2F;
	if (r0 == r3){
		r3 = CHAR_W; // 'W' = v2f
		state = r3;
		pop r3;
		return(r0);
	}	
}

proc TokenIs(tok){
	push r3;
	r0 = token;
	r3 = &token_stack;
	r3 = [r3+r0*8];
	r0 = tok;
	if (r0 != r3){
		r3 = TOKEN_AND;if (r0 == r3) { abort_b0('&& Expected'); }
		r3 = TOKEN_OR; if (r0 == r3) { abort_b0('| Expected'); }
		r3 = TOKEN_XOR; if (r0 == r3) { abort_b0('^ Expected'); }
		r3 = TOKEN_NOT; if (r0 == r3) { abort_b0('! Expected'); }
		r3 = TOKEN_EQUATE; if (r0 == r3) { abort_b0('= Expected'); }
		r3 = TOKEN_ADD; if (r0 == r3) { abort_b0('+ Expected'); }
		r3 = TOKEN_MINUS; if (r0 == r3) { abort_b0('- Expected'); }
		r3 = TOKEN_MULTIPLY; if (r0 == r3) { abort_b0('* Expected'); }
		r3 = TOKEN_DIVIDE; if (r0 == r3) { abort_b0('/ Expected'); }
		r3 = TOKEN_MODULUS; if (r0 == r3) { abort_b0('% Expected'); }
		r3 = TOKEN_S_MULTIPLY; if (r0 == r3) { abort_b0('~* Expected'); }
		r3 = TOKEN_S_DIVIDE; if (r0 == r3) { abort_b0('~/ Expected'); }
		r3 = TOKEN_S_MODULUS; if (r0 == r3) { abort_b0('~% Expected'); }
		r3 = TOKEN_RSHIFT; if (r0 == r3) { abort_b0('>> Expected'); }
		r3 = TOKEN_LSHIFT; if (r0 == r3) { abort_b0('<< Expected'); }
		r3 = TOKEN_RROTATE; if (r0 == r3) { abort_b0('>>> Expected'); }
		r3 = TOKEN_LROTATE; if (r0 == r3) { abort_b0('<<< Expected'); }
		r3 = TOKEN_EQUALS; if (r0 == r3) { abort_b0('== Expected'); }
		r3 = TOKEN_NOTEQUALS; if (r0 == r3) { abort_b0('!= Expected'); }
		r3 = TOKEN_LESSTHAN; if (r0 == r3) { abort_b0('< Expected'); }
		r3 = TOKEN_GREATERTHAN; if (r0 == r3) { abort_b0('> Expected'); }
		r3 = TOKEN_LESSTHANEQUALS; if (r0 == r3) { abort_b0('<= Expected'); }
		r3 = TOKEN_GREATERTHANEQUALS; if (r0 == r3) { abort_b0('>= Expected'); }
		r3 = TOKEN_S_LESSTHAN; if (r0 == r3) { abort_b0('~< Expected'); }
		r3 = TOKEN_S_GREATERTHAN; if (r0 == r3) { abort_b0('~> Expected'); }
		r3 = TOKEN_S_LESSTHANEQUALS; if (r0 == r3) { abort_b0('~<= Expected'); }
		r3 = TOKEN_S_GREATERTHANEQUALS; if (r0 == r3) { abort_b0('~>= Expected'); }
		r3 = TOKEN_STRING; if (r0 == r3) { abort_b0('Start of String Expected'); }
		r3 = TOKEN_END_STRING; if (r0 == r3) { abort_b0('End of String Expected'); }
		r3 = TOKEN_PARA_START; if (r0 == r3) { abort_b0('( Expected'); }
		r3 = TOKEN_PARA_END; if (r0 == r3) { abort_b0(') Expected'); }
		r3 = TOKEN_POINTER; if (r0 == r3) { abort_b0('& Expected'); }
		r3 = TOKEN_ARRAY_START; if (r0 == r3) { abort_b0('[ Expected'); }
		r3 = TOKEN_ARRAY_END; if (r0 == r3) { abort_b0('] Expected'); }
		r3 = TOKEN_FULLSTOP; if (r0 == r3) { abort_b0('. Expected'); }
		r3 = TOKEN_NUM_INTEGER; if (r0 == r3) { abort_b0('Integer Immediate Expected'); }
		r3 = TOKEN_NUM_DECIMAL; if (r0 == r3) { abort_b0('Decimal Immediate Expected'); }
		abort_b0('Unknown Token');
	}
	pop r3;
	return(1);
}

proc callProc(who, return_reg, i){
	//int local_offset;
	m64 local_offset;
	m64 WarningIssued;
	push r1, r2, r3, r4;
	
	WarningIssued = 0;

	//if(DEBUG)
	//	printf("Processing Function call with target\n");
	
	r0 = DEBUG;
	if (r0){
		echo_string(STDOUT, 'Processing Function call with target\n');
	}
	//local_offset = 0;
	local_offset = 0;
	//token++
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	//TokenIs(TOKEN_PARA_START);
	TokenIs(TOKEN_PARA_START);
	//token++; // Move onto the next token
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	
	// First set our local variable block
	// All we do in save r0 (if required), push esi, and add the amount of space used to nearest 8 bytes
	//if (return_reg != HASH_r0)
	//	fprintf(code, "\tpush r0\n");
	r0 = return_reg;
	r1 = HASH_r0;
	if (r0 != r1){
		r0 = code;
		echo_string(r0, '\tpush r0\n');
	}
	
	//#ifndef i386
	//fprintf(code, "\tpush r6\n\tadd r6, 0%xh\n", (((hash_table[(global-HASH_OFFSET)].local_offset/8)+1)*8) );
	//#else
	//fprintf(code, "\tpush r6\n\tadd r6, 0%xh\n", (((hash_table[(global-HASH_OFFSET)].local_offset/4)+1)*4) );
	//#endif

	r0 = global;
	r0 = r0 - HASH_OFFSET;
	r2 = hash_table[r0].local_offset;
	r2 = r2 >> CPU_STACK_SIZE_SHIFT;	// div by stack size
	r2 = r2 + 1;
	r2 = r2 << CPU_STACK_SIZE_SHIFT;	// mul by stack size
	r1 = code;
	
	r0 = STACK_FRAME;
	if(r0){
		echo_string(r1, '\tpush r6\n\tadd r6, ');
		echo_hex(r1, r2);
		echo_cr(r1);
	}

	r0 = i;
	r1 = token;
	if(r1 >= r0){
		abort_b0('Unexpected end of procedure call');
	}

	
	//while (token_stack[token] != TOKEN_PARA_END){
	r3 = token;
	r2 = &token_stack;
	r3 = [r2+r3*8];
	r2 = TOKEN_PARA_END;
	while(r2 != r3){
		r0 = STACK_FRAME;
		r4 = 0;
		//if((STACK_FRAME == 0)&&(WarningIssued == 0)){
		if(r0 == r4){
			//issue warning that passing local variables, but stack frame has not been setup
			//if(HeaderPrinted == 0)
				//PrintHeader();
			r0 = WarningIssued;
			if(r0 == r4){
				r0 = WarningsDisabled;
				if(r0 == r4){
					r0 = HeaderPrinted;
					if(r0 == r4){
						PrintHeader();
					}
					//printf("WARNING: Stack frame creation has been disabled, current local variable\n frame will be overwritten\n");
					echo_string(STDOUT, 'WARNING: Stack frame creation has been disabled, current local variable\n frame will be overwritten during this procedure call\n');
					//printf("Filename: %s Line: %d.\n",file[file_stack_ptr].filename, (file[file_stack_ptr].line_count));
					echo_string(STDOUT, 'Filename: ');
					r4 = file_stack_ptr;
					r0 = &file[r4].filename;
					echo_string(STDOUT, r0);
					echo_string(STDOUT, ' Line: ');
					r0 = file[r4].line_count;
					echo_hex(STDOUT, r0);
					echo_string(STDOUT, '.\n');
				}
			}
			WarningIssued = 1;
		}
		//if ((token_stack[token] == TOKEN_STRING) || (token_stack[token] == TOKEN_POINTER)) {
		r4 = 0;
		r2 = TOKEN_STRING;
		if (r3 == r2){
			r4 = 1;
		}
		r2 = TOKEN_POINTER;
		if (r3 == r2){
			r4 = 1;
		}
		if (r4){
			//if (token_stack[token] == TOKEN_POINTER){
			//	token++;
			//}
			if (r3 == r2){
				r0 = token;
				r0 = r0 + 1;
				token = r0;
			}
			//TokenIs(TOKEN_STRING);
			TokenIs(TOKEN_STRING);
			//token++;
			r0 = token;
			r0 = r0 + 1;
			token = r0;
			
			//if (UTF8_STRINGS == 0){
			//	fprintf(data, "UTF16_STRING B0_DynStr%d , ", dynamic_string_count);
			//	outputString(i);
			//} else {
			//	fprintf(data, "UTF8_STRING B0_DynStr%d , ", dynamic_string_count);
			//	outputStringUTF8(i);
			//}
			r4 = data;
			r2 = dynamic_string_count;
			r3 = i;
			r0 = UTF8_STRINGS;
			if (r0){
				echo_string(r4, 'UTF8_STRING B0_DynStr');
				echo_hex(r4, r2);
				echo_string(r4, ' , ');
				outputString(r3);
			} else {
				echo_string(r4, 'UTF16_STRING B0_DynStr');
				echo_hex(r4, r2);
				echo_string(r4, ' , ');
				outputStringUTF8(r3);
			}
			
			//TokenIs(TOKEN_END_STRING);
			TokenIs(TOKEN_END_STRING);
			
			//#ifndef i386
			//fprintf(code, "\tpush r0\n\tmov r0, B0_DynStr%d\n\tmov qword [r6+0%xh], r0\n\tpop r0\n", dynamic_string_count, local_offset);
			//#else
			//fprintf(code, "\tpush r0\n\tmov r0, B0_DynStr%d\n\tmov dword [r6+0%xh], r0\n\tpop r0\n", dynamic_string_count, local_offset);
			//#endif
						// We place the string offset into r0, and then store it rather than using "mov mem64, imm64" as this opcode
						// doesn't exist! fasm truncates the immediate to 32bits to form a valid opcode.
			r4 = code;
			echo_string(r4, '\tpush r0\n\tmov r0, B0_DynStr');
			r2 = dynamic_string_count;
			echo_hex(r4, r2);
			#ifndef i386;
			echo_string(r4, '\n\tmov qword [r6+');
			#else;
			echo_string(r4, '\n\tmov dword [r6+');
			#endif;
			r2 = local_offset;
			echo_hex(r4, r2);
			echo_string(r4, '], r0\n\tpop r0\n');
			
			//dynamic_string_count++; // Inc the number of dynamic strings we have
			r2 = dynamic_string_count;
			r2 = r2 + 1;
			dynamic_string_count = r2;
			
		//} else {
		} else {
			//if ((token_stack[token] < TOKEN_OFFSET) || (token_stack[token] == TOKEN_MINUS)) {
			r4 = 0;
			r2 = TOKEN_NUM_INTEGER;
			if (r3 == r2){
				r4 = 1;
			}
			r2 = TOKEN_MINUS;
			if (r3 == r2){
				r4 = 1;
			}
			if(r4){
				// We have an immediate load
				//#ifndef i386
				//fprintf(code, "\tmov qword [r6+0%xh], ", local_offset);
				//#else
				//fprintf(code, "\tmov dword [r6+0%xh], ", local_offset);
				//#endif
				r4 = code;
				r2 = local_offset;
				#ifndef i386;
				echo_string(r4, '\tmov qword [r6+');
				#else;
				echo_string(r4, '\tmov dword [r6+');
				#endif;
				echo_hex(r4, r2);
				echo_string(r4, '], ');
				
				//if (token_stack[token] == TOKEN_MINUS) {
				//	token++;
				//	fprintf(code, "-");
				//}

				r2 = TOKEN_MINUS;
				if (r3 == r2){
					r0 = token;
					r0 = r0 + 1;
					token = r0;
					echo_string(r4, '-');
					
				}
				//outputNumber(i, NUM_INTEGER);
				r0 = i;
				outputNumber(r0, NUM_INTEGER, r4);
				//fprintf(code, "\n");
				echo_cr(r4);
				r0 = token;
				r0 = r0 - 1;
				token = r0;
			//} else {
			} else {
				//TokenIsLabelType(TYPE_REG); // Otherwise only accept 64bit registers
				TokenIsLabelType(TYPE_REG); // Otherwise only accept 64bit registers
				//fprintf(code, "\tmov [r6+0%xh], %s\n", local_offset, hash_table[token_stack[token]-HASH_OFFSET].token);
				r4 = code;
				r2 = local_offset;
				r3 = r3 - HASH_OFFSET;
				r3 = &hash_table[r3].token;
				echo_string(r4, '\tmov [r6+');
				echo_hex(r4, r2);
				echo_string(r4, '], ');
				echo_string(r4, r3);
				echo_cr(r4);
			}
		}
		//token++;
		r0 = token;
		r0 = r0 + 1;
		token = r0;
		//#ifndef i386
		//local_offset += 8; // Move the offset forward 8.
		//#else
		//local_offset += 4; // Move the offset forward 4.
		//#endif
		r0 = local_offset;
		r0 = r0 + CPU_STACK_SIZE;
		local_offset = r0;
		
		//if(token_stack[token] == TOKEN_COMMA)
		//	token++;
		r3 = token;
		r2 = &token_stack;
		r3 = [r2+r3*8];
		r2 = TOKEN_COMMA;
		if (r3 == r2){
			r0 = token;
			r0 = r0 + 1;
			token = r0;
		}
		
		r0 = i;
		r1 = token;
		if(r1 >= r0){
			abort_b0('Unexpected end of procedure call');
		}
		
		// refill the condition registers.
		r3 = token;
		r2 = &token_stack;
		r3 = [r2+r3*8];
		r2 = TOKEN_PARA_END;
	}
	r0 = i;
	r1 = token;
	if(r1 >= r0){
		abort_b0('Unexpected end of procedure call');
	}
	//TokenIs(TOKEN_PARA_END); // Final token should be the )
	TokenIs(TOKEN_PARA_END); // Final token should be the )
	//token++;
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	//atStackEnd(i);
	r0 = i;
	atStackEnd(r0);
	// Lets call our procedure
	//if (hash_table[who].token_type == TYPE_EPROC){
	//	if (SOURCE_TYPE != SOURCE_PE){
	//		fprintf(code, "\tcall %s\n", hash_table[who].token);
	//	} else {
	//		fprintf(code, "\tcall [%s]\n", hash_table[who].token);
	//	}
	//} else {
	//	fprintf(code, "\tcall _B0_%s\n", hash_table[who].token);		
	//}
	r1 = who;
	r0 = hash_table[r1].token_type;
	r3 = TYPE_EPROC;
	r2 = &hash_table[r1].token;
	r4 = code;
	if (r0 == r3){
		r3 = SOURCE_PE;
		r1 = SOURCE_TYPE;
		if (r1 != r3){
			r3 = SOURCE_DLL;
			if (r1 != r3){
				echo_string(r4, '\tcall ');
				echo_string(r4, r2);
				echo_cr(r4);
			} else {
				echo_string(r4, '\tcall [');
				echo_string(r4, r2);
				echo_string(r4, ']\n');
			}
		} else {
			echo_string(r4, '\tcall [');
			echo_string(r4, r2);
			echo_string(r4, ']\n');
		}
	} else {
		echo_string(r4, '\tcall _B0_');
		echo_string(r4, r2);
		echo_cr(r4);
	}
	
	// Reset esi to point to our local variables.
	//fprintf(code, "\tpop r6\n");	// Restore our frame pointer
	r0 = STACK_FRAME;
	if(r0){
		echo_string(r4, '\tpop r6\n');
	}
	
	//if (return_reg != HASH_r0){
	//	fprintf(code, "\tmov %s, r0\n", hash_table[return_reg].token); // Copy our result to the target reg
	//	fprintf(code, "\tpop r0\n"); // And restore r0, back to our default.
	//}
	r1 = return_reg;
	r0 = HASH_r0;
	if (r1 != r0){
		r2 = &hash_table[r1].token;
		echo_string(r4, '\tmov ');
		echo_string(r4, r2);
		echo_string(r4, ', r0\n\tpop r0\n');
	}
	pop r4, r3, r2, r1;
	return(1);
}

proc outputDynamicString(i){
	//token++;
	push r1, r2, r3, r4;
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	//Point to the first char.
	// dynamic_string_count = string number.
	
	//if (UTF8_STRINGS == 0){
	r0 = UTF8_STRINGS;
	if(r0){
		//fprintf(data, "UTF16_STRING B0_DynStr%d , ", dynamic_string_count);
		r4 = data;
		r3 = dynamic_string_count;
		echo_string(r4, 'UTF8_STRING B0_DynStr');
		echo_hex(r4, r3);
		echo_string(r4, ' , ');
		//outputString(i);
		r0 = i;
		outputString(r0);
	} else {
		//fprintf(data, "UTF8_STRING B0_DynStr%d , ", dynamic_string_count);
		r4 = data;
		r3 = dynamic_string_count;
		echo_string(r4, 'UTF16_STRING B0_DynStr');
		echo_hex(r4, r3);
		echo_string(r4, ' , ');
		//outputStringUTF8(i);
		r0 = i;
		outputStringUTF8(r0);
	}
	//fprintf(code, "\tmov %s, B0_DynStr%d\n", hash_table[target].token, dynamic_string_count);
	r4 = code;
	r3 = target;
	r3 = &hash_table[r3].token;
	r2 = dynamic_string_count;
	echo_string(r4, '\tmov ');
	echo_string(r4, r3);
	echo_string(r4, ', B0_DynStr');
	echo_hex(r4, r2);
	echo_cr(r4);
	//dynamic_string_count++; // Inc the number of dynamic strings we have
	r2 = r2 + 1;
	dynamic_string_count = r2;
	//token++;
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	pop r4, r3, r2, r1;
	return(1);
}

proc setDefine(def_hash, i){
	f64 fp_val;
	push r1, r2, r3, r4, r5, r8, r9;
	r5 = i;
	r2 = token;
	r3 = &token_stack;
	r3 = [r3+r2*8];
	r2 = 0;
	r4 = 0;
	r1 = TOKEN_MINUS;
	if (r3 == r1){
		r4 = 1;
	}
	r1 = CHAR_MINUS; // '-'
	if (r3 == r1){
		r4 = 1;
	}
	if(r4){
		r0 = token;
		r0 = r0 + 1;
		token = r0;
		if (r0 >= r5){
			abort_b0('Expected value1?');
		}
	}
	
	r2 = token;
	r3 = &token_stack;
	r3 = [r3+r2*8];
	
	r0 = TOKEN_NUM_DECIMAL;
	if(r0 == r3){
		r2 = r2 + 1;
		token = r2;
		if(r2 >= r5) { abort_b0('Expected value2?'); }
		r3 = &token_stack;
		r1 = &fp_val;
		r0 = [r3+r2*8];
		[r1] = r0;
		fp0 = fp_val;
		if (r4){
			-fp0;
		}
		fp_val = fp0;
		r0 = &fp_val;
		r1 = [r1];
		r0 = def_hash;
		r2 = TYPE_DEFINE + TYPE_F64;
		r0 = &hash_table[r0];
		[r0+hash_table_struc.token_type] = r2;
		[r0+hash_table_struc.define_fp] = r1;
				
	} else {
		r0 = TOKEN_NUM_INTEGER;
		if(r0 == r3){
			r2 = r2 + 1;
			token = r2;
			if(r2 >= r5) { abort_b0('Expected value3?'); }
			r3 = &token_stack;
			r2 = [r3+r2*8];
			if (r4){
				r0 = r2 << 1;
				if(%CARRY){
					abort_b0('Integer too large to made signed value');
				}
				-r2;
			}
			r0 = def_hash;
			r1 = TYPE_DEFINE + TYPE_MAX_REG;
			r0 = &hash_table[r0];
			[r0+hash_table_struc.token_type] = r1;
			[r0+hash_table_struc.define_int] = r2;
		} else {
			r0 = TOKEN_STRING;
			if(r0 == r3){
				r2 = r2 + 1;
				token = r2;
				if(r2 >= r5) { abort_b0('Expected value5?'); }
				r3 = &token_stack;
				//r2 = [r3+r2*8];
				r0 = def_hash;
				r1 = TYPE_DEFINE + TYPE_M8;
				r0 = &hash_table[r0];
				[r0+hash_table_struc.token_type] = r1;
				r1 = TOKEN_MAX_SIZE / 8 - 2;
				r0 = r0 + hash_table_struc.token_import_name;
				r4 = [r3+r2*8];
				r8 = TOKEN_END_STRING;
				r9 = 0;
				while(r4 != r8){
					[r0] = r4;
					[r0+8] = r9;	// NULL terminate the beast.
					r0 = r0 + 8;
					r2 = r2 + 1;
					r4 = [r3+r2*8];
					r1 = r1 - 1;
					if(r1 == r9){
						abort_b0('Defined string too long?');
					}
				}
				//r2 = r2 + 1;
				token = r2;
			} else {
				abort_b0('Expected value4?');
			}
		}
	}
	
	r0 = DEBUG;
	if (r0){
		r1 = def_hash;
		echo_string(STDOUT, 'setDefine(); define ');
		r0 = &hash_table[r1].token;
		echo_string(STDOUT, r0);
		echo_string(STDOUT, '; type ');
		r0 = hash_table[r1].token_type;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '; value ');
		r0 = hash_table[r1].define_int;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, ' or ');
		fp0 = hash_table[r1].define_fp;
		echo_float(STDOUT);			// echo_float destroys fp0;
		echo_cr(STDOUT);
	}
	r0 = token;
	r0 = r0 + 1;
	token = r0;		// move token past the actual number;
	pop r9, r8, r5, r4, r3, r2, r1;
	return(1);
}

proc checkDefine(def_hash, comparison, i){
	// def_hash = the hash we are testing
	// comparision = the test
	// i = end of token_stack.
	// token = current start of string of the number to test against.
	//int isNeg = 0;
	//int isFP = 0;  		// 0 = int, 1 = fp (decimal), 2 = hex (aka int)
	//long value;			// Our value
	//double fp_value;		// Our value in fp
	//double fp_value2;	//
	
	m64 isFP;
	m64 value;
	m64 value2;
	f64 fp_value;
	f64 fp_value2;
	
	//if ((token_stack[token] == TOKEN_MINUS)||(token_stack[token] == '-')){
	//	isNeg = 1;
	//	token++;
	//	if(token == i)
	//		abort_b0("Expected value?");
	//}

	push r1, r2, r3, r4, r5;
	r0 = DEBUG;
	if(r0){
		echo_string(STDOUT, 'CheckDefine();\n');
	}
	r4 = token;
	r5 = &token_stack;
	r3 = [r5+r4*8];
	r2 = 0;
	isFP = r2;
	r1 = TOKEN_MINUS;
	if (r3 == r1){
		r2 = 1;			// isNeg
		r4 = r4 + 1;
		token = r4;
		r1 = i;
		if (r4 >= r1){
			abort_b0('Expected value?');
		}
	}
	r3 = [r5+r4*8];
	r4 = r4 + 1;
	token = r4;
	r0 = TOKEN_NUM_INTEGER;
	if(r3 == r0){
		// We have an integer;
		r3 = [r5+r4*8];
		if(r2){
			r0 = r3 << 1;
			if(%CARRY){
				abort_b0('Integer too large to make signed value');
			}
			-r3;
		}
		value = r3;
	} else {
		r0 = TOKEN_NUM_DECIMAL;
		if(r3 == r0){
			// We have a decimal value;
			r0 = &fp_value;
			r1 = [r5+r4*8];
			[r0] = r1;
			fp0 = fp_value;
			if(r2){
				-fp0;
			}
			isFP = 1;
			fp_value = fp0;
		} else {
			abort_b0('Expected value?');
		}
	}
	r4 = r4 + 1;
	token = r4;
	r1 = i;
	atStackEnd(r1);
	
	// Our test values have been loaded
	// Check to see if our hash is a DEFINE or exists?
	//if ((hash_table[def_hash].token_type & TYPE_DEFINE) != TYPE_DEFINE)
		//return(0); // Isn't a define or doesn't exist, then exit
	r1 = def_hash;
	r0 = TYPE_DEFINE;
	r2 = hash_table[r1].token_type;
	r2 = r2 && r0;
	if (r2 != r0){
		pop r5, r4, r3, r2, r1;
		return(0);
	}
		
	//if ((hash_table[def_hash].token_type & TYPE_F64) == TYPE_F64){
	r1 = def_hash;
	r2 = hash_table[r1].token_type;
	r0 = TYPE_M8;	
	r2 = r2 && r0;
	if(r2 != r0){
		r2 = hash_table[r1].token_type;
		r0 = TYPE_F64;
		r2 = r2 && r0;
		if (r2 == r0){
			fp0 = hash_table[r1].define_fp;
			fp_value2 = fp0;
			r0 = isFP;
			r1 = 0;
			if(r0 == r1){
				fp0 = value;
				fp_value = fp0;
				isFP = 1;
				r1 = DEBUG;
				if(r1){
					echo_string(STDOUT, 'loading fp_value with int\n');
				}
			}
		} else {
			r0 = isFP;
			if(r0){
				fp0 = hash_table[r1].define_int;
				r1 = DEBUG;
				if(r1){
					echo_string(STDOUT, 'loading fp_value2 with int\n');
				}
			} else {
				r0 = hash_table[r1].define_int;
				value2 = r0;
			}
		}
	} else {
		// It's a string, so let go yes, it exists.
		pop r5, r4, r3, r2, r1;
		return(1);
	}

	r0 = isFP;
	if(r0){
		fp0 = fp_value;		// loaded value
		fp0 = fp_value2;	// define value
		r0 = 0;
		r2 = comparison;
		r1 = TOKEN_EQUALS; if (r1 == r2) { if (fp0 == fp1) { r0 = 1; } }
		r1 = TOKEN_NOTEQUALS; if (r1 == r2) { if (fp0 != fp1) { r0 = 1; } }
		r1 = TOKEN_LESSTHAN; if (r1 == r2) { if (fp0 < fp1) { r0 = 1; } }
		r1 = TOKEN_GREATERTHAN; if (r1 == r2) { if (fp0 > fp1) { r0 = 1; } }
		r1 = TOKEN_LESSTHANEQUALS; if (r1 == r2) { if (fp0 <= fp1) { r0 = 1; } }
		r1 = TOKEN_GREATERTHANEQUALS; if (r1 == r2) { if (fp0 >= fp1) { r0 = 1; } }
		r1 = TOKEN_S_LESSTHAN; if (r1 == r2) { if (fp0 < fp1) { r0 = 1; } }
		r1 = TOKEN_S_GREATERTHAN; if (r1 == r2) { if (fp0 > fp1) { r0 = 1; } }
		r1 = TOKEN_S_LESSTHANEQUALS; if (r1 == r2) { if (fp0 >= fp1) { r0 = 1; } }
		r1 = TOKEN_S_GREATERTHANEQUALS; if (r1 == r2) { if (fp0 <= fp1) { r0 = 1; } }
	} else {
		r4 = value;			// loaded value
		r3 = value2;		// define value
		r0 = 0;
		r2 = comparison;
		r1 = TOKEN_EQUALS; if (r1 == r2) { if (r3 == r4) { r0 = 1; } }
		r1 = TOKEN_NOTEQUALS; if (r1 == r2) { if (r3 != r4) { r0 = 1; } }
		r1 = TOKEN_LESSTHAN; if (r1 == r2) { if (r3 < r4) { r0 = 1; } }
		r1 = TOKEN_GREATERTHAN; if (r1 == r2) { if (r3 > r4) { r0 = 1; } }
		r1 = TOKEN_LESSTHANEQUALS; if (r1 == r2) { if (r3 <= r4) { r0 = 1; } }
		r1 = TOKEN_GREATERTHANEQUALS; if (r1 == r2) { if (r3 >= r4) { r0 = 1; } }
		r1 = TOKEN_S_LESSTHAN; if (r1 == r2) { if (r3 < r4) { r0 = 1; } }
		r1 = TOKEN_S_GREATERTHAN; if (r1 == r2) { if (r3 > r4) { r0 = 1; } }
		r1 = TOKEN_S_LESSTHANEQUALS; if (r1 == r2) { if (r3 >= r4) { r0 = 1; } }
		r1 = TOKEN_S_GREATERTHANEQUALS; if (r1 == r2) { if (r3 <= r4) { r0 = 1; } }
	}
	pop r5, r4, r3, r2, r1;
	return(r0);
}

proc scan_env(str){
	//int i; - we'll use r10 for this.
	//if (total_paths > PATHS_MAX)
		//return;		//buffer already full
	push r1, r2;
	r2 = total_paths;
	r1 = PATHS_MAX;
	if (r2 > r1){
		pop r2, r1;
		return(0);
	}
	push r3, r4, r5, r8, r9, r10, r11;
	r11 = FILENAME_MAX;
	r0 = 0;
	r4 = str;
	r0b = [r4];
	r10 = 0;
	//while(*str){
	while(r0){
		//i = 0;
		r5 = &paths;
		r3 = r2 << 8;	// Multiply by 256 (We assume that FILENAME MAX = 256;)
		r5 = r5 + r3;
		r5 = r5 + 2;	// Add in offset for size bytes.
		//while((*str != ';')&&(*str)){
		r8 = PATH_SEPARATOR;
		r9 = 0;
		if (r0 != r9){
			if (r0 != r8){
				r9 = 1;
			}
		}
		while(r9){
			//paths[total_paths][i] = *str++;
			[r5+r10] = r0b;
			r4 = r4 + 1;
			r0 = 0;
			r0b = [r4];
			//i++;
			r10 = r10 + 1;
			//if (i >= FILENAME_MAX)
				//abort_b0("File path supplied too large");
			if (r10 >= r11){
				abort_b0('File path supplied too large');
			}
			r9 = 0;
			if (r0 != r9){
				if (r0 != r8){
					r9 = 1;
				}
			}
		//}
		}
		//if(paths[total_paths][i-1] != '/')
			//paths[total_paths][i++] = '/'; // add terminating slash if not there
		r0b = [r5+r10-1];
		r8 = 2fh;
		if (r0 != r8){
			[r5+r10] = r8b;
			r10 = r10 + 1;
		}
		//paths[total_paths][i] = '\0';		 // Null terminate the string.
		r0 = 0;
		[r5+r10] = r0w;
		//total_paths++;
		r2 = r2 + 1;
		total_paths = r2;
		//if (total_paths >= PATHS_MAX)
			//return;  // Return, as the path buffer is now full.
		if(r2 >= r1){
			pop r11, r10, r9, r8, r5, r4, r3, r2, r1;
			return(0);
		}
		//if (!*str)
			//return;
		r0b = [r4];
		r10 = 0;
		if (r0 == r10){
			pop r11, r10, r9, r8, r5, r4, r3, r2, r1;
			return(0);
		}
		//*str++;
		r4 = r4 + 1;
		r0 = 0;
		r0b = [r4];
	//}
	}
	pop r11, r10, r9, r8, r5, r4, r3, r2, r1;
}

proc if_while_block(i){
	//atStackStart();
	push r1, r2, r3, r4, r5;
	atStackStart();
	r5 = DEBUG;
	if(r5){
		echo_string(STDOUT, 'Processing if_while_block()\n');
	}
	//if (ch != '{')	// While statements are to be followed immediately by a block.
		//abort_b0("{ Expected");
	r0 = ch;
	r1 = CHAR_OCPARAN;
	if (r0 != r1){
		abort_b0('{ Expected');
	}
	//if_while_stack[block_level].type = (token_stack[0]-HASH_OFFSET);
	r2 = &token_stack;
	r1 = HASH_OFFSET;
	r3 = [r2];
	r3 = r3 - r1;
	r0 = block_level;
	if_while_stack[r0].type = r3;
	
	//if ((token_stack[0]-HASH_OFFSET) == HASH_while)
		//block_num++;
	r1 = HASH_while;
	r4 = block_num;
	if (r3 == r1){
		r4 = r4 + 1;
		block_num = r4;
	}
		
	//if_while_stack[block_level].offset = block_num;
	if_while_stack[r0].offset = r4;
	
	//TokenIs(TOKEN_PARA_START);
	TokenIs(TOKEN_PARA_START);
	//token++; // Lets see what we are testing?
	r5 = token;
	r5 = r5 + 1;
	token = r5;
	//if (token_stack[token] == TOKEN_PARA_END) 
		//abort_b0("Unexpected ')'");
	r0 = [r2+r5*8];
	r1 = TOKEN_PARA_END;
	if (r0 == r1){
		abort_b0('Unexpected \')\'');
	}
		
	// Process the first item...
	//if ((token_stack[token] < HASH_OFFSET) && (token_stack[token] != TOKEN_MODULUS))
		//abort_b0("Expected Token/Label");
	r1 = TOKEN_MODULUS;
	if (r0 != r1){
		r1 = HASH_OFFSET;
		if (r0 < r1){
			abort_b0('Expected Token/Label');
		}
	}
	//if (token_stack[token] == TOKEN_MODULUS)
		//token++;		// Skip past this flag marker
	r1 = TOKEN_MODULUS;
	if(r0 == r1){
		r5 = r5 + 1;
		token = r5;
	}
	r0 = [r2+r5*8];
	r1 = HASH_OFFSET;
	r0 = r0 - r1;
	r1 = hash_table[r0].token_type;
	r4 = TYPE_FLAG;
	//if (((hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_REG) && (hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_REG_FPU)) && (hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_FLAG))
		//#ifndef i386
		//abort_b0("Expected 64bit Register, FPU Register or CPU Flag");
		//#else
		//abort_b0("Expected 32bit Register, FPU Register or CPU Flag");
		//#endif
	if(r1 != r4){
		r4 = TYPE_REG;
		if (r1 != r4){
			r4 = TYPE_REG_FPU;
			if (r1 != r4){
				#ifndef i386;
				abort_b0('Expected 64bit Register, FPU Register or CPU Flag');
				#else;
				abort_b0('Expected 32bit Register, FPU Register or CPU Flag');
				#endif;
			}
		}
	}
	
	//if (hash_table[(token_stack[token]-HASH_OFFSET)].token_type == TYPE_FLAG){
		//if (token_stack[(token-1)] != TOKEN_MODULUS)
		//#ifndef i386
			//abort_b0("Expected 64bit Register, FPU Register or CPU Flag");
		//#else
			//abort_b0("Expected 32bit Register, FPU Register or CPU Flag");
		//#endif
	//}
	r4 = TYPE_FLAG;
	if(r1 == r4){
		r4 = TOKEN_MODULUS;
		r1 = [r2+r5*8-8];
		if (r1 != r4){
			#ifndef i386;
			abort_b0('Expected 64bit Register, FPU Register or CPU Flag');
			#else;
			abort_b0('Expected 32bit Register, FPU Register or CPU Flag');
			#endif;
		}
	}
	
	//if_while_stack[block_level].if_while_test1 = hash_table[(token_stack[token]-HASH_OFFSET)].hash; 
	r1 = hash_table[r0].hash;
	r4 = block_level;
	if_while_stack[r4].if_while_test1 = r1;
	
	//token++;	// goto the next token?
	r5 = r5 + 1;
	token = r5;
	
	//if (token_stack[token] == TOKEN_PARA_END) {
		// Looks like we are testing against zero?
		//if_while_stack[block_level].comparison = TOKEN_NOTEQUALS;
		//if_while_stack[block_level].if_while_test2 = HASH_zero;
		//token++;
		//atStackEnd(i);
		//return(0);
	//} 
	r0 = [r2+r5*8];
	r1 = TOKEN_PARA_END;
	if (r0 == r1){
		r1 = TOKEN_NOTEQUALS;
		if_while_stack[r4].comparison = r1;
		r1 = HASH_zero;
		if_while_stack[r4].if_while_test2 = r1;
		r5 = r5 + 1;
		token = r5;
		r5 = i;
		atStackEnd(r5);
		pop r5, r4, r3, r2, r1;
		return(0);
	}
	

	//if ((token_stack[token] < TOKEN_EQUALS) || (token_stack[token] > TOKEN_GREATERTHAN))
		//abort_b0("Expected comparison test");
	r1 = TOKEN_EQUALS;
	r0 = r0 - r1;
	r1 = TOKEN_GREATERTHAN - TOKEN_EQUALS;
	if (r0 > r1){
		abort_b0('Expected comparison test');
	}
	
	//if (hash_table[if_while_stack[block_level].if_while_test1].token_type == TYPE_FLAG)
		//abort_b0("Expected ) - Comparisons cannot be performed on flags?");
	r1 = if_while_stack[r4].if_while_test1;
	r0 = hash_table[r1].token_type;
	r1 = TYPE_FLAG;
	if (r0 == r1){
		abort_b0('Expected ) - Comparisons cannot be performed on flags?');
	}
		
	//token++;
	r5 = r5 + 1;
	token = r5;
	
	//if (token_stack[token] < HASH_OFFSET) 
		//abort_b0("Expected Token/Label");
	r0 = [r2+r5*8];
	r1 = HASH_OFFSET;
	if (r0 < r1){
		r3 = TOKEN_NUM_INTEGER;
		if(r0 != r3){
			abort_b0('Expected Token/Label');
		}
		// Handle second operand being an integer.
		r5 = r5 + 1;
		token = r5;
		r0 = [r2+r5*8];
		if(r0){
			// Must be zero
			abort_b0('Comparison must be against zero (0)');
		}
		r0 = HASH_zero;
		if_while_stack[r4].if_while_test2 = r0;
	} else {
	
		//if ((hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_REG) && (hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_REG_FPU))
			//#ifndef i386
			//abort_b0("Expected 64bit or FPU Register");
			//#else
			//abort_b0("Expected 32bit or FPU Register");
			//#endif
		r3 = r0 - r1;
		r1 = hash_table[r3].token_type;
		r0 = TYPE_REG;
		if(r0 != r1){
			r0 = TYPE_REG_FPU;
			if(r0 != r1){
				#ifndef i386;
				abort_b0('Expected 64bit or FPU Register');
				#else;
				abort_b0('Expected 32bit or FPU Register');
				#endif;
			}
		}
	
	
		//if_while_stack[block_level].if_while_test2 = hash_table[(token_stack[token]-HASH_OFFSET)].hash;
		r0 = hash_table[r3].hash;
		if_while_stack[r4].if_while_test2 = r0;
	}
	//token++;
	r5 = r5 + 1;
	token = r5;
	//TokenIs(TOKEN_PARA_END);
	TokenIs(TOKEN_PARA_END);
	//if_while_stack[block_level].comparison = token_stack[(token-2)]; // Save the type of test for later
	r0 = HASH_zero;
	r1 = if_while_stack[r4].if_while_test2;
	if(r0 != r1){
		r0 = [r2+r5*8-16];
	} else {
		r0 = [r2+r5*8-24];
	}
	if_while_stack[r4].comparison = r0;
	//token++;
	r5 = r5 + 1;
	token = r5;
	//atStackEnd(i);
	r0 = i;
	atStackEnd(r0);
	pop r5, r4, r3, r2, r1;
	//return(0);
	return(0);
}

proc ScanForDupStrucLabel(dest_table, source_hash){
	//unsigned int j; // Count of hashes to check
	// I'll use r2 = j;
	//struc_struc *ptr_struc; // Pointer to struc
	// I'll use r1 = ptr_struc;
	push r1, r2, r3, r4, r5;
	//ptr_struc = hash_table[dest_table].struc_ptr;
	r0 = dest_table;
	r1 = hash_table[r0].struc_ptr;
	r3 = hash_table[r0].local_offset;
	r2 = 0;
	r4 = source_hash;
	//for (j = 0; j < hash_table[dest_table].local_offset; j++){
	while (r2 < r3){
		//if (ptr_struc->struc[j].hash == source_hash)
			//abort_b0("Duplicate label found when constructing structure");
		// make r5 = hash value in struc;
		r0 = r2 << 5;  // each struct entry is 32bytes in size.
		r5 = [r1+r0+struct_entry.hash];
		if (r5 == r4){
			abort_b0('Duplicate label found when constructing structure');
		}
		r2 = r2 + 1;
	//}
	}
	pop r5, r4, r3, r2, r1;
}

//unsigned int BuildLabelInfo(unsigned int i){
proc BuildLabelInfo(i){
	//struc_struc *struc_ptr;			// Pointer to variable structure
	//unsigned j;
	push r1, r2, r3, r4, r5, r8;
	//v_base = token_stack[token]-HASH_OFFSET;
	r1 = token;
	r2 = &token_stack;
	r2 = [r2+r1*8];
	r1 = HASH_OFFSET;
	r2 = r2 - r1;
	v_base = r2;
	//SetState();
	SetState();
	//v_offset_type = state;
	r0 = state;
	v_offset_type = r0;
	//if ((hash_table[v_base].token_type & TYPE_GLOBAL) == TYPE_GLOBAL) {
		//v_global = 1;
	//} else {
		//v_global = 0;
	//}
	r0 = hash_table[r2].token_type;
	r3 = TYPE_GLOBAL;
	r4 = r0 && r3;
	if (r4 == r3){
		v_global = 1;
	} else {
		v_global = 0;
	}
	//if ((hash_table[v_base].token_type & TYPE_VSTRUC) == TYPE_VSTRUC) {
		//v_isStruc = 1;
		//v_size = hash_table[v_base].local_offset;
	r3 = TYPE_VSTRUC;
	r4 = r0 && r3;
	if(r4 == r3){
		v_isStruc = 1;
		r4 = hash_table[r2].local_offset;
		v_size = r4;
	//} else {
	} else {
		//v_isStruc = 0;
		v_isStruc = 0;
		//switch(state){
			//case 'b': v_size = 1; break;
			//case 'w': v_size = 2; break;
			//#ifndef i386
			//case 'd': v_size = 4; break;
			//case ' ': v_size = 8; break;
			//#else
			//case ' ': v_size = 4; break;
			//#endif
			//case '3': v_size = 4; break;
			//case '6': v_size = 8; break;
			//case '8': v_size = 10; break;
		//}
		r0 = state;
		r1 = CHAR_b; 
		if (r0 == r1){
			v_size = 1;
		} else {
			r1 = CHAR_w; //w;
			if (r0 == r1){
				//is word
				v_size = 2;
			} else {
				#ifndef i386;
				r1 = CHAR_d; //d;
				#else;
				r1 = CHAR_SPACE; //space;
				#endif;
				if (r0 == r1){
					//is dword;
					v_size = 4;
				} else {
					r1 = CHAR_SPACE; // space;
					if(r0 == r1){
						v_size = 8;
					} else {
						r1 = CHAR_3;//3;
						if(r0 == r1){
							v_size =4;
						} else {
							r1 = CHAR_6;//6;
							if (r0 == r1){
								v_size = 8;
							} else {
								r1 = CHAR_8;
								if(r0 == r1){
									v_size = 10;
								} else {
									// Must be Vector Op
									v_size = 16;
								}
							}
						}
					}
				}
			}
		}
	}
	//}

	//if(DEBUG)
		//printf("v_isStruc = %d; v_global = %d\n", v_isStruc, v_global);
	r1 = DEBUG;
	if(r1){
		echo_string(STDOUT, 'BuildLabelInfo v_isStruc = ');
		r1 = v_isStruc;
		echo_hex(STDOUT, r1);
		echo_string(STDOUT, '; v_global = ');
		r1 = v_global;
		echo_hex(STDOUT, r1);
		echo_cr(STDOUT);
	}
	//token++;
	r5 = token;
	r5 = r5 + 1;
	token = r5;
	//if (token == i)
		//return(0);
	r1 = i;
	if (r1 == r5){
		pop r8, r5, r4, r3, r2, r1;
		return(0);
	}
	//if (token_stack[token] == TOKEN_ARRAY_START){
	r2 = &token_stack;
	r3 = [r2+r5*8];
	r1 = TOKEN_ARRAY_START;
	if (r1 == r3){
		//if(DEBUG)
			//printf("Array index value defined\n");
		r1 = DEBUG;
		if(r1){
			echo_string(STDOUT, 'Array index value defined\n');
		}
		//token++;
		r5 = r5 + 1;
		token = r5;
		//v_index = token;
		v_index = r5;
		//if (token_stack[token] == TOKEN_ARRAY_END)
			//abort_b0("Unexpected ]");
		r3 = [r2+r5*8];
		r1 = TOKEN_ARRAY_END;
		if(r1 == r3){
			abort_b0('Unexpected ]');
		}
		//while ((token_stack[token] != TOKEN_ARRAY_END)&&(token != i)){
			//token++;
		//}
		r0 = i;
		r4 = 0;
		if (r3 != r1){
			if(r5 != r0){
				r4 = 1;
			}
		}
		while (r4){
			r5 = r5 + 1;
			token = r5;
			r3 = [r2+r5*8];
			r4 = 0;
			if (r3 != r1){
				if(r5 != r0){
					r4 = 1;
				}
			}
		}
			
		//if (token == i)
			//abort_b0("Unexpected end of instruction");
		if (r5 == r0){
			abort_b0('Unexpected end of instruction');
		}
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//token++;
		r5 = r5 + 1;
		token = r5;
	//}
	}
	//if (token == i)
		//return(0);
	r0 = i;
	if (r5 == r0){
		pop r8, r5, r4, r3, r2, r1;
		return(0);
	}
	r3 = [r2+r5*8];
	r1 = TOKEN_FULLSTOP;
	if(r3 == r1){
	//if (token_stack[token] == TOKEN_FULLSTOP) {
		//We have a sub-object of a larger structure;
		//if (DEBUG)
			//printf("Sub-element of variable, eg a structure is being used\n");
		r1 = DEBUG;
		if(r1){
			echo_string(STDOUT, 'Sub-element of variable, eg a structure is being used3\n');
		}
		// Now let's find the sub-object within the structure information.
		//if (v_isStruc == 0)
			//abort_b0("Structure element defined on Non-structure variable");
		r4 = v_isStruc;
		r1 = 0;
		if(r4 == r1){
			abort_b0('Structure element defined on Non-structure variable');
		}
		//token++;
		r5 = r5 + 1;
		token = r5;
		// token now points to the hash of the struc sub-object.
		//isHash(token_stack[token]);
		r3 = [r2+r5*8];
		isHash(r3);
		//struc_ptr = hash_table[v_base].struc_ptr;
		r1 = v_base;
		r4 = hash_table[r1].struc_ptr;
		//struc_ptr = r4;
		//if(DEBUG)
			//printf(" struc_ptr = %p\n", struc_ptr);
		r0 = DEBUG;
		if(r0){
			echo_string(STDOUT, ' struc_ptr = ');
			echo_hex(STDOUT, r4);
			echo_cr(STDOUT);
		}
		//j = 0;
		// use r8 for j;
		r8 = 0;  // our pointer into the struc table.
		r1 = r8;
		r5 = r8;
		r0 = HASH_OFFSET;
		r3 = r3 - r0;
		r2 = r8 << 5;
		r0 = [r4+r2+struct_entry.hash];
		if (r0 != r5){
			if(r0 != r3){
				r1 = 1;
			}
		}
		//while ((struc_ptr->struc[j].hash != token_stack[token]-HASH_OFFSET) &&
				//(struc_ptr->struc[j].hash != 0))
					//j++;
		r1 = 1;
		while(r1){
			r1 = 0;
			r2 = r8 << 5;
			r0 = [r4+r2+struct_entry.hash];
			if(r0 != r5){
				if(r0 != r3){
					r1 = 1;
					r8 = r8 + 1;
				}
			}
			push r0, r8;
			r8 = r0;
			r0 = DEBUG;
			if(r0){
				echo_string(STDOUT, 'Testing hash: ');
				echo_hex(STDOUT, r8);
				echo_string(STDOUT, ' => ');
				echo_hex(STDOUT, r3);
				echo_cr(STDOUT);
			}
			pop r8, r0;

		}
		//if (struc_ptr->struc[j].hash == 0)
			//abort_b0("Structure does not contain sub-object defined");
		if(r0 == r5){
			abort_b0('Structure does not contain sub-object defined3');
		}
		//v_offset_type = struc_ptr->struc[j].type & 0xf;
		r0 = [r4+r2+struct_entry.type];
		r0 = r0 && 0fh;
		v_offset_type = r0;
		//switch(v_offset_type){
			//case TYPE_M8: state = 'b'; break;
			//case TYPE_M16: state = 'w'; break;
			//#ifndef i386
			//case TYPE_M32: state = 'd'; break;
			//case TYPE_M64: state = ' '; break;
			//#else
			//case TYPE_M32: state = ' '; break;
			//#endif
			//case TYPE_F32: state = '3'; break;
			//case TYPE_F64: state = '6'; break;
			//case TYPE_F80: state = '8'; break;		
		//}
		r1 = TYPE_M8;
		if (r0 == r1){
			state = CHAR_b; // 'b'
		} else {
			r1 = TYPE_M16;
			if (r0 == r1){
				state = CHAR_w; // 'w'
			} else {
				r1 = TYPE_M32;
				if (r0 == r1){
					#ifndef i386;
					state = CHAR_d; // 'd'
					#else;
					state = CHAR_SPACE; // space;
					#endif;
				} else {
					r1 = TYPE_M64;
					if(r0 == r1){
						state = CHAR_SPACE; // space;
					} else {
						r1 = TYPE_F32;
						if(r0 == r1){
							state = CHAR_3; // '3'
						} else {
							r1 = TYPE_F64;
							if (r0 == r1){
								state = CHAR_6; // '6'
							} else {
								r1 = TYPE_F80;
								if(r0 == r1){
									state = CHAR_8; // '8'
								} else {
									r1 = TYPE_V4I;
									if(r0 == r1){
										state = CHAR_U;
									} else {
										r1 = TYPE_V4F;
										if(r0 == r1){
											state = CHAR_V;
										} else {
											r1 = TYPE_V2F;
											if(r0 == r1){
												state = CHAR_W;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		// We had better ensure that state was set correctly
		//v_offset_type = state;
		r0 = state;
		v_offset_type = r0;
		//v_offset = struc_ptr->struc[j].offset;
		r0 = [r4+r2+struct_entry.offset];
		v_offset = r0;
		
		// When operating with variable structures, .local_offset is the size of the structure. 
		// Read it's offset to get the size of the structure.
		
		//v_size = hash_table[v_base].local_offset;
		r0 = v_base;
		r0 = hash_table[r0].local_offset;
		v_size = r0;
		//token++;
		r5 = token;
		r5 = r5 + 1;
		token = r5;
	//}
	}
	//if(token == i)
		//return(0);
	r0 = i;
	if(r5 == r0){
		pop r8, r5, r4, r3, r2, r1;
		return(0);
	}
	//TokenIs(TOKEN_EQUATE);
	TokenIs(TOKEN_EQUATE);
	//return(0);
	pop r8, r5, r4, r3, r2, r1;
	return(0);
//} 
}

proc Set_v_reg(){

	#ifndef i386;
	#define v_reg15 = HASH_r15;
	#define v_reg14 = HASH_r14;
	#else;
	#define v_reg15 = HASH_r5;
	#define v_reg14 = HASH_r4;
	#endif;
	//if (v_index == 0) {
		//v_reg = HASH_r6;
	//} else {
		//if (token_stack[v_index] > TOKEN_OFFSET){
			//if(token_stack[v_index]-HASH_OFFSET != HASH_r6){
				//v_reg = HASH_r6;					
			//} else {
				//#ifndef i386
				//v_reg = HASH_r15; // This should never happen?
				//#else
				//v_reg = HASH_r5; // This should never happen?
				//#endif
			//}
		//} else {
			//v_reg = HASH_r6;
		//}				
	//}
	push r1, r2, r3, r4, r5;
	r0 = v_index;
	r1 = 0;
	r2 = &token_stack;
	r2 = [r2+r0*8];
	r4 = HASH_OFFSET;
	r5 = r2 - r4;
	if(r0 == r1){
		v_reg = HASH_r6;
	} else {
		r1 = HASH_r6;
		if (r2 >= r4){		// If we have a HASH then it must be a reg?
			if(r5 != r1){
				v_reg = r1;
			} else {
				v_reg = v_reg15;
			}
		} else {
			v_reg = r1;
		}
	}

	//if (token_stack[v_target] > TOKEN_OFFSET) {
		//#ifndef i386
		//if (v_reg == HASH_r15){
		//#else
		//if (v_reg == HASH_r5){
		//#endif
			// Our index is HASH_r6!
			//#ifndef i386
			//if (token_stack[v_target]-HASH_OFFSET == HASH_r15)
				//v_reg = HASH_r14;
			//#else
			//if (token_stack[v_target]-HASH_OFFSET == HASH_r5)
 				//v_reg = HASH_r4;
			//#endif
		//} else {
			//if (token_stack[v_target]-HASH_OFFSET == HASH_r6){
				// Just check that the index isn't r15 first!
				//if (v_index == 0){
					//#ifndef i386
					//v_reg = HASH_r15;
					//#else
					//v_reg = HASH_r5;
					//#endif
				//} else {
					//if (token_stack[v_index] > TOKEN_OFFSET) {
						//#ifndef i386
						//if (token_stack[v_index]-HASH_OFFSET == HASH_r15){
							//v_reg = HASH_r14;
						//#else
						//if (token_stack[v_index]-HASH_OFFSET == HASH_r5){
							//v_reg = HASH_r4;						
						///#endif
						//} else {
							//#ifndef i386
							//v_reg = HASH_r15;
							//#else
							//v_reg = HASH_r5;
							//#endif
						//}
					//}
				//}
			//}
		//}
	//}
	r0 = v_index;
	r2 = &token_stack;
	r2 = [r2+r0*8];
	if(r2 >= r4){
		r1 = v_reg15;
		r0 = v_reg;
		if (r0 == r1){
			//Our index is HASH_r6!
			r2 = &token_stack;
			r0 = v_target;
			r2 = [r2+r0*8];
			r2 = r2 - HASH_OFFSET;
			if(r1 == r2){
				v_reg = v_reg14;
			}
		} else {
			r2 = &token_stack;
			r0 = v_target;
			r2 = [r2+r0*8];
			r2 = r2 - HASH_OFFSET;
			r1 = HASH_r6;
			if(r1 == r2){
				r3 = v_index;
				r4 = 0;
				if(r3 == r4){
					v_reg = v_reg15;
				} else {
					r2 = &token_stack;
					r0 = v_index;
					r0 = [r2+r0*8];
					r2 = HASH_OFFSET;
					if (r0 >= r2){
						r0 = r0 - HASH_OFFSET;
						r2 = v_reg15;
						if(r0 == r2){
							v_reg = v_reg14;
						} else {
							v_reg = v_reg15;
						}
					}
				}
			}
		}
	};
	
	#undefine v_reg15;
	#undefine v_reg14;
	pop r5, r4, r3, r2, r1;
}

proc Calculate_label_address(i){
	//unsigned int p2_valid = 0;
	//if (v_global == 0){
	push r1, r2, r3, r4, r5;
	r0 = v_global;
	r1 = 0;
	if(r0 == r1){
		//fprintf(code, "\tlea %s, [r6+_B0_%s_%s]\n", hash_table[v_reg].token, hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);
		r1 = code;
		echo_string(r1, '\tlea ');
		r2 = v_reg;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, ', [r6+_B0_');
		r2 = global;
		r2 = r2 - HASH_OFFSET;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, '_');
		r2 = v_base;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, ']\n');
	//} else {
	} else {
		//fprintf(code, "\tmov %s, _B0_%s\n", hash_table[v_reg].token, hash_table[v_base].token);
		r1 = code;
		echo_string(r1, '\tmov ');
		r2 = v_reg;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, ', _B0_');
		r2 = v_base;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_cr(r1);
		
	//}
	}
	// Our reg now points to the base of the structure.
	
	r1 = v_index;
	//if (v_index > 0) {
	if(r1){
		//We have an index to worry about.
		r2 = &token_stack;
		r0 = HASH_OFFSET;
		r3 = [r2+r1*8];
		if (r3 >= r0){
		//if (token_stack[v_index] > HASH_OFFSET) {
			//token = v_index;
			token = r1;
			//TokenIsLabelType(TYPE_REG);
			TokenIsLabelType(TYPE_REG);
			// Crap, it's a reg.
			r4 = code;
			r3 = v_size;
			r1 = v_size_is_p2(r3);
			//if ((p2_valid = v_size_is_p2(v_size))){ //v_size_is_p2 returns a shift value. If 0, shift value cannot be found.
					// Rather than using mul, we use a shl to calculate the index into the structure!
			if(r1){
				//fprintf(code, "\tpush %s\n", hash_table[token_stack[v_index]-HASH_OFFSET].token);
				r5 = v_index;
				r5 = [r2+r5*8];
				r5 = r5 - HASH_OFFSET;
				r5 = &hash_table[r5].token;
				echo_string(r4, '\tpush ');
				echo_string(r4, r5);
				//fprintf(code, "\tshl %s, %d\n", hash_table[token_stack[v_index]-HASH_OFFSET].token, p2_valid);
				echo_string(r4, '\n\tshl ');
				echo_string(r4, r5);
				echo_string(r4, ', ');
				echo_hex(r4, r1);
				//fprintf(code, "\tadd %s, %s\n", hash_table[v_reg].token, hash_table[token_stack[v_index]-HASH_OFFSET].token);
				echo_string(r4, '\n\tadd ');
				r1 = v_reg;
				r1 = &hash_table[r1].token;
				echo_string(r4, r1);
				echo_string(r4, ', ');
				echo_string(r4, r5);
				//fprintf(code, "\tpop %s\n", hash_table[token_stack[v_index]-HASH_OFFSET].token);
				echo_string(r4, '\n\tpop ');
				echo_string(r4, r5);
				echo_cr(r4);
			//} else {
			} else {
				//fprintf(code, "\tpush r0\n\tpush r3\n");
				// Load r0, with the size, unless r0 is the index...
				r4 = code;
				echo_string(r4, '\tpush r0\n\tpush r3\n');
				r1 = v_index;
				r1 = [r2+r1*8];
				r1 = r1 - HASH_OFFSET;
				r0 = HASH_r0;
				//if(token_stack[v_index]-HASH_OFFSET == HASH_r0){
				if(r1 == r0){
					// The index is r0... well move it to r1
					//fprintf(code, "\tpush r1\n\tmov r1, r0\n");
					//fprintf(code, "\tmov r0, 0%xh\n", v_size);
					echo_string(r4, '\tpush r1\n\tmov r1, r0\n\tmov r0, ');
					r0 = v_size;
					echo_hex(r4, r0);
					//fprintf(code, "\tmul r1\n");
					//fprintf(code, "\tadd %s, r0\n", hash_table[v_reg].token);
					echo_string(r4, '\n\tmul r1\n\tadd ');
					r0 = v_reg;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					//fprintf(code, "\tpop r1\n");
					echo_string(r4, ', r0\n\tpop r1\n');
				//} else {
				} else {
					//fprintf(code, "\tmov r0, 0%xh\n", v_size);
					echo_string(r4, '\tmov r0, ');
					r0 = v_size;
					echo_hex(r4, r0);
					//fprintf(code, "\tmul %s\n", hash_table[token_stack[v_index]-HASH_OFFSET].token);
					echo_string(r4, '\n\tmul ');
					r0 = &hash_table[r1].token;
					echo_string(r4, r0);
					//fprintf(code, "\tadd %s, r0\n", hash_table[v_reg].token);
					echo_string(r4, '\n\tadd ');
					r0 = v_reg;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					echo_string(r4, ', r0\n');
				//}
				}
				//fprintf(code, "\tpop r3\n\tpop r0\n");
				echo_string(r4, '\tpop r3\n\tpop r0\n');
			//}
			}
		//} else {
		} else {
			// Easy, it's an immediate.
			r1 = v_size;
			//if (v_size != 0){
			if (r1){
				//fprintf(code, "\tadd %s, ",hash_table[v_reg].token); 
				r2 = v_reg;
				r2 = &hash_table[r2].token;
				r3 = code;
				echo_string(r3, '\tadd ');
				echo_string(r3, r2);
				echo_string(r3, ', ');
				//token = v_index;
				r0 = v_index;
				token = r0;
				//outputNumber(i, NUM_INTEGER);
				r0 = i;
				outputNumber(r0, NUM_INTEGER, r3);
				//fprintf(code, "*0%xh\n", v_size);
				echo_string(r3, ' * ');
				echo_hex(r3, r1);
				echo_cr(r3);
			//}
			}
		//}
		}
	//}
	}
	// The index (if any) has been dealt with.
	// Now add the variable offset.
	//if (v_offset > 0){
		//fprintf(code, "\tadd %s, 0%lxh\n", hash_table[v_reg].token, v_offset);
	//}
	r0 = v_offset;
	if (r0){
		r1 = code;
		echo_string(r1, '\tadd ');
		r2 = v_reg;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, ', ');
		r2 = v_offset;
		echo_hex(r1, r2);
		echo_cr(r1);
	}
	pop r5, r4, r3, r2, r1;
}

proc Calculate_NSLabel_address(i){
	//if (state != '8'){
		//if (v_global == 0){
			//fprintf(code, "[r6+_B0_%s_%s", hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);
		//} else {
			//fprintf(code, "[_B0_%s", hash_table[v_base].token);
		//}
	//}
	push r1, r2, r3, r4, r5;
	r3 = state;
	r2 = CHAR_U;
	r1 = 1;
	if(r2 == r3){
		r1 = 0;
	} else {
		r2 = CHAR_V;
		if(r2 == r3){
			r1 = 0;
		} else {
			r2 = CHAR_W;
			if(r2 == r3){
				r1 = 0;
			} else {
				r2 = CHAR_8;
				if(r2 == r3){
					r1 = 0;
				}
			}
		}
	}
	//if r1 = 0, then we need special handling;
	r4 = code;
	//echo_hex(STDOUT, r1);
	//echo_hex(STDOUT, r3);
	//echo_cr(STDOUT);
	if (r1){
		r0 = v_global;
		push r1;
		r1 = 0;
		if (r0 == r1){
			echo_string(r4, '[r6+_B0_');
			r2 = global;
			r2 = r2 - HASH_OFFSET;
			r2 = &hash_table[r2].token;
			echo_string(r4, r2);
			echo_string(r4, '_');
			r2 = v_base;
			r2 = &hash_table[r2].token;
			echo_string(r4, r2);
		} else {
			echo_string(r4, '[_B0_');
			r2 = v_base;
			r2 = &hash_table[r2].token;
			echo_string(r4, r2);
		}
		pop r1;
		//echo_string(STDOUT, 'NSLabel1\n');
	} else {
		r0 = v_index;
		r2 = 0;
		if(r0 == r2){
			// We have FPU/XMM and no index...
			echo_string(r4, '\tlea ');
			r0 = target;
			r0 = &hash_table[r0].token;
			echo_string(r4, r0);
			r0 = v_global;
			push r1;
			r1 = 0;
			if (r0 == r1){
				echo_string(r4, ', [r6+_B0_');
				r2 = global;
				r2 = r2 - HASH_OFFSET;
				r2 = &hash_table[r2].token;
				echo_string(r4, r2);
				echo_string(r4, '_');
				r2 = v_base;
				r2 = &hash_table[r2].token;
				echo_string(r4, r2);
			} else {
				echo_string(r4, ', [_B0_');
				r2 = v_base;
				r2 = &hash_table[r2].token;
				echo_string(r4, r2);
			}
			pop r1;
			//echo_string(STDOUT, 'NSLabel1.5\n');			
		}
	}
	r0 = v_index;
	//if (v_index != 0){
	if (r0){
		// We have an index to work out as well
		// But we need to handle 80bit FPU offsets intelligently.
		//if(state != 80bit FPU or XMM){
		if(r1){
			// Normal register, this is nice and easy.
			//switch(state){
				//case 'b' : fprintf(code, "+"); break;
				//case 'w' : fprintf(code, "+2*"); break;
				//#ifndef i386
				//case 'd' : fprintf(code, "+4*"); break;
				//case ' ' : fprintf(code, "+8*"); break;
				//#else
				//case ' ' : fprintf(code, "+4*"); break;
				//#endif
				//case '3' : fprintf(code, "+4*"); break;
				//case '6' : fprintf(code, "+8*"); break;
			//}
			r2 = CHAR_b;  // 'b'
			if(r3 == r2){
				echo_string(r4, '+');
			} else {
				r2 = CHAR_w; // 'w'
				if(r3 == r2){
					echo_string(r4, '+2*');
				} else {
					#ifndef i386;
					r2 = CHAR_d; //'d'
					#else;
					r2 = CHAR_SPACE;
					#endif;
					if(r3 == r2){
						echo_string(r4, '+4*');
					} else {
						r2 = CHAR_SPACE; // space
						if(r3 == r2){
							echo_string(r4, '+8*');
						} else {
							r2 = CHAR_3; // '3'
							if(r3 == r2){
								echo_string(r4, '+4*');
							} else {
								echo_string(r4, '+8*');
							}
						}
					}
				}
			}
			//echo_string(STDOUT, 'NSLabel2\n');
			r0 = &token_stack;
			r1 = v_index;
			r1 = [r0+r1*8];
			r0 = HASH_OFFSET;
			//if (token_stack[v_index] > TOKEN_OFFSET){
			if(r1 >= r0){
				// We have a reg, 
				//fprintf(code, "%s", hash_table[token_stack[v_index]-HASH_OFFSET].token);
				r1 = r1 - HASH_OFFSET;
				r1 = &hash_table[r1].token;
				echo_string(r4, r1);
			//} else {
			} else {
				// We have an immediate
				//token = v_index;
				//outputNumber(i, NUM_INTEGER);
				r0 = v_index;
				token = r0;
				r0 = i;
				outputNumber(r0, NUM_INTEGER, r4);
			//}
			}
			//fprintf(code, "]");
			echo_string(r4, ']');
			
		} else {
			// We have to deal with a pointer to an 80bit FPU reg OR XMM reg with an index value!
			//echo_string(STDOUT, 'NSLabel3\n');
			r0 = v_index;
			r1 = &token_stack;
			r1 = [r1+r0*8];
			r0 = HASH_OFFSET;
			//if(token_stack[v_index] < TOKEN_OFFSET){
			if(r1 < r0){
				//Looks like an immediate, so is easy
				r0 = v_global;
				r1 = 0;
				//if (v_global == 0){
				if(r0 == r1){
					//fprintf(code, "lea %s, [r6+_B0_%s_%s", hash_table[target].token, hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);
					echo_string(r4, '\tlea ');
					r0 = target;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					echo_string(r4, ', [r6+_B0_');
					r0 = global;
					r0 = r0 - HASH_OFFSET;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					echo_string(r4, '_');
					r0 = v_base;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
				//} else {
				} else {
					//fprintf(code, "lea %s, [_B0_%s", hash_table[target].token, hash_table[v_base].token);
					echo_string(r4, '\tlea ');
					r0 = target;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					echo_string(r4, ', [_B0_');
					r0 = v_base;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
				//}
				}
				//fprintf(code, "+10*");
				r0 = CHAR_8;
				if(r3 == r0){
					// If it's FPU
					echo_string(r4, '+10*');
				} else {
					// If it's XMM
					echo_string(r4, '+16*');
				}
				//token = v_index;
				r0 = v_index;
				token = r0;
				r0 = i;
				//outputNumber(i, NUM_INTEGER);
				outputNumber(r0, NUM_INTEGER, r4);
				//fprintf(code, "]");
				echo_string(r4, ']');
			//} else {
				
			} else {
				// we have a reg!
				//if ((token_stack[v_index]-HASH_OFFSET)!=target){
					//fprintf(code, "\tmov %s, %s\n", hash_table[target].token, hash_table[token_stack[v_index]-HASH_OFFSET].token);
					//v_index = 0; // set a new v_index to target.
				//}
				//echo_string(STDOUT, 'NSLabel4\n');
				r0 = v_index;
				r1 = &token_stack;
				r1 = [r1+r0*8];
				r1 = r1 - HASH_OFFSET;
				r2 = target;
				if(r1!= r2){
					echo_string(r4, '\tmov ');
					r0 = &hash_table[r2].token;
					echo_string(r4, r0);
					echo_string(r4, ', ');
					r0 = &hash_table[r1].token;
					echo_string(r4, r0);
					echo_cr(r4);
					v_index = 0;
				}
				//fprintf(code, "\tlea %s, [%s+%s*4]\n", hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[token_stack[v_index]-HASH_OFFSET].token);	// Multiply the index by 5
				r1 = CHAR_8;
				if(r3 == r1){
					// if we are 80bit FPU we mul by 5
					echo_string(r4, '\tlea ');
					r2 = &hash_table[r2].token;
					echo_string(r4, r2);
					echo_string(r4, ', [');
					echo_string(r4, r2);
					echo_string(r4, '+');
					echo_string(r4, r2);
					echo_string(r4, '*4]\n');
				} else {
					// If we are XMM we mul by 8
					echo_string(r4, '\tlea ');
					r2 = &hash_table[r2].token;
					echo_string(r4, r2);
					echo_string(r4, ', [');
					echo_string(r4, r2);
					echo_string(r4, '*8]\n');
				}
				//if ((SOURCE_TYPE == SOURCE_ELFO)&&(v_global == 1)){
				r0 = SOURCE_TYPE;
				r1 = SOURCE_ELFO;
				if (r0 == r1){
					r0 = v_global;
					r1 = 1;
					if (r0 == r1){ 
						//fprintf(code, "\tlea %s, [%s*2]\n", hash_table[target].token, hash_table[token_stack[v_index]-HASH_OFFSET].token);		 // Multiple the index again by 2
						echo_string(r4, '\tlea ');
						r3 = target;
						r3 = &hash_table[r3].token;
						echo_string(r4, r3);
						echo_string(r4, ', [');
						echo_string(r4, r2);
						echo_string(r4, '*2]\n');
						//if (target != HASH_r6){
						r3 = target;
						r2 = HASH_r6;
						if(r3 != r2){
							//fprintf(code, "\tpush r6\n\tmov r6, _B0_%s\n\tadd %s, r6\n\tpop r6",hash_table[v_base].token,hash_table[target].token);
							echo_string(r4, '\tpush r6\n\tmov r6, _B0_');
							r2 = v_base;
							r2 = &hash_table[r2].token;
							echo_string(r4, r2);
							echo_string(r4, '\n\tadd ');
							r2 = &hash_table[r3].token;
							echo_string(r4, r2);
							echo_string(r4, ', r6\n\tpop r6');
						//} else {
						} else {
							//fprintf(code, "\tpush r0\n\tmov r0, _B0_%s\n\tadd %s, r0\n\tpop r0",hash_table[v_base].token,hash_table[target].token);
							echo_string(r4, '\tpush r0\n\tmov r0, _B0_');
							r2 = v_base;
							r2 = &hash_table[r2].token;
							echo_string(r4, r2);
							echo_string(r4, '\n\tadd ');
							r2 = &hash_table[r3].token;
							echo_string(r4, r2);
							echo_string(r4, ', r0\n\tpop r0');
						//}
						}
					} else {
					//echo_string(STDOUT, 'NSLabel6\n');
						r0 = v_global;
						r1 = 0;
							//if(v_global == 0){
						if(r0 == r1){
							//fprintf(code, "\tlea %s, [r6+%s*2+_B0_%s_%s]", hash_table[target].token,hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);		 // Multiple the index again by 2 and add offset	
							echo_string(r4, '\tlea ');
							r0 = target;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, ', [r6+');
							r0 = &token_stack;
							r1 = v_index;
							r0 = [r0+r1*8];
							r0 = r0 - HASH_OFFSET;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, '*2+_B0_');
							r0 = global;
							r0 = r0 - HASH_OFFSET;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, '_');
							r0 = v_base;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, ']');
						//} else {
						} else {
							//fprintf(code, "\tlea %s, [%s*2+_B0_%s]", hash_table[target].token, hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[v_base].token);		 // Multiple the index again by 2 and add offset						
							echo_string(r4, '\tlea ');
							r0 = target;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, ', [');
							r0 = &token_stack;
							r1 = v_index;
							r0 = [r0+r1*8];
							r0 = r0 - HASH_OFFSET;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, '*2+_B0_');
							r0 = v_base;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, ']');
						//}
						}
					}
				} else {
					//} else {
					//echo_string(STDOUT, 'NSLabel7\n');
					r0 = v_global;
					r1 = 0;
						//if(v_global == 0){
					if(r0 == r1){
						//fprintf(code, "\tlea %s, [r6+%s*2+_B0_%s_%s]", hash_table[target].token,hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);		 // Multiple the index again by 2 and add offset	
						echo_string(r4, '\tlea ');
						r0 = target;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, ', [r6+');
						r0 = &token_stack;
						r1 = v_index;
						r0 = [r0+r1*8];
						r0 = r0 - HASH_OFFSET;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, '*2+_B0_');
						r0 = global;
						r0 = r0 - HASH_OFFSET;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, '_');
						r0 = v_base;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, ']');
					//} else {
					} else {
						//fprintf(code, "\tlea %s, [%s*2+_B0_%s]", hash_table[target].token, hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[v_base].token);		 // Multiple the index again by 2 and add offset						
						echo_string(r4, '\tlea ');
						r0 = target;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, ', [');
						r0 = &token_stack;
						r1 = v_index;
						r0 = [r0+r1*8];
						r0 = r0 - HASH_OFFSET;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, '*2+_B0_');
						r0 = v_base;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, ']');
					}
				}
			} 
		} 
	} else {
		echo_string(r4, ']');
	}
	//echo_string(STDOUT, 'NSLabel-End\n');
	pop r5, r4, r3, r2, r1;
}

proc Global_Pointer(i){
//unsigned int Global_Pointer(unsigned int i){
	//if (token_stack[token] == TOKEN_ARRAY_END)
		//abort_b0("Unexpected end of memory reference");
	push r1, r2, r3, r4, r5;
	r0 = token;
	r1 = &token_stack;
	r2 = [r1+r0*8];
	r3 = TOKEN_ARRAY_END;
	if (r2 == r3){
		abort_b0('Unexpected end of memory reference');
	}
	
	r3 = HASH_OFFSET;
	if(r2 < r3){
		// We should have an immediate
		r3 = TOKEN_MINUS;
		if(r2 == r3){
			r4 = code;
			echo_string(r4, '-');
			r0 = token;
			r0 = r0 + 1;
			token = r0;
		}
		//outputNumber(i, NUM_INTEGER);
		r4 = code;
		r0 = i;
		outputNumber(r0, NUM_INTEGER, r4);
	} else {
	//} else {
		//we should be dealing with a register
		//TokenIsLabelType(TYPE_REG);
		TokenIsLabelType(TYPE_REG);
		//fprintf(code, "%s", hash_table[token_stack[token]-HASH_OFFSET].token);
		r2 = r2 - HASH_OFFSET;
		r2 = &hash_table[r2].token;
		r4 = code;
		echo_string(r4, r2);
		//token++;
		r0 = token;
		r0 = r0 + 1;
		token = r0;
		r2 = [r1+r0*8];
		r3 = TOKEN_ADD;
		//if (token_stack[token] == TOKEN_ADD){
		if(r2 == r3){
			// Looks like a complex memory pointer operation.
			//fprintf(code, "+");
			echo_string(r4, '+');
			//token++;
			r0 = token;
			r0 = r0 + 1;
			token = r0;
			r2 = [r1+r0*8];
			r3 = HASH_OFFSET;
			//if (token_stack[token] > TOKEN_OFFSET) {
			if(r2 >= r3){
				// Should be a reg?
				//TokenIsLabelType(TYPE_REG);
				TokenIsLabelType(TYPE_REG);
				//fprintf(code, "%s", hash_table[token_stack[token]-HASH_OFFSET].token); // Output the reg
				r2 = r2 - HASH_OFFSET;
				r2 = &hash_table[r2].token;
				r4 = code;
				echo_string(r4, r2);
				//token++;
				r0 = token;
				r0 = r0 + 1;
				token = r0;
				// Here we should have either a + or a *
				//if ((token_stack[token] != TOKEN_ADD) &&
					//(token_stack[token] != TOKEN_MINUS) &&
					//(token_stack[token] != TOKEN_MULTIPLY) &&
					//(token_stack[token] != TOKEN_ARRAY_END))
					//abort_b0("+, * or ] Expected");
				r2 = [r1+r0*8];
				r3 = TOKEN_ADD;
				if(r2 != r3){
					r3 = TOKEN_MINUS;
					if(r2!=r3){
						r3 = TOKEN_MULTIPLY;
						if(r2!=r3){
							r3 = TOKEN_ARRAY_END;
							if(r2!=r3){
								abort_b0('+, * or ] Expected');
							}
						}
					}
				}
				r4 = 0;
				r3 = TOKEN_MINUS;
				if(r2 == r3){ r4 = 1; }
				r3 = TOKEN_ADD;
				if(r2 == r3){ r4 = 1; }
				//if ((token_stack[token] == TOKEN_ADD)||(token_stack[token] == TOKEN_MINUS)) {
				if(r4){
					// We should have an immediate
					//if(token_stack[token] == TOKEN_ADD) {
						//fprintf(code, "+");
					//} else {
						//fprintf(code, "-");
					//}
					if(r2 == r3){
						r4 = code;
						echo_string(r4, '+');
					} else {
						r4 = code;
						echo_string(r4, '-');
					}
					//token++;
					r0 = token;
					r0 = r0 + 1;
					token = r0;
					//if (token_stack[token] > TOKEN_OFFSET)
						//abort_b0("Immediate Expected");
					r2 = [r1+r0*8];
					r3 = HASH_OFFSET;
					if(r2>r3){
						abort_b0('Immediate Expected');
					}
					//outputNumber(i, NUM_INTEGER);
					r0 = i;
					r4 = code;
					outputNumber(r0, NUM_INTEGER, r4);
				//} else {
				} else {
					//if (token_stack[token] == TOKEN_MULTIPLY) {
					r3 = TOKEN_MULTIPLY;
					if(r2 == r3){
						// Handle our multiply, else fall through (it should be an ARRAY_END).
						//fprintf(code, "*");
						r4 = code;
						echo_string(r4, '*');
						//token++;
						r0 = token;
						r0 = r0 + 1;
						token = r0;
						// This part gets tricky, as we should only have 1,2,4 or 8 here!
						//if (token_stack[token] > TOKEN_OFFSET)
							//abort_b0("Immediate Expected");
						TokenIs(TOKEN_NUM_INTEGER);
						r0 = token;
						r0 = r0 + 1;
						token = r0;
						//if ((token_stack[token] != '1') &&
							//(token_stack[token] != '2') &&
							//(token_stack[token] != '4') &&
							//(token_stack[token] != '8'))
							//abort_b0("Illformed pointer expression, please revise");
						r2 = [r1+r0*8];
						r3 = 1;
						if(r2!=r3){
							r3 = 2;
							if(r2!=r3){
								r3 = 4;
								if(r2!=r3){
									r3 = 8;
									if(r2!=r3){
										abort_b0('Illformed pointer expression, please revise');
									}
								}
							}
						}
						//fprintf(code, "%c", token_stack[token]);
						r4 = code;
						r2 = r2 + 30h;
						echo_character(r4, r2);
						//token++; // Output the number
						r0 = token;
						r0 = r0 + 1;
						token = r0;
						r2 = [r1+r0*8];
						r2 = r2 - TOKEN_ADD;
						r3 = 1;
						if(r2<=r3){
						//if ((token_stack[token] == TOKEN_ADD)||(token_stack[token] == TOKEN_MINUS)){
							//if(token_stack[token] == TOKEN_ADD) {
								//fprintf(code, "+");
							//} else {
								//fprintf(code, "-");
							//}
							r4 = code;
							r2 = [r1+r0*8];
							r3 = TOKEN_ADD;
							if(r2 == r3){
								echo_string(r4, '+');
							} else {
								echo_string(r4, '-');
							}
							//token++;
							r0 = token;
							r0 = r0 + 1;
							token = r0;
							TokenIs(TOKEN_NUM_INTEGER);
							r0 = i;
							r4 = code;
							outputNumber(r0, NUM_INTEGER, r4);
						//}
						}
					//}
					}
				//}
				}
			//} else {
			} else {
				// Else output the displacement.
				//outputNumber(i, NUM_INTEGER);
				r0 = i;
				outputNumber(r0, NUM_INTEGER, r4);
			//}
			}
		//}  else {
		} else {
			r3 = TOKEN_MULTIPLY;
			//if (token_stack[token] == TOKEN_MULTIPLY) {
			if(r2 == r3){
				// Handle our multiply, else fall through (it should be an ARRAY_END).
				//fprintf(code, "*");
				r4 = code;
				echo_string(r4, '*');
				//token++;
				r0 = token;
				r0 = r0 + 1;
				token = r0;
				// This part gets tricky, as we should only have 1,2,4 or 8 here!
				//if (token_stack[token] > TOKEN_OFFSET)
					//abort_b0("Immediate Expected");
				
				TokenIs(TOKEN_NUM_INTEGER);
				r0 = token;
				r0 = r0 + 1;
				token = r0;
				r2 = [r1+r0*8];
				//if ((token_stack[token] != '1') &&
					//(token_stack[token] != '2') &&
					//(token_stack[token] != '4') &&
					//(token_stack[token] != '8'))
					//abort_b0("Illformed pointer expression, please revise");
				r3 = 1h;
				if(r2!=r3){
					r3 = 2h;
					if(r2!=r3){
						r3 = 4h;
						if(r2!=r3){
							r3 = 8h;
							if(r2!=r3){
								abort_b0('Illformed pointer expression, please revise');
							}
						}
					}
				}
				r2 = r2 + 30h;
				//fprintf(code, "%c", token_stack[token]);
				echo_character(r4, r2);
				//token++; // Output the number
				r0 = token;
				r0 = r0 + 1;
				token = r0;
				r2 = [r1+r0*8];
				r2 = r2 - TOKEN_ADD;
				r3 = 1;
				if(r2<=r3){
				//if ((token_stack[token] == TOKEN_ADD)||(token_stack[token] == TOKEN_MINUS)){
					//if(token_stack[token] == TOKEN_ADD) {
						//fprintf(code, "+");
					//} else {
						//fprintf(code, "-");
					//}
					r4 = code;
					r2 = [r1+r0*8];
					r3 = TOKEN_ADD;
					if(r2 == r3){
						echo_string(r4, '+');
					} else {
						echo_string(r4, '-');
					}
					//token++;
					r0 = token;
					r0 = r0 + 1;
					token = r0;
					TokenIs(TOKEN_NUM_INTEGER);
					r0 = i;
					outputNumber(r0, NUM_INTEGER, r4);
				//}
				}
			//}
			} else {
				r3 = TOKEN_MINUS;
				if(r2 == r3){
					//fprintf(code, "-");
					r4 = code;
					echo_string(r4, '-');
					//token++;
					r0 = token;
					r0 = r0 + 1;
					token = r0;
					TokenIs(TOKEN_NUM_INTEGER);
					r0 = i;
					outputNumber(r0, NUM_INTEGER, r4);
				}
			}
		//}
		}
	//}
	}
	//return(0);
	pop r5, r4, r3, r2, r1;
}

proc process_struc_def(i){
	//unsigned int target_hash;
	//int variable_size, struc_size;
	//struc_struc *ptr_struc;
	m64 target_hash;
	m64 variable_size;
	m64 struc_size;
	m64 ptr_struc;
	
	push r1, r2, r3, r4, r5, r8, r9, r10, r15;
	r15 = DEBUG;
	//if(DEBUG)
		//printf("Defining a Variable based on a Structure\n");
	if (r15){
		echo_string(STDOUT, 'Defining a Variable based on a Structure\n');
	}
	//atStackStart();
	atStackStart();
	
	//Lets see if we have an array of struc's
	r5 = &token_stack;
	r4 = token;
	r0 = [r5+r4*8];
	r1 = TOKEN_ARRAY_START;
	r10 = 0;
	//if(token_stack[token] == TOKEN_ARRAY_START){
	if(r0 == r1){
		// Looks like we do, so lets grab our size.
		//token++;
		r4 = r4 + 1;
		token = r4;
		TokenIs(TOKEN_NUM_INTEGER);
		r0 = [r5+r4*8+8];
		variable_size = r0;
		r4 = r4 + 2;
		token = r4;
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//token++; // Skip end of array size indicator.
		r4 = token;
		r4 = r4 + 1;
		token = r4;
	//} else {
	} else {
		//variable_size = 1;
		variable_size = 1;
	//}
	}
	//if(DEBUG)
		//printf("Struc Variable Size = %d\n", variable_size);
	if(r15){
		r1 = variable_size;
		echo_string(STDOUT, 'Struc Variable Size = ');
		echo_hex(STDOUT, r1);
		echo_cr(STDOUT);
	}
	//isHash(token_stack[token]);
	r4 = token;
	r1 = [r5+r4*8];
	isHash(r1);
	//target_hash = token_stack[token]-HASH_OFFSET;
	r1 = r1 - HASH_OFFSET;
	target_hash = r1;
	//IsLabelAllocated();
	IsLabelAllocated();
	//Set our variable type;
	
	//if(global == 0){
		//hash_table[target_hash].token_type = TYPE_GLOBAL+TYPE_VSTRUC+(hash_table[token_stack[0]-HASH_OFFSET].token_type & 0xf);
	//} else {
		//hash_table[target_hash].token_type = TYPE_LOCAL+TYPE_VSTRUC +(hash_table[token_stack[0]-HASH_OFFSET].token_type & 0xf);
	//}
	r0 = [r5];
	r3 = r0 - HASH_OFFSET;
	r0 = hash_table[r3].token_type;
	r0 = r0 && 0fh;
	r2 = global;
	if(r2 == r10){
		r0 = r0 + TYPE_GLOBAL+TYPE_VSTRUC;
	} else {
		r0 = r0 + TYPE_LOCAL+TYPE_VSTRUC;
	}
	hash_table[r1].token_type = r0;
	//Now comes the hard bit... Now to allocate the space within the final executable.
	//struc_size = hash_table[token_stack[0]-HASH_OFFSET].local_offset;  //Local offset holds the number of elements within the struc
	r4 = hash_table[r3].local_offset;
	struc_size = r4;
	//ptr_struc = hash_table[token_stack[0]-HASH_OFFSET].struc_ptr;
	r0 = hash_table[r3].struc_ptr;
	ptr_struc = r0;
	//hash_table[target_hash].struc_ptr = ptr_struc;
	hash_table[r1].struc_ptr = r0;
	//struc_size = ptr_struc->struc[struc_size].offset; // Struc Size == size of structure in bytes!
	r4 = r4 << 5;
	r8 = [r0+r4+struct_entry.offset];
	//hash_table[target_hash].local_offset = struc_size;
	hash_table[r1].local_offset = r8;
	//if(DEBUG)
		//printf("Structure Size = %d\nVariable Size = %d\n", struc_size, struc_size*variable_size);
	r3 = variable_size;
	r0 = r8;
	r9 = r0 * r3;  // variable_size * struc_size
	if(r15){
		echo_string(STDOUT, 'Structure Size = ');
		echo_hex(STDOUT, r8);
		echo_string(STDOUT, '\nVariable Size = ');
		echo_hex(STDOUT, r9);
		echo_cr(STDOUT);
	}
	// Now that we have our size, let's output the required stuff...
	//if(global == 0){
	if(r2 == r10){
		//fprintf(bss, "_B0_%s rb %d\n", hash_table[target_hash].token, struc_size*variable_size);	
		r10 = bss;
		echo_string(r10, '_B0_');
		r0 = target_hash;
		r0 = &hash_table[r0].token;
		echo_string(r10, r0);
		echo_string(r10, ' rb ');
		echo_hex(r10, r9);
		echo_cr(r10);
	//} else {
	} else {
		//fprintf(data, "_B0_%s_%s equ %d\n", hash_table[global-HASH_OFFSET].token, hash_table[target_hash].token, local_var_offset);
		r10 = data;
		echo_string(r10, '_B0_');
		r0 = global;
		r0 = r0 - HASH_OFFSET;
		r0 = &hash_table[r0].token;
		echo_string(r10, r0);
		echo_string(r10, '_');
		r0 = &hash_table[r1].token;
		echo_string(r10, r0);
		echo_string(r10, ' equ ');
		r1 = local_var_offset;
		echo_hex(r10, r1);
		echo_cr(r10);
		//local_var_offset = local_var_offset + (struc_size*variable_size);
		r1 = r1 + r9;
		local_var_offset = r1;
		//hash_table[global-HASH_OFFSET].local_offset = local_var_offset;
		r0 = global;
		r0 = r0 - HASH_OFFSET;
		hash_table[r0].local_offset = r1;
	//}
	}
	//token++;
	r4 = token;
	r4 = r4 + 1;
	token = r4;
	r10 = i;
	//if(DEBUG)
		//printf("token = 0x%x, i = 0x%x\n", token, i);
	if(r15){
		echo_string(STDOUT, 'token = ');
		echo_hex(STDOUT, r4);
		echo_string(STDOUT, ', i = ');
		echo_hex(STDOUT, r10);
		echo_cr(STDOUT);
	}
		
	//atStackEnd(i);
	atStackEnd(r10);
	//if(DEBUG)
		//printf("Finished defining a variable based on a structure\n");
	if(r15){
		echo_string(STDOUT, 'Finished defining a variable based on a structure\n');
	}
	pop r15, r10, r9, r8, r5, r4, r3, r2, r1;
	//return(0);
}

proc TS_is_int(i){
	// All this function does is scan the token_stack, and
	// return 0 if FPU
	// return 1 if INT (none of other found)
	// return 2 if XMM found.
	// i = number of tokens.
	// token = current token., we assume token = 0;
	//for (token = 0; token < i; token++){
		//switch(token_stack[token]) {
			//case HASH_fp0+HASH_OFFSET:
			//case HASH_fp1+HASH_OFFSET:
			//case HASH_fp2+HASH_OFFSET:
			//case HASH_fp3+HASH_OFFSET:
			//case HASH_fp4+HASH_OFFSET:
			//case HASH_fp5+HASH_OFFSET:
			//case HASH_fp6+HASH_OFFSET:
			//case HASH_fp7+HASH_OFFSET: isInt = 0;
			//break;
		//}
	//}
	push r1, r2, r3, r4, r5;
	r0 = 0;
	r1 = i;
	r2 = &token_stack;
	while (r0 < r1){
		r3 = [r2+r0*8];
		r5 = TOKEN_NUM_INTEGER;
		if(r3 == r5){
			r0 = r0 + 1;
		}
		r5 = TOKEN_NUM_DECIMAL;
		if(r3 == r5){
			r0 = r0 + 1;
		}
		r4 = HASH_fp7 - HASH_fp0;
		push r3;
		r3 = r3 - HASH_fp0+HASH_OFFSET;
		if(r3 < r4){
			token = 0;
			pop r3;
			pop r5, r4, r3, r2, r1;
			return(0);
		}
		pop r3;
		push r3;
		r4 = HASH_xmm9 - HASH_xmm0;
		r3 = r3 - HASH_xmm0+HASH_OFFSET;
		if(r3 < r4){
			token = 0;
			pop r3;
			pop r5, r4, r3, r2, r1;
			return(2);
		}	
		pop r3;
		push r3;
		r4 = HASH_xmm15 - HASH_xmm10;
		r3 = r3 - HASH_xmm10+HASH_OFFSET;
		if(r3 < r4){
			token = 0;
			pop r3;
			pop r5, r4, r3, r2, r1;
			return(2);
		}	
		pop r3;		
		
		r0 = r0 + 1;
	}
	
	//token = 0; // Reset the token value
	//return(isInt);
	token = 0;
	pop r5, r4, r3, r2, r1;
	return(1);
}

proc process_struc(){
	//unsigned int i, j, k, offset, s_offset;
	//int variable_size;
	//struc_struc *ptr_struc;
	//struc_struc *ptr_struc_embedded;	// Pointer to another structure which we want
									// to embed into this structure!
	// struc_def = hash of the structure we are operating on.
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12, r13, r14, r15;
	
	m64 i;
	m64 j;
	m64 k;
	m64 offset;
	m64 s_offset;
	m64 variable_size;
	m64 ptr_struc;
	m64 ptr_struc_embedded;
	
	r12 = DEBUG;
	r15 = &token_stack;
	r14 = token;
	//i = token;
	r13 = r14;
	//token = 0;
	r14 = 0;
	//if(DEBUG){
		//printf("PROCESSING STRUC STACK : ");
		//for (token = 0; token < i; token++){
			//printf("0x%x ", token_stack[token]);
		//}
		//printf("\n");
	//}
	if(r12){
		echo_string(STDOUT, 'PROCESSING STRUC STACK : ');
		while(r14 < r13){
			r1 = [r15+r14*8];
			echo_hex(STDOUT, r1);
			echo_string(STDOUT, ' ');
			r14 = r14 + 1;
		}
		echo_cr(STDOUT);
	}
	//token = 0;
	r14 = 0;
	token = r14;
	//while (token < i){
	while(r14 < r13){
		//if(DEBUG)
			//printf("Structure - Processing Stack\n");
		if(r12){
			echo_string(STDOUT, 'Structure - Processing Stack\n');
		}
		//switch (token_stack[token]) {
		r1 = [r15+r14*8];
		r0 = 0;
		r2 = HASH_m8+HASH_OFFSET;  if (r1 == r2) { r0 = 1; };
		r2 = HASH_m16+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		r2 = HASH_m32+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		#ifndef i386;
		r2 = HASH_m64+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		#endif;
		r2 = HASH_f32+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		r2 = HASH_f64+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		r2 = HASH_f80+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		r2 = HASH_v4i+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		r2 = HASH_v4f+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		r2 = HASH_v2f+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		
			//case HASH_m8+HASH_OFFSET :
			//case HASH_m16+HASH_OFFSET :
			//case HASH_m32+HASH_OFFSET :
			//#ifndef i386
			//case HASH_m64+HASH_OFFSET :
			//#endif
			//case HASH_f32+HASH_OFFSET :
			//case HASH_f64+HASH_OFFSET :
			//case HASH_f80+HASH_OFFSET :
		if (r0){
				//if(DEBUG)
					//printf("Structure - Processing Variable Def\n");
				if(r12) {
					echo_string(STDOUT, 'Structure - Processing Variable Def\n');
				}
				//atStackStart();
				atStackStart();
				r14 = token;
				r1 = [r15+r14*8];
				r2 = TOKEN_ARRAY_START;
				//if (token_stack[token] == TOKEN_ARRAY_START) {
				if(r1 == r2){
					r14 = r14 + 1;
					token = r14;
					TokenIs(TOKEN_NUM_INTEGER);
					r3 = [r15+r14*8+8];
					r14 = r14 + 2;
					token = r14;
					variable_size = r3;
					TokenIs(TOKEN_ARRAY_END);
					r14 = r14 + 1;
					token = r14;
				//} else {
				} else {
					r3 = 1;
					variable_size = r3;
				}
				//}
				r14 = token;
				r1 = [r15+r14*8];
				//isHash(token_stack[token]);
				isHash(r1);
				//switch (token_stack[0]) {
					//case HASH_m8+HASH_OFFSET : break;
					//case HASH_m16+HASH_OFFSET : variable_size *= 2; break;
					//case HASH_m32+HASH_OFFSET : variable_size *= 4; break;
					//#ifndef i386
					//case HASH_m64+HASH_OFFSET : variable_size *= 8; break;
					//#endif
					//case HASH_f32+HASH_OFFSET : variable_size *= 4; break;
					//case HASH_f64+HASH_OFFSET : variable_size *= 8; break;
					//case HASH_f80+HASH_OFFSET : variable_size *= 10; break;
				//}
				r0 = [r15];
				r1 = HASH_m16+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 1; }
				r1 = HASH_m32+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 2; }
				#ifndef i386;
				r1 = HASH_m64+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 3; }
				#endif;
				r1 = HASH_f32+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 2; }
				r1 = HASH_f64+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 3; }
				r1 = HASH_f80+HASH_OFFSET; if(r0 == r1){ r3 = &[r3+r3*4]; r3 = r3 << 1; }
				r1 = HASH_v4i+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 4; }
				r1 = HASH_v4f+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 4; }
				r1 = HASH_v2f+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 4; }
				
				variable_size = r3;
				//token++;
				r14 = r14 + 1;
				token = r14;
				//atStackEnd(i);
				atStackEnd(r13);
				r0 = [r15+r14*8-8];
				r0 = r0 - HASH_OFFSET;
				r1 = struc_def;
				//ScanForDupStrucLabel(struc_def, token_stack[token-1]-HASH_OFFSET);
				ScanForDupStrucLabel(r1, r0);
				//offset = hash_table[struc_def].local_offset;
				r2 = hash_table[r1].local_offset;
				offset = r2;
				//ptr_struc = hash_table[struc_def].struc_ptr;
				r10 = hash_table[r1].struc_ptr;
				ptr_struc = r10;
				//if(DEBUG)
					//printf("Variable Size = %d, Offset = 0x%x\n", variable_size, offset);
				if(r12){
					echo_string(STDOUT, 'Variable Size = ');
					echo_hex(STDOUT, r3);
					echo_string(STDOUT, ', Offset = ');
					echo_hex(STDOUT, r2);
					echo_cr(STDOUT);
				}
				//token--;	// Better point to our hash value!
				r14 = r14 - 1;
				token = r14;
				r0 = hash_table[r1].token_type;
				r5 = TYPE_STRUC;
				//if (hash_table[struc_def].token_type == TYPE_STRUC) {
				if(r0 == r5){
					// We better set the it the first variable type;
					//switch (token_stack[0]) {
						//case HASH_m8+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_M8; break;
						//case HASH_m16+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_M16; break;
						//case HASH_m32+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_M32; break;
						//#ifndef i386
						//case HASH_m64+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_M64; break;
						//#endif
						//case HASH_f32+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_F32; break;
						//case HASH_f64+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_F64; break;
						//case HASH_f80+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_F80; break;
					//}
					r0 = [r15];
					r3 = HASH_m8+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_M8; } else {
					r3 = HASH_m16+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_M16; } else {
					r3 = HASH_m32+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_M32; } else {
					#ifndef i386; 
					r3 = HASH_m64+HASH_OFFSET;
					#else;
					r3 = HASH_m32+HASH_OFFSET;
					#endif;
					if(r0 == r3){ 
						#ifndef i386;
						hash_table[r1].token_type = TYPE_STRUC+TYPE_M64;
						#else;
						hash_table[r1].token_type = TYPE_STRUC+TYPE_M32;
						#endif;
					} else {
					r3 = HASH_f32+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_F32; } else {
					r3 = HASH_f64+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_F64; } else {
					r3 = HASH_f80+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_F80; } else {
					r3 = HASH_v4i+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_V4I; } else {
					r3 = HASH_v4f+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_V4F; } else {
					r3 = HASH_v2f+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_V2F; }}}}}}}}}};
				
				}
				// Get our next offset.
				//s_offset = ptr_struc->struc[offset].offset;
				r2 = r2 << 5;
				r3 = [r10+r2+struct_entry.offset];
				s_offset = r3;
				//switch (token_stack[0]) {
					//case HASH_m8+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_M8; break;
					//case HASH_m16+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_M16;  break;
					//case HASH_m32+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_M32;  break;
					//#ifndef i386
					//case HASH_m64+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_M64;  break;
					//#endif
					//case HASH_f32+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_F32;  break;
					//case HASH_f64+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_F64;  break;
					//case HASH_f80+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_F80;  break;
				//}
				r0 = [r15];
				r3 = HASH_m8+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_M8; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_m16+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_M16; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_m32+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_M32; [r10+r2+struct_entry.type] = r3; } else {
				#ifndef i386; 
				r3 = HASH_m64+HASH_OFFSET;
				#else;
				r3 = HASH_m32+HASH_OFFSET;
				#endif;
				if(r0 == r3) { 
				#ifndef i386;
				r3 = TYPE_M64;
				#else;
				r3 = TYPE_M32;
				#endif; 
				[r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_f32+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_F32; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_f64+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_F64; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_f80+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_F80; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_v4i+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_V4I; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_v4f+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_V4F; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_v2f+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_V2F; [r10+r2+struct_entry.type] = r3; }}}}}}}}}};
				//ptr_struc->struc[offset].hash = token_stack[token]-HASH_OFFSET;
				r0 = [r15+r14*8];
				r0 = r0 - HASH_OFFSET;
				[r10+r2+struct_entry.hash] = r0;
				//ptr_struc->struc[offset].size = variable_size;
				r0 = variable_size;
				[r10+r2+struct_entry.size] = r0;
				//ptr_struc->struc[offset+1].offset = s_offset+variable_size;
				r1 = s_offset;
				r0 = r0 + r1;
				[r10+r2+struct_entry.offset+32] = r0;
				//ptr_struc->struc[offset+1].hash = 0;
				r0 = 0;
				[r10+r2+struct_entry.hash+32] = r0;
				//if(DEBUG)
					//printf("Variable %s, Type = 0x%x, Size = 0x%x, Offset = 0x%x\n", hash_table[ptr_struc->struc[offset].hash].token, ptr_struc->struc[offset].type, ptr_struc->struc[offset].size, ptr_struc->struc[offset].offset);
				if(r12){
					echo_string(STDOUT, 'Variable ');
					echo_hex(STDOUT, r2);
					echo_string(STDOUT, ' ');
					r0 = [r10+r2+struct_entry.hash];
					r0 = &hash_table[r0].token;
					echo_string(STDOUT, r0);
					echo_string(STDOUT, ', Type = ');
					r0 = [r10+r2+struct_entry.type];
					echo_hex(STDOUT, r0);
					echo_string(STDOUT, ', Size = ');
					r0 = [r10+r2+struct_entry.size];
					echo_hex(STDOUT, r0);
					echo_string(STDOUT, ', Offset = ');
					r0 = [r10+r2+struct_entry.offset];
					echo_hex(STDOUT, r0);
					echo_cr(STDOUT);
				}
				//hash_table[struc_def].local_offset++;	// Increment the pointer into the structure table
				r1 = struc_def;
				r0 = hash_table[r1].local_offset;
				r0 = r0 + 1;
				hash_table[r1].local_offset = r0;
				//if (offset+1 >= STRUC_SIZE)
					//abort_b0("INTERNAL: Structure Definition Table Overflow! - Increase STRUC_SIZE");
				r0 = offset;
				r0 = r0 + 1;
				r1 = STRUC_SIZE;
				if(r0 >= r1){ abort_b0('INTERNAL: Structure Definition Table Overflow! - Increase STRUC_SIZE'); }
				//token = i;
				r14 = r13;
				token = r14;
				//break;
		} else {
			//case TOKEN_BLOCK_END : 
			r2 = TOKEN_BLOCK_END;
			if(r1 == r2){
				//if(DEBUG)
					//printf("Struc - Processing TOKEN_END_BLOCK\n");
				if(r12){
					echo_string(STDOUT, 'Struc - Processing TOKEN_END_BLOCK\n');
				}
				//atStackStart();
				atStackStart();
				r14 = token;
				//if(DEBUG)
					//printf("token = 0x%x, i = 0x%x\n", token, i);
				if(r12){
					echo_string(STDOUT, 'token = ');
					echo_hex(STDOUT, r14);
					echo_string(STDOUT, ', i = ');
					echo_hex(STDOUT, r13);
					echo_cr(STDOUT);
				}
				//if (i > token){
				if(r13 > r14){
					//j = i - token; // make j our count!
					r5 = r13 - r14;
					//for (k = 0; k < j; k++){
						// Quick move the stack forward
						//token_stack[k] = token_stack[token];
						//token++;
						//if (DEBUG)
							//printf("stack[%d] = 0x%x\n",k,token_stack[k]);
					//}
					r1 = 0;
					while (r1 < r5){
						r2 = [r15+r14*8];
						[r15+r1*8] = r2;
						if(r12){
							echo_string(STDOUT, 'stack[');
							echo_hex(STDOUT, r1);
							echo_string(STDOUT, '] = ');
							echo_hex(STDOUT, r2);
							echo_cr(STDOUT);
						}
						r14 = r14 + 1;
						token = r14;
						r1 = r1 + 1;
					}
					//token = 0;		// Set our stack pointer to 0
					r14 = 0;
					token = r14;
					//i = j;			// Set our new stack size to the count!
					r13 = r5;
					//if(DEBUG)
						//printf("process_struc > token = 0x%x, i = 0x%x\n", token, i);
					if(r12){
						echo_string(STDOUT, 'process_struc > token = ');
						echo_hex(STDOUT, r14);
						echo_string(STDOUT, ', i = ');
						echo_hex(STDOUT, r13);
						echo_cr(STDOUT);
					}
						
					//struc_def = 0;
					struc_def = 0;
					//do_process = 0;
					do_process = 0;
					r0 = r13;
					pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
					//return(i);
					return(r0);
				//} else {
				} else {
					//atStackEnd(i);
					atStackEnd(r13);
					//getChar();
					getChar();
					//struc_def = 0;
					struc_def = 0;
					//return(1);
					pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
					return(1);
				//}
				}
				//break;
			} else {
			//default:
				r2 = r1 - HASH_OFFSET;
				r2 = hash_table[r2].token_type;
				r3 = TYPE_STRUC;
				r2 = r2 && r3;
				//if ((hash_table[(token_stack[token]-HASH_OFFSET)].token_type & TYPE_STRUC) != TYPE_STRUC)
					//abort_b0("Structures can only contain variable definitions");
				if(r2 != r3){ abort_b0('Structures can only contain variable definitions'); }
				//if(DEBUG)
					//printf("Structure - Processing embedded structure\n");
				if(r12){
					echo_string(STDOUT, 'Structure - Processing embedded structure\n');
				}
				//atStackStart();
				atStackStart();
				//atStackEnd(i);
				atStackEnd(r13);
				//token--;
				r14 = token;
				r14 = r14 - 1;
				token = r14;

				// The structure which we want to copy.
				//ptr_struc_embedded = hash_table[token_stack[token]-HASH_OFFSET].struc_ptr;
				//s_offset = hash_table[token_stack[token]-HASH_OFFSET].local_offset;
				r1 = [r15+r14*8];
				r1 = r1 - HASH_OFFSET;
				r11 = hash_table[r1].struc_ptr;
				r3 = hash_table[r1].local_offset;
				ptr_struc_embedded = r11;
				s_offset = r3;
				
				//if(DEBUG)
					//printf("Source ptr = %p\n", ptr_struc_embedded);
				if(r12){
					echo_string(STDOUT, 'Embedded Source ptr = ');
					echo_hex(STDOUT, r11);
					echo_cr(STDOUT);
				}
				// The desintation
				r1 = struc_def;
				//offset = hash_table[struc_def].local_offset;
				//ptr_struc = hash_table[struc_def].struc_ptr;
				r4 = hash_table[r1].local_offset;
				r10 = hash_table[r1].struc_ptr;
				offset = r4;
				ptr_struc = r10;

				// Now copy the structures over
				//for (j = 0; j < s_offset; j++){
					//ScanForDupStrucLabel(struc_def, ptr_struc_embedded->struc[j].hash);
					//ptr_struc->struc[offset].type = ptr_struc_embedded->struc[j].type;
					//ptr_struc->struc[offset].size = ptr_struc_embedded->struc[j].size;
					//ptr_struc->struc[offset].hash = ptr_struc_embedded->struc[j].hash;
					//ptr_struc->struc[offset+1].offset = ptr_struc->struc[offset].offset + ptr_struc->struc[offset].size;
					//if(DEBUG)
						//printf("Variable %s, Type = 0x%x, Size = 0x%x, Offset = 0x%x\n", hash_table[ptr_struc->struc[offset].hash].token, ptr_struc->struc[offset].type, ptr_struc->struc[offset].size, ptr_struc->struc[offset].offset);
					//offset++;
				//}
				r2 = 0;
				while(r2 < r3){
					r8 = r2 << 5;
					r15 = r4 << 5;
					r9 = [r11+r8+struct_entry.hash];
					ScanForDupStrucLabel(r1, r9);
					if(r12){ echo_string(STDOUT, 'Variable '); r0 = &hash_table[r9].token; echo_string(STDOUT, r0); }
					[r10+r15+struct_entry.hash] = r9;
					r9 = [r11+r8+struct_entry.type];
					[r10+r15+struct_entry.type] = r9;
					if(r12){ echo_string(STDOUT, ', Type = '); echo_hex(STDOUT, r9); }
					r9 = [r11+r8+struct_entry.size];
					[r10+r15+struct_entry.size] = r9;
					if(r12){ echo_string(STDOUT, ', Size = '); echo_hex(STDOUT, r9); }
					r8 = [r10+r15+struct_entry.offset];
					if(r12){ echo_string(STDOUT, ', Offset = '); echo_hex(STDOUT, r8); echo_cr(STDOUT); }
					r9 = r9 + r8;
					r15 = r15 + 32;  // Each entry is 32bytes in size;
					[r10+r15+struct_entry.offset] = r9;
					r2 = r2 + 1;
					r4 = r4 + 1;
				}
				//hash_table[struc_def].local_offset = offset;
				hash_table[r1].local_offset = r4;
				//token = i;
				r14 = r13;
				token = r14;
				//break;
			}
		}
	//}
	}
	//token = 0;	// Clear the token stack
	token = 0;
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	//return(0);
}

proc process_token_stack(){
	//unsigned int i, j, k, l, exit_struc;
	m64 i;
	m64 j;
	m64 k;
	m64 l;
	
	
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12, r13, r14, r15;
	
	r12 = DEBUG;
	if(r12){
		echo_string(STDOUT, 'Process_token_stack()\n');
	}
	
	//preparse_token_stack();
	preparse_token_stack();
	
	//i = token; // i holds the number of tokens to process.
	r15 = &token_stack;
	r14 = token;
	r13 = r14;
	i = r13;
	//if(DEBUG){
		//printf("PROCESSING STACK : ");
		//for (token = 0; token < i; token++){
			//printf("0x%x ", token_stack[token]);
		//}
		//printf("\n");
	//}
	r12 = DEBUG;
	if(r12){
		echo_string(STDOUT, 'PROCESSING STACK : ');
		r14 = 0;
		while (r14 < r13){
			r1 = [r15+r14*8];
			echo_hex(STDOUT, r1);
			echo_string(STDOUT, ' ');
			r14 = r14 + 1;
		}
		echo_cr(STDOUT);
	}
		
	r11 = &pp_GenCode;
	r10 = pp_ptr;
	r0 = 0;
	r1 = TOKEN_PREPARSER;
	r2 = [r15];
	r3 = [r11+r10*8];
	r4 = 1;
	if(r2 == r1) { r0 = 1; }
	if(r3 == r4) { r0 = 1; }
	//if ((pp_GenCode[pp_ptr] == 1)||(token_stack[0] == TOKEN_PREPARSER)) {
		//token = 0;		// Set the token pointer to the start of the stack
	if (r0) {
		r14 = 0;
		token = r14;
	} else {
		//if (token_stack[0] == TOKEN_BLOCK_END){
		r1 = TOKEN_BLOCK_END;
		if(r2 == r1){
			// The next valid token could be a PREPARSER command which we definitely need to execute.
			r0 = 0;
			//while ((token_stack[j] == TOKEN_BLOCK_END) & (j < i)){
				// Scan the token stack for the last TOKEN_END_BLOCK
				//j++;
			//}
			r2 = [r15+r0*8];
			r3 = 0;
			if (r2 == r1) { 
				if (r0 < r13) { r3 = 1; }
			}
			while (r3){
				r3 = 0;
				r0 = r0 + 1;
				r2 = [r15+r0*8];
				if (r2 == r1) { 
					if (r0 < r13) { r3 = 1; }
				}
			}
				
			// If we're at the end, just exit
			if (r0 == r13){
				token = r13;
				r14 = r13;
			} else {
				// Else see if the next one is a preparser command.
				r2 = [r15+r0*8];
				r1 = TOKEN_PREPARSER;
				if(r2 != r1){
					//token = i;
					r14 = r13;
					token = r14;
				} else {
					//Before continuing, let's see if we need to process the end_block's.
					r1 = pp_ptr;
					r1 = [r11+r1*8];
					//r1 = pp_GenCode[r1];
					r3 = r0;	// make r3 our count into the token stack with the start of the TOKEN
					r0 = 0;
					if(r1 == r0){
						// Skip the end_blocks;
						r0 = DEBUG;
						if(r0){
							echo_string(STDOUT, 'Have preprocessor command, pp_GenCode = 0, and need to skip }\'s\n');
						}
						// r15 = token_stack;
						// r3 = our start position;
						// r13 = the end;
						// r2 = our new token_stack_length.
						// r14 = token position (should be 0);
						r2 = 0;
						while(r3 < r13){
							r0 = [r15+r3*8];
							[r15+r2*8] = r0;
							r3 = r3 + 1;
							r2 = r2 + 1;
						}
						r13 = r2;	// Our new end
					}
					//token = 0;
					r14 = 0;
					token = r14;
				}
			}
		} else {
			//token = i;		// Set the token pointer to the end of the stack, which causes no code generation to occur!
			r14 = r13;
			token = r14;
			// if skipping if(){, while(){, etc
			r0 = ch;
			r1 = CHAR_OCPARAN;
			if(r0 == r1){
				r1 = block_level;
				r1 = r1 - 1;
				block_level = r1;
				r0 = DEBUG;
				if(r0){
					echo_string(STDOUT, 'BLOCK_2 (skip) Current Block Level is ');
					echo_hex(STDOUT, r1);
					echo_cr(STDOUT);
				}
			}
		}
	}
	//while (token < i){
	while(r14 < r13){
		//if(DEBUG)
			//printf("Processing Stack\n");
		if(r12){
			echo_string(STDOUT, 'Processing Stack - token = ');
			echo_hex(STDOUT, r14);
			echo_string(STDOUT, ' i = ');
			echo_hex(STDOUT, r13);
			echo_cr(STDOUT);
		}
		r1 = [r15+r14*8];
		r0 = HASH_lib+HASH_OFFSET; if (r0 == r1){ process_lib_directive(r13); } else {
		r0 = HASH_syscall+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_sysret+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_fdecstp+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_fincstp+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_ret+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_extern+HASH_OFFSET; if(r0 == r1){ process_extern_directive(r13); } else {
		r0 = HASH_push+HASH_OFFSET; if(r0 == r1){ process_pushpop_directive(r13); } else {
		r0 = HASH_pop+HASH_OFFSET; if(r0 == r1) { process_pushpop_directive(r13); } else {
		r0 = HASH_in+HASH_OFFSET; if(r0 == r1){ process_inout_directive(r13); } else {
		r0 = HASH_out+HASH_OFFSET; if(r0 == r1) { process_inout_directive(r13); } else {
		r0 = HASH_call+HASH_OFFSET; if (r0 == r1){ process_calljmp_directive(r13); } else {
		r0 = HASH_jmp+HASH_OFFSET; if(r0 == r1){ process_calljmp_directive(r13); } else {
		r0 = HASH_asm+HASH_OFFSET; if(r0 == r1){ process_asm_directive(r13); } else {
		r0 = HASH_else+HASH_OFFSET; if (r0 == r1){ abort_b0('Unexpected ELSE'); } else {
		r0 = TOKEN_BLOCK_END; if(r0 == r1){ r13 = process_token_block_end(r13); i = r13; } else {
		r0 = HASH_if+HASH_OFFSET; if(r0 == r1){ process_ifwhile_directive(r13); } else {
		r0 = HASH_while+HASH_OFFSET; if(r0 == r1){ process_ifwhile_directive(r13); } else {
		r0 = HASH_proc+HASH_OFFSET; if (r0 == r1){ process_proc_directive(r13); } else {
		r0 = HASH_m8+HASH_OFFSET; if (r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_m16+HASH_OFFSET;if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_m32+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13);} else {
		#ifndef i386;
		r0 = HASH_m64+HASH_OFFSET;
		#else;
		r0 = HASH_m32+HASH_OFFSET;
		#endif;
		if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_f32+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_f64+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_f80+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_v4i+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_v4f+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_v2f+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_struc+HASH_OFFSET; if(r0 == r1){ process_struc_directive(r13); } else {
		r0 = TOKEN_NOT; if(r0 == r1){ process_notminus_directive(r13); } else {
		r0 = TOKEN_MINUS; if(r0 == r1){ process_notminus_directive(r13); } else {
		r0 = HASH_exit+HASH_OFFSET; if(r0 == r1){ process_exit_directive(r13); } else {
		r0 = HASH_return+HASH_OFFSET; if(r0 == r1){ process_exit_directive(r13); } else {
		r0 = HASH_macro+HASH_OFFSET; if(r0 == r1){ process_macro_directive(r13); } else {
		r0 = HASH_iflock+HASH_OFFSET; if(r0 == r1){ process_iflock_directive(r13); } else {
		r0 = HASH_lock+HASH_OFFSET; if(r0 == r1){ process_lock_directive(r13); } else {
		r0 = HASH_unlock+HASH_OFFSET; if(r0 == r1){ process_unlock_directive(r13); } else {
		r0 = TOKEN_PREPARSER; if(r0 == r1){ process_token_preparser(r13);} else {
			//default;
			//if(DEBUG)
				//printf("Processing Default: - token index = %d; i = %d\n", token, i);
			if(r12){
				echo_string(STDOUT, 'Processing Default: - token index = ');
				echo_hex(STDOUT, r14);
				echo_string(STDOUT, '; i = ');
				echo_hex(STDOUT, r13);
				echo_cr(STDOUT);
			}
			
			r0 = HASH_OFFSET;
			//if(token_stack[token] > HASH_OFFSET){
			if(r1 > r0){
				//if (((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_STRUC)==TYPE_STRUC) &&
					//(hash_table[token_stack[token]-HASH_OFFSET].struc_ptr != NULL)){
					//process_struc_def(i);
					//token = i;
					//break;
				//}
				r2 = r1 - r0;
				r3 = hash_table[r2].token_type;
				r4 = TYPE_STRUC;
				r3 = r3 && r4;
				if(r3 == r4){
					r3 = hash_table[r2].struc_ptr;
					if(r3){
						process_struc_def(r13);
						token = r13;
						r14 = r13;
						token = 0;
						//return(1);
						pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
						return(1);
					}
				}
				r3 = hash_table[r2].token_type;
				r4 = TYPE_MACRO;
				r3 = r3 && r4;
				if(r3 == r4){
					process_macro(r13);
					token = r13;
					r14 = r13;
					token = 0;
					//return(1);
					pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
					return(1);
				}
			//}
			}
			
			//if(global == 0)
				//abort_b0("Unexpected instructions");
			r2 = global;
			r3 = 0;
			if(r2 == r3){
				r1 = block_level;
				r0 = DEBUG;
				if(r0){
					echo_string(STDOUT, 'BLOCK_2 Current Block Level is ');
					echo_hex(STDOUT, r1);
					echo_string(STDOUT, '; Global = ');
					echo_hex(STDOUT, r2);
					echo_cr(STDOUT);
				}
				abort_b0('Unexpected instructions');
			}
			
			//if ( token_stack[token] < TOKEN_ARRAY_START)
				//abort_b0("Invalid construct");
			r1 = [r15+r14*8];
			r2 = TOKEN_ARRAY_START;
			if(r1 < r2){
				abort_b0('Invalid construct');
			}
			
			// Determine if operation is an int or FP operation?
			//if (TS_is_int(i)){
				//process_int_operation(i);
			//} else {
				//process_fpu_operation(i);
			//}
			r0 = TS_is_int(r13);
			if(r0){
				r1 = 2;
				if(r0 == r1){
					process_xmm_operation(r13);
				} else {
					process_int_operation(r13);
				}
			} else {
				process_fpu_operation(r13);
			}
			//token = i;
			r14 = r13;
			token = r14;

			}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
		r14 = token;
	}
	//token = 0;
	token = 0;
	//return(1);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(1);
}

proc nextToken(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//int i;
	//unsigned int UTF32;
	//while (isSpace(ch)) {
		//skip whitespace
		//getChar();
	//}
	r1 = ch;
	r0 = isSpace(r1);
	while (r0){
		getChar();
		r1 = ch;
		r0 = isSpace(r1);
	}
	//if (ch == '/') { // Skip comments
	r2 = CHAR_FSLASH;
	if(r1 == r2){
		r3 = look_ahead_ch;
		//if (look_ahead_ch == '/'){
		if(r3 == r2){
			r0 = 0;
			r4 = CHAR_CR;
			r5 = CHAR_LF;
			r8 = -1;
			if(r1 != r4){ 
				if(r1 != r5){
					if(r1 != r8){
						r0 = 1;
					}
				}
			}
			while (r0){
				getChar();
				r1 = ch;
				r0 = 0;
				if(r1 != r4){ 
					if(r1 != r5){
						if(r1 != r8){
							r0 = 1;
						}
					}
				}
			}
			//return(0);
			pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
			return(0);
		}
	}
	r1 = ch;
	r2 = isDigit(r1);
	r3 = isAlpha(r1);
	r2 = r2 + r3;
	r0 = 0;
	if(r2 == r0){
	//if (!isDigit(ch) && !isAlpha(ch)) {
		//process operator
		//switch(ch) {
		r2 = CHAR_SQUOT;
		if(r1 == r2){
			//case '\'' :
				//insert_token_stack(TOKEN_STRING);
				insert_token_stack(TOKEN_STRING);
				r12 = DEBUG;
				//if(DEBUG)
					//printf("START STRING\n");
				if(r12){
					echo_string(STDOUT, 'START STRING\n');
				}
				//getChar();
				getChar();
				r1 = ch;
				r2 = CHAR_SQUOT;
				//while (ch != '\'') {
				while(r1 != r2){
					//if (ch == '\\') {
					r3 = CHAR_BSLASH;
					if(r1 == r3){
						r3 = look_ahead_ch;
						//switch (look_ahead_ch) {
						r4 = CHAR_n;
						if(r3 == r4){
							//case 'n' :
								//insert_token_stack(CR);
								insert_token_stack(CHAR_LF);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output 0x%x , ch == %c\n", CH, ch);
								if(r12){
									echo_string(STDOUT, 'Output ');
									echo_hex(STDOUT, CHAR_LF);
									echo_string(STDOUT, ' , ch == ');
									echo_character(STDOUT, r1);
									echo_cr(STDOUT);
								}
								//break;
								
						} else {
						r4 = CHAR_r;
						if(r3 == r4){
							//case 'r' :
								//insert_token_stack(LF);
								insert_token_stack(CHAR_CR);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output 0x%x , ch == %c\n", LF, ch);
								if(r12){
									echo_string(STDOUT, 'Output ');
									echo_hex(STDOUT, CHAR_CR);
									echo_string(STDOUT, ' , ch == ');
									echo_character(STDOUT, r1);
									echo_cr(STDOUT);
								}
								//break;
								
						} else {
						r4 = CHAR_t;
						if(r3 == r4){
							//case 't' :
								//insert_token_stack(TAB);
								insert_token_stack(CHAR_HT);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output 0x%x , ch == %c\n", TAB, ch);
								if(r12){
									echo_string(STDOUT, 'Output ');
									echo_hex(STDOUT, CHAR_HT);
									echo_string(STDOUT, ' , ch == ');
									echo_character(STDOUT, r1);
									echo_cr(STDOUT);
								}
								//break;
								
						} else {
						r4 = CHAR_BSLASH;
						if(r3 == r4){
							//case '\\' :
								//insert_token_stack('\\');
								insert_token_stack(CHAR_BSLASH);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output \\, ch == %c\n", ch);
								if(r12){
									echo_string(STDOUT, 'Output \\ , ch == ');
									echo_character(STDOUT, r1);
									echo_cr(STDOUT);
								}
								//break;
								
						} else {
						r4 = CHAR_SQUOT;
						if(r3 == r4){
							//case '\'' :
								//insert_token_stack('\'');
								insert_token_stack(CHAR_SQUOT);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output \', ch == %c\n", ch);
								if(r12){
									echo_string(STDOUT, 'Output \' , ch == ');
									echo_character(STDOUT, r1);
									echo_cr(STDOUT);
								}
								//break;
								
						} else {
						r4 = CHAR_0;
						if(r3 == r4){
							//case '\0' :
								//insert_token_stack('\0');
								insert_token_stack(0);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output NULL, ch == NULL\n");
								if(r12){
									echo_string(STDOUT, 'Output NULL, ch == NULL\n');
								}
								//break;
						} else {
							//default :
								//insert_token_stack((unsigned int) ch);
								insert_token_stack(r1);
								//getChar();
								getChar();
								//break;
						//}
						}}}}}}
						r1 = ch;
					//} else {
					} else {
						//if (ch == 0xffffffff)
						r3 = -1;
						if(r1 == r3){
							//return(0);
							pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
							return(0);
						}
						// What we need to do is handle UTF-8 input correctly.
						r3 = 07fh;
						//if (ch < 0x7f) {
						if(r1 < r3){
							//insert_token_stack((unsigned int) ch);
							insert_token_stack(r1);
						//} else {
						} else {
							// We must have a UTF-8 character.
							r3 = 0dfh;
							///if (ch < 0xdf) {
							if(r1 < r3){
								// we have a 2 byte sequence
								//UTF32 = (unsigned int) ch & 0x1f;
								r4 = r1 && 01fh;
								//UTF32 = UTF32 << 6;
								r4 = r4 << 6;
								//getChar(); // Get our second character
								getChar();
								//if (ch < 0x7f)
									//abort_b0("Poor UTF-8 construct");
								r1 = ch;
								r3 = 07fh;
								if(r1 < r3){
									abort_b0('Poor UTF-8 construct');
								}
								//UTF32 = UTF32 + (ch & 0x3f);
								r1 = r1 && 03fh;
								r4 = r4 + r1;
								//insert_token_stack(UTF32);
								insert_token_stack(r4);
							//} else {
							} else {
								r3 = 0f0h;
								//if (ch < 0xf0) {
								if(r1 < r3){
									// We have a 3 byte sequence
									//UTF32 = (unsigned int) ch & 0x0f;
									r4 = r1 && 0fh;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our second character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int)ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our third character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int)ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//insert_token_stack(UTF32);
									insert_token_stack(r4);
								//} else {
								} else {
									// We must have a 4 byte sequence
									//UTF32 = (unsigned int) ch & 0x0f;
									r4 = r1 && 0fh;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our second character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int) ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our second character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int) ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our second character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int) ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//insert_token_stack(UTF32);
									insert_token_stack(r4);
								//}
								}
							//}
							}
						//}
						}
						//getChar();
						getChar();
					//}
					}
					r1 = ch;
					r2 = CHAR_SQUOT;
				//}
				}
				//insert_token_stack(TOKEN_END_STRING);
				insert_token_stack(TOKEN_END_STRING);
				r12 = DEBUG;
				//if(DEBUG)
					//printf("END STRING\n");
				if(r12){
					echo_string(STDOUT, 'END STRING\n');
				}
				//break;
		} else {
			r2 = CHAR_OCPARAN;
			if(r1 == r2){
			//case '{' :
				//return(2);
				pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
				return(2);
				//break;
				
		} else {
			r2 = CHAR_CCPARAN;
			if(r1 == r2){
			//case '}' :
				//insert_token_stack(TOKEN_BLOCK_END);
				insert_token_stack(TOKEN_BLOCK_END);
				//break;
				
		} else {
			r2 = CHAR_SCOLON;
			if(r1 == r2){
			//case ';' :
				//getChar();
				//return(1);
				getChar();
				pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
				return(1);
				//break;
				
		} else {
			r2 = CHAR_EQU;
			if(r1 == r2){
			//case '=' :
				//if (look_ahead_ch == '=') {
					//getChar();
					//insert_token_stack(TOKEN_EQUALS);
				//} else {
					//insert_token_stack(TOKEN_EQUATE);
				//}
				r3 = look_ahead_ch;
				if(r3 == r2){
					getChar();
					insert_token_stack(TOKEN_EQUALS);
				} else {
					insert_token_stack(TOKEN_EQUATE);
				}
				//break;	
				
		} else {
			r2 = CHAR_AMP;
			if(r1 == r2){
			//case '&' :
				//if (look_ahead_ch == '&') {
					//getChar();
					//insert_token_stack(TOKEN_AND);
				//} else {
					//insert_token_stack(TOKEN_POINTER);
				//}
				r3 = look_ahead_ch;
				if(r3 == r2){
					getChar();
					insert_token_stack(TOKEN_AND);
				} else {
					insert_token_stack(TOKEN_POINTER);
				}
				
				//break;
				
		} else {
			r2 = CHAR_VL;
			if(r1 == r2){
			//case '|' :
				//insert_token_stack(TOKEN_OR);
				insert_token_stack(TOKEN_OR);
				//break;

		} else {
			r2 = CHAR_CARAT;
			if(r1 == r2){
			//case '^' :
				//insert_token_stack(TOKEN_XOR);
				insert_token_stack(TOKEN_XOR);
				//break;
				
		} else {
			r2 = CHAR_EXCL;
			if(r1 == r2){
			//case '!' :
				//if (look_ahead_ch == '=') {
					//getChar();
					//insert_token_stack(TOKEN_NOTEQUALS);
				//} else {
					//insert_token_stack(TOKEN_NOT);
				//}
				r3 = look_ahead_ch;
				r4 = CHAR_EQU;
				if(r3 == r4){
					getChar();
					insert_token_stack(TOKEN_NOTEQUALS);
				} else {
					insert_token_stack(TOKEN_NOT);
				}
				//break;
				
		} else {
			r2 = CHAR_ASTX;
			if(r1 == r2){
			//case '*' :
				//insert_token_stack(TOKEN_MULTIPLY);
				insert_token_stack(TOKEN_MULTIPLY);
				//break;
				
		} else {
			r2 = CHAR_PLUS;
			if(r1 == r2){
			//case '+' :
				//insert_token_stack(TOKEN_ADD);
				insert_token_stack(TOKEN_ADD);
				//break;
				
		} else {
			r2 = CHAR_MINUS;
			if(r1 == r2){
			//case '-' :
				//insert_token_stack(TOKEN_MINUS);
				insert_token_stack(TOKEN_MINUS);
				//break;
				
		} else {
			r2 = CHAR_FSLASH;
			if(r1 == r2){
			//case '/' :
				//insert_token_stack(TOKEN_DIVIDE);
				insert_token_stack(TOKEN_DIVIDE);
				//break;
				
		} else {
			r2 = CHAR_PERCENT;
			if(r1 == r2){
			//case '%' :
				//insert_token_stack(TOKEN_MODULUS);
				insert_token_stack(TOKEN_MODULUS);
				//break;
				
		} else {
			r2 = CHAR_OPARAN;
			if(r1 == r2){
			//case '(' :
				//insert_token_stack(TOKEN_PARA_START);
				insert_token_stack(TOKEN_PARA_START);
				//break;
				
		} else {
			r2 = CHAR_CPARAN;
			if(r1 == r2){
			//case ')' :
				//insert_token_stack(TOKEN_PARA_END);
				insert_token_stack(TOKEN_PARA_END);
				//break;
		} else {
			r2 = CHAR_SOPARAN;
			if(r1 == r2){
			//case '[' :
				//insert_token_stack(TOKEN_ARRAY_START);
				insert_token_stack(TOKEN_ARRAY_START);
				//break;
				
		} else {
			r2 = CHAR_SCPARAN;
			if(r1 == r2){
			//case ']' :
				//insert_token_stack(TOKEN_ARRAY_END);
				insert_token_stack(TOKEN_ARRAY_END);
				//break;
				
		} else {
			r2 = CHAR_LT;
			if(r1 == r2){
			//case '<' :
				r3 = look_ahead_ch;
				//if (look_ahead_ch == '<') {
				if(r3 == r2){
					//getChar();
					getChar();
					r3 = look_ahead_ch;
					//if (look_ahead_ch == '<') {
					if(r3 == r2){
						//getChar();
						getChar();
						//insert_token_stack(TOKEN_LROTATE);
						insert_token_stack(TOKEN_LROTATE);
					//} else {
					} else {
						//insert_token_stack(TOKEN_LSHIFT);
						insert_token_stack(TOKEN_LSHIFT);
					//}
					}
				//} else {
				} else {
					r2 = CHAR_EQU;
					//if (look_ahead_ch == '=') {
					if(r3 == r2){
						//getChar();
						getChar();
						//insert_token_stack(TOKEN_LESSTHANEQUALS);
						insert_token_stack(TOKEN_LESSTHANEQUALS);
					//} else {
					} else {
						//insert_token_stack(TOKEN_LESSTHAN);
						insert_token_stack(TOKEN_LESSTHAN);
					//}
					}
				//}
				}
				//break;
				
		} else {
			r2 = CHAR_GT;
			if(r1 == r2){
			//case '>' :
				r3 = look_ahead_ch;
				//if (look_ahead_ch == '>') {
				if(r3 == r2){
					//getChar();
					getChar();
					r3 = look_ahead_ch;
					//if (look_ahead_ch == '>') {
					if(r3 == r2){
						//getChar();
						getChar();
						//insert_token_stack(TOKEN_RROTATE);
						insert_token_stack(TOKEN_RROTATE);
					//} else {
					} else {
						//insert_token_stack(TOKEN_RSHIFT);
						insert_token_stack(TOKEN_RSHIFT);
					//}
					}
				//} else {
				} else {
					r2 = CHAR_EQU;
					//if (look_ahead_ch == '=') {
					if(r3 == r2){
						//getChar();
						getChar();
						//insert_token_stack(TOKEN_GREATERTHANEQUALS);
						insert_token_stack(TOKEN_GREATERTHANEQUALS);
					//} else {
					} else {
						//insert_token_stack(TOKEN_GREATERTHAN);
						insert_token_stack(TOKEN_GREATERTHAN);
					//}
					}
				//}
				}
				//break;

		} else {
			r2 = CHAR_COMMA;
			if(r1 == r2){
			//case ',' :
			    //insert_token_stack(TOKEN_COMMA);
				insert_token_stack(TOKEN_COMMA);
				//break;

		} else {
			r2 = CHAR_STOP;
			if(r1 == r2){
			//case '.' :
			    //insert_token_stack(TOKEN_FULLSTOP);
				insert_token_stack(TOKEN_FULLSTOP);
				//break;

		} else {
			r2 = CHAR_HASH;
			if(r1 == r2){
			//case '#' :
			    //insert_token_stack(TOKEN_PREPARSER);
				insert_token_stack(TOKEN_PREPARSER);
				//break;

		} else {
			r2 = CHAR_DOLLAR;
			if(r1 == r2){
			//case '$' :
			    //insert_token_stack(TOKEN_PREPARSER);
				insert_token_stack(TOKEN_MACROARG);
				//break;


		} else {
			r2 = CHAR_TILDE;
			if(r1 == r2){
			//case '~' :	//Signed operation
				//switch(look_ahead_ch){
				r3 = look_ahead_ch;
				r4 = CHAR_GT;
				if(r3 == r4){
					//case '>' : getChar();
								getChar();
								r3 = look_ahead_ch;
								r4 = CHAR_EQU;
								//if (look_ahead_ch == '=') {
								if(r3 == r4){
									//getChar();
									getChar();
									//insert_token_stack(TOKEN_S_GREATERTHANEQUALS);
									insert_token_stack(TOKEN_S_GREATERTHANEQUALS);
								//} else {
								} else {
									//insert_token_stack(TOKEN_S_GREATERTHAN);
									insert_token_stack(TOKEN_S_GREATERTHAN);
								//}
								}
								//break;
								
				} else {
					
					r4 = CHAR_LT;
					if(r3 == r4){
					//case '<' : getChar();
								getChar();
								r3 = look_ahead_ch;
								r4 = CHAR_EQU;
								//if (look_ahead_ch == '=') {
								if(r3 == r4){
									//getChar();
									getChar();
									//insert_token_stack(TOKEN_S_LESSTHANEQUALS);
									insert_token_stack(TOKEN_S_LESSTHANEQUALS);
								//} else {
								} else {
									//insert_token_stack(TOKEN_S_LESSTHAN);
									insert_token_stack(TOKEN_S_LESSTHAN);
								//}
								}
								//break;
				} else {
					
					r4 = CHAR_ASTX;
					if(r3 == r4){
								
					//case '*' : getChar(); 
								getChar();
								//insert_token_stack(TOKEN_S_MULTIPLY); 
								insert_token_stack(TOKEN_S_MULTIPLY);
								//break;
								
				} else {
					
					r4 = CHAR_FSLASH;
					if(r3 == r4){
					//case '/' : getChar(); 
								getChar();
								//insert_token_stack(TOKEN_S_DIVIDE); 
								insert_token_stack(TOKEN_S_DIVIDE);
								//break;
								
				} else {
					
					r4 = CHAR_PERCENT;
					if(r3 == r4){
					//case '%' : getChar(); 
								getChar();
								//insert_token_stack(TOKEN_S_MODULUS); 
								insert_token_stack(TOKEN_S_MODULUS);
								//break;
								
				} else {
					//default :
						//abort_b0("Unknown Signed operation");
						abort_b0('Unknown Signed operation');
						//break;
				//}
				}}}}}
				//break;

		} else {
				//default :
				//if (ch == 0xffffffff){
					//return(1);
				//}
				r1 = ch;
				r3 = look_ahead_ch;
				r2 = -1;
				if(r1 == r2){
					pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
					return(1);
				}
				r2 = 0efh;
				if(r1 == r2){
					r4 = 0bbh;
					if(r3 == r4){
				//if ((ch == 0xef) && (look_ahead_ch == 0xbb)) {
					// we may have a BOM
						//getChar(); // Get the next char
						getChar();
						//if (look_ahead_ch != 0xbf)
							//abort_b0("Unknown Symbol - BOM");
						r3 = look_ahead_ch;
						r4 = 0bfh;
						if(r3 != r4){
							abort_b0('Unknown Symbol - BOM');
						}
						//getChar(); // Move the BOM indicator 0xbf into ch.
						getChar();
					} else {
						abort_b0('Unknown Symbol - UNK');
					}
				//} else {
				} else {
					//printf("ch = 0x%x, lch = 0x%x\n", ch, look_ahead_ch);
					//abort_b0("Unknown Symbol - UNK");
					abort_b0('Unknown Symbol - UNK');
				//}
				}
				//break;
		//}
		}}}}}}}}}}}}}}}}}}}}}}}}}
		//getChar();
		getChar();
	//} else {
	} else {
		r2 = isDigit(r1);
		//if (isDigit(ch)){
		if(r2){
			//process digit
			r13 = &token_buffer;
			r0 = 0;
			r1 = 0;
			r11 = TOKEN_MAX_SIZE;
			while (r1 < r11){		//Clear the token buffer to place the number in there
				[r13+r1] = r0b;
				r1 = r1 + 1;
			}
			r1 = 0; 
			r5 = 0;		// isFP flag
			r2 = ch;
			r3 = isXDigit(r2);	
			while(r3){				// Continue while we have an xDigit (0-9, a-f);
				[r13+r1] = r2b;		// insert the character into the string
				r1 = r1 + 1;		// Increment the string offset pointer
				if(r1 >= r11){		// Check for overflow >256 chars (Number would be way too big anyway).
					abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE');
				}
				getChar();			// Get our next character
				r2 = ch;
				r2 = tolower(r2);	// Lower case it.
				r3 = isXDigit(r2);	// is it within our range?
				r0 = 0;
				if(r3 == r0){
					r4 = CHAR_STOP;		// If not, do we have a fullstop
					if(r2 == r4){		// If so, set some registers accordingly
						r3 = 1;
						r5 = 1;
						r8 = look_ahead_ch;
						r4 = isDigit(r8);	// after a full stop MUST be a 0-9
						if(r4 == r0){
							abort_b0('Malformed number');
						}
					} else {
						r4 = CHAR_h;
						if(r2 == r4){
							r3 = 1;		// do forget to include our 'h' postfix.
						}
					}
				}
				r0 = CHAR_e;
				if(r2 == r0){
					if(r5){
						// We have a float and e is present?
						[r13+r1] = r2b;
						r1 = r1 + 1;
						r8 = look_ahead_ch;
						r4 = CHAR_MINUS;			// Check for '1.0e-99' format
						if(r8 == r4){
							[r13+r1] = r8b;
							r1 = r1 + 1;
							getChar();
						} else {
							r4 = CHAR_PLUS;			// Check for '1.0e+99' format
							if(r8 == r4){
								[r13+r1] = r8b;
								r1 = r1 + 1;
								getChar();
							}
						}
						getChar();				// get our next character
						r2 = ch;
						r3 = isDigit(r2);		// which should be 0-9 (after either the 'e', '-' or '+')
						r0 = 0;
						if(r3 == r0){
							abort_b0('Malformed number');
						}
					}
				}
			}
			insert_token_stack_number(r13);		// Looks like we are all done, so noe convert the string to a
												// number and shove it onto the token stack.
		//} else {
		} else {
			//process token
			//Clear our token buffer
			//for (i = 0; i < TOKEN_MAX_SIZE; i++) {
				//token_buffer[i] = 0;
			//}
			
			r13 = &token_buffer;
			r0 = 0;
			r1 = 0;
			r11 = TOKEN_MAX_SIZE;
			while (r1 < r11){
				[r13+r1] = r0b;
				r1 = r1 + 1;
			}
			
			// copy our input into the buffer
			//toki = 0;
			r1 = 0; 
			r2 = ch;
			r3 = isAlpha(r2);
			r4 = isDigit(r2);
			r3 = r3 + r4;
			//while (isAlpha(ch) || isDigit(ch)) {
			while(r3){

	//push r0;
	//echo_string(STDOUT, 'nextToken()\n');
	//pop r0;


				//token_buffer[toki] = (unsigned char) (ch & 0xff);
				//r2 = r2 && 0ffh;
				[r13+r1] = r2b;
				//toki++;
				r1 = r1 + 1;
				//if (toki >= TOKEN_MAX_SIZE) abort_b0("INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE");

	//push r0;
	//echo_string(STDOUT, 'nextToken()\n');
	//pop r0;


				if(r1 >= r11){
					abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE');
				}
				//getChar();
				getChar();

	//push r0;
	//echo_string(STDOUT, 'nextToken()\n');
	//pop r0;


				r2 = ch;
				r3 = isAlpha(r2);
				r4 = isDigit(r2);
				r3 = r3 + r4;
			//}
			}
			// get the hash
			//token_hash = (ElfHash(&token_buffer[0])) % HASH_TABLE_SIZE + 1; //Can't have tokens = 0
			r0 = ElfHash(r13);
			r3 = r0;
			//echo_string(STDOUT, 'ELFHash = ');
			//echo_hex(STDOUT, r3);
			//echo_string(STDOUT, '\n');
			r0 = r3;
			r2 = HASH_TABLE_SIZE;
			r3 = r3 ^ r3;
			r0 = r0 % r2;
			r0 = r0 + 1;
			//if (token_hash >= (HASH_TABLE_SIZE-1)) token_hash = 1;
			
			r2 = r2 - 1;
			if (r0 >= r2) { r0 = 1; }
			
			r1 = r0;		//r1 = token_hash
			//echo_string(STDOUT, 'Adjusted Hash = ');
			//echo_hex(STDOUT, r1);
			//echo_string(STDOUT, '\n');
			r0 = 0;
			r2 = hash_table[r1].hash;
			// Check for collision?
			//if (hash_table[token_hash].hash == 0){
			if(r2 == r0){
				// No entry, so we just enter the hash into the table
				//hash_table[token_hash].hash = token_hash;
				hash_table[r1].hash = r1;
				//strcpy((char *) hash_table[token_hash].token, ( char *) token_buffer);
				r3 = &hash_table[r1].token;
				r13 = r13 - 2;
				strcpy(r3, r13);
				r13 = r13 + 2;
				r12 = DEBUG;
				//if(DEBUG)
					//printf("TOKEN : %s = 0x%lx\n", hash_table[token_hash].token, hash_table[token_hash].hash);
				if(r12){
					echo_string(STDOUT, 'TOKEN : ');
					echo_string(STDOUT, r3);
					echo_string(STDOUT, ' = ');
					echo_hex(STDOUT, r1);
					echo_cr(STDOUT);
				}
			} else {
			//} else {
				// Let's see if we have the same string
				r3 = &hash_table[r1].token;
				r13 = r13 - 2;
				r0 = strcmp(r13, r3);
				//if (strcmp((char *) token_buffer, ( char *) hash_table[token_hash].token)) {
				if(r0){
					// If the string are different, then we have a real problem!
					//if(DEBUG)
						//printf("Hash Collision Detected 0x%lx = %s = %s\n", token_hash, hash_table[token_hash].token, token_buffer);
					r12 = DEBUG;
					if(r12){
						echo_string(STDOUT, 'Hash Collision Detected ');
						echo_hex(STDOUT, r1);
						echo_string(STDOUT, ' = ');
						echo_string(STDOUT, r3);
						echo_string(STDOUT, ' = ');
						echo_string(STDOUT, r13);
						echo_cr(STDOUT);
					}
					//i = 0;
					r5 = 0;
					r9 = 0;
					r0 = 0;
					if(r2 != r9) { 
						r10 = strcmp(r13, r3);
						if(r10) { 
							r0 = 1;
						}
					}
					r11 = HASH_TABLE_SIZE - 1;
					//while ((hash_table[token_hash].hash != 0) && strcmp((char *) token_buffer, ( char *) hash_table[token_hash].token)) {
					while(r0){
						//token_hash++; // Linear refactor the hash!
						r1 = r1 + 1;
						//echo_string(STDOUT, 'New HASH = ');
						//echo_hex(STDOUT, r1);
						//echo_string(STDOUT, '\n');
						//i++;
						r5 = r5 + 1;
						//if (i >= HASH_TABLE_SIZE-1) {
						if(r5 >= r11){
							//if(DEBUG){
							if(r12){
								r11 = r11 + 1;
								//printf("HASH TABLE----------\n");
								echo_string(STDOUT, 'HASH TABLE----------\n');
								r5 = 0;
								//for (i = 0; i < HASH_TABLE_SIZE; i++) {
									//if (hash_table[i].hash != 0)
										//printf("0x%x -> 0x%lx = %s\n", i, hash_table[i].hash, hash_table[i].token);
								//};
								while(r5 < r11){
									r1 = hash_table[r5].hash;
									if(r1){
										echo_hex(STDOUT, r5);
										echo_string(STDOUT, ' -> ');
										echo_hex(STDOUT, r1);
										echo_string(STDOUT, ' = ');
										r0 = &hash_table[r5].token;
										echo_string(STDOUT, r0);
										echo_cr(STDOUT);
									}
									r5 = r5 + 1;
								}
							//}
							}
							//abort_b0("INTERNAL: Hash Table Overflow! - Increase HASH_TABLE_SIZE");
							abort_b0('INTERNAL: Hash Table Overflow! - Increase HASH_TABLE_SIZE');
						//}
						}
						//if (token_hash >= HASH_TABLE_SIZE-1) {
							//token_hash = 1; // Wrap around so we don't go off the table
						//}
						if(r1 >= r11){
							r1 = 1;
						}
						r3 = &hash_table[r1].token;
						r2 = hash_table[r1].hash;
						r0 = 0;
						if(r2 != r9) { 
							r10 = strcmp(r13, r3);  // r13 = &token_buffer, r3 = hash_table[token_hash].token;
							if(r10) { 
								r0 = 1;
							}
						}
					//}
					}
					//hash_table[token_hash].hash = token_hash;
					hash_table[r1].hash = r1;
					r3 = &hash_table[r1].token;
					//strcpy((char *) hash_table[token_hash].token, ( char *) token_buffer);
					
					strcpy(r3, r13);
					//if(DEBUG)
						//printf("TOKEN : %s = 0x%lx\n", hash_table[token_hash].token, hash_table[token_hash].hash);
					if(r12){
						echo_string(STDOUT, 'TOKEN : ');
						echo_string(STDOUT, r3);
						echo_string(STDOUT, ' = ');
						echo_hex(STDOUT, r1);
						echo_cr(STDOUT);
					}
				//}
				}
			//}
			}
			//insert_token_stack(token_hash+HASH_OFFSET);
			r1 = r1 + HASH_OFFSET;
			insert_token_stack(r1);
		//}
		}
	//}
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
};

proc end_block_else(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//unsigned int old_block_num;
	//block_level--;
	r12 = DEBUG;
	r15 = block_level;
	r15 = r15 - 1;
	block_level = r15;
	//if (DEBUG)
		//printf("EBE_ current block level is %d\n", block_level);
	if(r12){
		echo_string(STDOUT, 'EBE_ Current Block Level is ');
		echo_hex(STDOUT, r15);
		echo_cr(STDOUT);
	}
	r0 = 1;
	//if (block_level < 1)
		//abort_b0("Unexpected }");
	if(r15 < r0){
		abort_b0('Unexpected }');
	}
	//if (block_level == 1) {
	if(r15 == r0){
		//abort_b0("Unexpected ELSE");
		abort_b0('Unexpected ELSE');
	//} else {
	} else {
		r1 = if_while_stack[r15].type;
		r2 = HASH_if;
		//if (if_while_stack[block_level].type == HASH_if) {
		if(r1 == r2){
			// Lets terminate the if statement
			//old_block_num = if_while_stack[block_level].offset;
			r4 = if_while_stack[r15].offset;
			//if_while_stack[block_level].offset = block_num;
			r1 = block_num;
			if_while_stack[r15].offset = r1;
			r14 = code;
			//fprintf(code, "\tjmp .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset);
			echo_string(r14, '\tjmp .B0_END_BLOCK_0000');
			echo_hex(r14, r1);
			echo_cr(r14);
			//fprintf(code, "\t.B0_END_BLOCK_0000%d:\n", old_block_num);
			echo_string(r14, '\t.B0_END_BLOCK_0000');
			echo_hex(r14, r4);
			echo_string(r14, ':\n');
		//} else {
		} else {
			r2 = HASH_while;
			//if (if_while_stack[block_level].type == HASH_while)
				//abort_b0("Unexpected ELSE");
			if(r1 == r2){
				abort_b0('Unexpected ELSE');
			}
		//}
		}
	//}
	}
	//return(0);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
};

proc end_block(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r15 = code;
	r14 = data;
	r13 = bss;
	r12 = DEBUG;
	r11 = block_level;
	//block_level--;
	r11 = r11 - 1;
	block_level = r11;
	//if(DEBUG)
		//printf("EB_ Current Block Level is %d\n", block_level);
	if(r12){
		echo_string(STDOUT, 'EB_ Current Block Level is ');
		echo_hex(STDOUT, r11);
		echo_cr(STDOUT);
	}
	r0 = 1;
	//if (block_level < 1)
		//abort_b0("Unexpected }");
	if(r11 < r0){
		abort_b0('Unexpected }');
	}
	//if (block_level == 1) {
	if(r11 == r0){
		r1 = global;
		//if (global != 0){  // If global == 0 then we must be in a struc?
		if(r1){
			r1 = r1 - HASH_OFFSET;
			r2 = &hash_table[r1].token;
			//fprintf(code, "\tmov r0, 0\n\tret\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
			//fprintf(code, "; End %s Function Code;\n", hash_table[(global-HASH_OFFSET)].token);
			//fprintf(code, ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n");
			echo_string(r15, '\tmov r0, 0\n\tret\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n');
			echo_string(r15, '; End ');
			echo_string(r15, r2);
			echo_string(r15, ' Function Code;\n');
			echo_string(r15, ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n');
			
			//fprintf(data, "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
			//fprintf(data, "; End %s Function Variables ;\n", hash_table[(global-HASH_OFFSET)].token);
			//fprintf(data, ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n");				
			echo_string(r14, '\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n');
			echo_string(r14, '; End ');
			echo_string(r14, r2);
			echo_string(r14, ' Function Variables ;\n');
			echo_string(r14, ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n');
			//fprintf(bss,  "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
			//fprintf(bss,  "; End %s Function BSS Variables ;\n", hash_table[(global-HASH_OFFSET)].token);
			//fprintf(bss,  ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n");				
			echo_string(r13, '\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n');
			echo_string(r13, '; End ');
			echo_string(r13, r2);
			echo_string(r13, ' Function BSS Variables ;\n');
			echo_string(r13, ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n');
			//hash_table[(global-HASH_OFFSET)].local_offset = local_var_offset;
			r3 = local_var_offset;
			hash_table[r1].local_offset = r3;
			//global = 0;
			global = 0;
		//}
		}
	//} else {
	} else {
		// We most likely have ended a if or a while. Let's ensure that we terminate the block 
		// correctly.
		r1 = if_while_stack[r11].type;
		r2 = HASH_if;
		//if (if_while_stack[block_level].type == HASH_if) {
		if(r1 == r2){
			// Lets terminate the if statement
			//fprintf(code, "\t.B0_END_BLOCK_0000%d:\n", if_while_stack[block_level].offset);
			r3 = if_while_stack[r11].offset;
			echo_string(r15, '\t.B0_END_BLOCK_0000');
			echo_hex(r15, r3);
			echo_string(r15, ':\n');
		//} else {
		} else {
			r2 = HASH_while;
			//if (if_while_stack[block_level].type == HASH_while) {
			if(r1 == r2){
				// Lets terminate the while block correctly
				r3 = if_while_stack[r11].if_while_test1;
				r4 = hash_table[r3].token_type;
				r5 = TYPE_FLAG;
				//if (hash_table[if_while_stack[block_level].if_while_test1].token_type == TYPE_FLAG) {
				if(r4 == r5){
					// We have a flag comparison, so this is really easy.
					//switch(if_while_stack[block_level].if_while_test1){
					r5 = HASH_CARRY;
					if(r3 == r5){
						//case HASH_CARRY: fprintf(code, "\tjc .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						//r15 = code;
						echo_string(r15, '\tjc .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOCARRY;
						if(r3 == r5){
						//case HASH_NOCARRY: fprintf(code, "\tjnc .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjnc .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_OVERFLOW;
						if(r3 == r5){
						//case HASH_OVERFLOW: fprintf(code, "\tjo .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjo .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOOVERFLOW;
						if(r3 == r5){
						//case HASH_NOOVERFLOW: fprintf(code, "\tjno .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjno .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_PARITY;
						if(r3 == r5){
						//case HASH_PARITY: fprintf(code, "\tjp .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjp .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOPARITY;
						if(r3 == r5){
						//case HASH_NOPARITY: fprintf(code, "\tjnp .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjnp .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_ZERO;
						if(r3 == r5){
						//case HASH_ZERO: 	fprintf(code, "\tjz .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjz .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOTZERO;
						if(r3 == r5){
						//case HASH_NOTZERO: fprintf(code, "\tjnz .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjnz .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_SIGN;
						if(r3 == r5){
						//case HASH_SIGN: 	fprintf(code, "\tjs .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjs .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOTSIGN;
						if(r3 == r5){
						//case HASH_NOTSIGN: fprintf(code, "\tjns .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjns .B0_END_BLOCK_0000');
					} else {
						//default: abort_b0("Unknown CPU FLAG"); break;
						abort_b0('Unknown CPU FLAG');
					//}
					}}}}}}}}}}
					r1 = if_while_stack[r11].offset;
					r1 = r1 - 1;
					echo_hex(r15, r1);
					echo_string(r15, '\n\t.B0_END_BLOCK_0000');
					r1 = r1 + 1;
					echo_hex(r15, r1);
					echo_string(r15, ':\n');
				//} else {
				} else {
					r5 = TYPE_REG;
					//if (hash_table[if_while_stack[block_level].if_while_test1].token_type == TYPE_REG) {
					if(r4 == r5){
						// Int test
						//if ((hash_table[if_while_stack[block_level].if_while_test2].token_type != TYPE_REG) && (if_while_stack[block_level].if_while_test2 != HASH_zero))
							//abort_b0("Second operand MUST be a integer register");
						r1 = if_while_stack[r11].if_while_test2;
						r2 = HASH_zero;
						if(r1 != r2){
							r4 = hash_table[r1].token_type;
							if(r4 != r5){
								abort_b0('Second operand MUST be a integer register');
							}
						}

						echo_string(r15, '\tcmp ');
						r0 = &hash_table[r3].token;
						echo_string(r15, r0);
						echo_string(r15, ', ');
						r0 = &hash_table[r1].token;
						echo_string(r15, r0);
						echo_cr(r15);
						
						r3 = if_while_stack[r11].comparison;
						//switch (if_while_stack[block_level].comparison) {
						r5 = TOKEN_EQUALS;
						if(r3 == r5){
							//case TOKEN_EQUALS :	fprintf(code, "\tje .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tje .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_NOTEQUALS;
							if(r3 == r5){
							//case TOKEN_NOTEQUALS : fprintf(code, "\tjne .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjne .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_LESSTHAN;
							if(r3 == r5){
							//case TOKEN_LESSTHAN : fprintf(code, "\tjb .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjb .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_GREATERTHAN;
							if(r3 == r5){
							//case TOKEN_GREATERTHAN : fprintf(code, "\tja .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tja .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_LESSTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_LESSTHANEQUALS : fprintf(code, "\tjbe .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjbe .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_GREATERTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_GREATERTHANEQUALS : fprintf(code, "\tjae .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjae .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_LESSTHAN;
							if(r3 == r5){
							//case TOKEN_S_LESSTHAN : fprintf(code, "\tjl .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjl .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_GREATERTHAN;
							if(r3 == r5){
							//case TOKEN_S_GREATERTHAN : fprintf(code, "\tjg .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjg .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_LESSTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_S_LESSTHANEQUALS : fprintf(code, "\tjle .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjle .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_GREATERTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_S_GREATERTHANEQUALS : fprintf(code, "\tjge .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjge .B0_END_BLOCK_0000');
						} else {
							abort_b0('Unknown Comparison');
						//}
						}}}}}}}}}}
						r1 = if_while_stack[r11].offset;
						r1 = r1 - 1;
						echo_hex(r15, r1);
						echo_string(r15, '\n\t.B0_END_BLOCK_0000');
						r1 = r1 + 1;
						echo_hex(r15, r1);
						echo_string(r15, ':\n');
					//} else {
					} else {
						// FPU test
						r1 = if_while_stack[r11].if_while_test1;
						r4 = if_while_stack[r11].if_while_test2;
						r5 = HASH_zero;
						//if (if_while_stack[block_level].if_while_test2 != HASH_zero){
						if(r4 != r5){
							// Non-zero test
							//if (if_while_stack[block_level].if_while_test1 != HASH_fp0)
								//abort_b0("Floating point comparison requires that fp0 be the first operand");
							r5 = HASH_fp0;
							if(r1 != r5){
								abort_b0('Floating point comparison requires that fp0 be the first operand');
							}
							//if (hash_table[if_while_stack[block_level].if_while_test2].token_type != TYPE_REG_FPU)
								//abort_b0("Second operand MUST be a FPU register");
							r0 = hash_table[r4].token_type;
							r5 = TYPE_REG_FPU;
							if(r0 != r5){
								abort_b0('Second operand MUST be a FPU register');
							}
							//fprintf(code, "\tfcomi %s\n", hash_table[if_while_stack[block_level].if_while_test2].token );
							echo_string(r15, '\tfcomi ');
							r0 = &hash_table[r4].token;
							echo_string(r15, r0);
							echo_cr(r15);

						//} else {
						} else {
							// Handle test against zero
							r4 = hash_table[r3].token_type;
							r5 = TYPE_REG_FPU;
							//if (hash_table[if_while_stack[block_level].if_while_test1].token_type != TYPE_REG_FPU)
								//abort_b0("Operand MUST be a register");
							if (r4 != r5){
								abort_b0('Operand MUST be a register');
							}
							//fprintf(code, "\tfldz\n\tfcomip ");
							echo_string(r15, '\tfldz\n\tfcomip ');
							//switch(if_while_stack[block_level].if_while_test1){
							r5 = HASH_fp0;
							if(r3 == r5){
								//case HASH_fp0: fprintf(code, "fp1\n"); break;
								echo_string(r15,'fp1\n');
							} else {
								r5 = HASH_fp1;
								if(r3 == r5){
								//case HASH_fp1: fprintf(code, "fp2\n"); break;
								echo_string(r15,'fp2\n');
							} else {
								r5 = HASH_fp2;
								if(r3 == r5){
								//case HASH_fp2: fprintf(code, "fp3\n"); break;
								echo_string(r15,'fp3\n');
							} else {
								r5 = HASH_fp3;
								if(r3 == r5){
								//case HASH_fp3: fprintf(code, "fp4\n"); break;
								echo_string(r15,'fp4\n');
							} else {
								r5 = HASH_fp4;
								if(r3 == r5){
								//case HASH_fp4: fprintf(code, "fp5\n"); break;
								echo_string(r15,'fp5\n');
							} else {
								r5 = HASH_fp5;
								if(r3 == r5){
								//case HASH_fp5: fprintf(code, "fp6\n"); break;
								echo_string(r15,'fp6\n');
							} else {
								r5 = HASH_fp6;
								if(r3 == r5){
								//case HASH_fp6: fprintf(code, "fp7\n"); break;
								echo_string(r15,'fp7\n');
							} else {
								r5 = HASH_fp7;
								if(r3 == r5){
								//case HASH_fp7: abort_b0("Error FPU stack overflow in WHILE construct"); break;
								abort_b0('Error FPU stack overflow in WHILE construct');
							}}}}}}}}
						}
						//switch (if_while_stack[block_level].comparison) {
						r3 = if_while_stack[r11].comparison;
						r5 = TOKEN_EQUALS;
						if(r3 == r5){
							//case TOKEN_EQUALS :	fprintf(code, "\tje .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tje .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_NOTEQUALS;
							if(r3 == r5){
							//case TOKEN_NOTEQUALS : fprintf(code, "\tjne .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjne .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_LESSTHAN;
							if(r3 == r5){
							//case TOKEN_LESSTHAN : fprintf(code, "\tjb .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjb .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_GREATERTHAN;
							if(r3 == r5){
							//case TOKEN_GREATERTHAN : fprintf(code, "\tja .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tja .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_LESSTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_LESSTHANEQUALS : fprintf(code, "\tjbe .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjbe .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_GREATERTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_GREATERTHANEQUALS : fprintf(code, "\tjae .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjae .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_LESSTHAN;
							if(r3 == r5){
							//case TOKEN_S_LESSTHAN : fprintf(code, "\tjb .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjb .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_GREATERTHAN;
							if(r3 == r5){
							//case TOKEN_S_GREATERTHAN : fprintf(code, "\tja .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tja .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_LESSTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_S_LESSTHANEQUALS : fprintf(code, "\tjbe .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjbe .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_GREATERTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_S_GREATERTHANEQUALS : fprintf(code, "\tjae .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjae .B0_END_BLOCK_0000');
						} else {
							abort_b0('Unknown Comparison');
						//}					
						}}}}}}}}}}
						r1 = if_while_stack[r11].offset;
						r1 = r1 - 1;
						echo_hex(r15, r1);
						echo_string(r15, '\n\t.B0_END_BLOCK_0000');
						r1 = r1 + 1;
						echo_hex(r15, r1);
						echo_string(r15, ':\n');
					//}
					}
				//}
				}
			//}
			}
		//}
		}
		//if_while_stack[block_level].type = 0;
		if_while_stack[r11].type = 0;
		// Else fall through
	//}
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
};

proc block(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//unsigned int do_process = 0;
	r9 = 0;
	//block_level++;
	r15 = block_level;
	r15 = r15 + 1;
	block_level = r15;
	r14 = DEBUG;
	//if(DEBUG)
		//printf("BLOCK_ Current Block Level is %d\n", block_level);
	if(r14){
		echo_string(STDOUT, 'BLOCK_ Current Block Level is ');
		echo_hex(STDOUT, r15);
		echo_cr(STDOUT);
	}

	//if (block_level >= TOKEN_STACK_SIZE)
		//abort_b0("INTERNAL: Block Level is too large - too many nested blocks - Increase TOKEN_STACK_SIZE");
	r0 = TOKEN_STACK_SIZE;
	if(r15 >= r0){
		abort_b0('INTERNAL: Block Level is too large - too many nested blocks - Increase TOKEN_STACK_SIZE');
	}
	//block_num++;
	r13 = block_num;
	r13 = r13 + 1;
	block_num = r13;
	//getChar();				// Get next character
	getChar();

	r1 = ch;
	r2 = -1;
	//if (ch ==  0xffffffff) { //If EOF
	if(r1 == r2){
		if(r14){ echo_string(STDOUT, 'Closing file\n'); }
		//fclose(file[file_stack_ptr].handle); // Close current file
		r3 = file_stack_ptr;
		r4 = file[r3].handle;
		_fclose(r4);
		//file_stack_ptr--;	//Move the file stack pointer down one
		r3 = r3 - 1;
		file_stack_ptr = r3;
		if(r14){ echo_string(STDOUT, 'file_stack_ptr = '); echo_hex(STDOUT, r3); echo_cr(STDOUT); }
		//if (file_stack_ptr < 0) {
		r4 = 0;
		if(r3 ~< r4){
			pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
			//return(0);		// If we are now off the stack, exit
			//echo_string(STDOUT, 'Here\n');
			return(0);
		//} else {
		} else {
			//ch = file[file_stack_ptr].ch;
			r0 = file[r3].ch;
			ch = r0;
			//look_ahead_ch = file[file_stack_ptr].look_ahead_ch;
			r0 = file[r3].look_ahead_ch;
			look_ahead_ch = r0;
		//}
		}
		//process_token_stack();
		process_token_stack();
							// else process remaining tokens to flush the stack
							// before moving onto another file
		//block_level--;
		r15 = block_level;
		r15 = r15 - 1;
		block_level = r15;
		if(r14){
			echo_string(STDOUT, 'BLOCK_ Current Block Level is now ');
			echo_hex(STDOUT, r15);
			echo_string(STDOUT, ' after flush\n');
		}
	//}
	}
	r1 = ch;
	r2 = -1;
	//while (ch != 0xffffffff) {
	while(r1 != r2){
		//do_process = nextToken();
		r9 = nextToken();
		//if (DEBUG) 
			//printf("do_process = 0x%x, token = 0x%x\n", do_process, token);
		r8 = token;
		r14 = DEBUG;
		if(r14){
			echo_string(STDOUT, 'block_do_process = ');
			echo_hex(STDOUT, r9);
			echo_string(STDOUT, ', token = ');
			echo_hex(STDOUT, r8);
			echo_string(STDOUT, ', Block Level = ');
			r15 = block_level;
			echo_hex(STDOUT, r15);
			echo_cr(STDOUT);
		}
		r0 = 0;
		//if (token != 0){
		if(r8 != r0){
			//switch(do_process){
			r0 = 1;
			if(r9 == r0){
				//case 1 : process_token_stack(); break;		// get the next token, and set token variable
				process_token_stack();
			} else {
				r0 = 2;
				if(r9 == r0){
				//case 2 : process_token_stack(); block(); break;
					process_token_stack(); 
					block();
				}
			}
			//}
		//}
		} else {
			r0 = 2;
			if(r9 == r0){
			//case 2 : process_token_stack(); block(); break;
				process_token_stack(); 
				block();
			}			
		}
		//do_process = 0;
		r9 = 0;
		r1 = ch;
		r2 = -1;
	//}
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	//echo_string(STDOUT, 'Here2\n');
	return(0);
};

proc include_standard_output(){
	push r1;
	r1 = file[0].handle;
	#ifndef i386;
	echo_string(r1, '\n;Register renaming\n\nr0 equ rax\nr0d equ eax\nr0w equ ax\nr0b equ al\n');
	echo_string(r1, 'r1 equ rbx\nr1d equ ebx\nr1w equ bx\nr1b equ bl\n');
	echo_string(r1, 'r2 equ rcx\nr2d equ ecx\nr2w equ cx\nr2b equ cl\n');
	echo_string(r1, 'r3 equ rdx\nr3d equ edx\nr3w equ dx\nr3b equ dl\n');
	echo_string(r1, 'r4 equ rdi\nr4d equ edi\nr4w equ di\nr4b equ dil\n');
	echo_string(r1, 'r5 equ rsi\nr5d equ esi\nr5w equ si\nr5b equ sil\n');
	echo_string(r1, 'r6 equ rbp\nr6d equ ebp\nr6w equ bp\nr6b equ bpl\n');
	echo_string(r1, 'r7 equ rsp\nr7d equ esp\nr7w equ sp\nr7b equ spl\n\n');
	#else;
	echo_string(r1, '\n;Register renaming\n\nr0 equ eax\nr0w equ ax\nr0b equ al\n');
 	echo_string(r1, 'r1 equ ebx\nr1w equ bx\nr1b equ bl\n');
 	echo_string(r1, 'r2 equ ecx\nr2w equ cx\nr2b equ cl\n');
 	echo_string(r1, 'r3 equ edx\nr3w equ dx\nr3b equ dl\n');
 	echo_string(r1, 'r4 equ edi\nr4w equ di\n');
 	echo_string(r1, 'r5 equ esi\nr5w equ si\n');
 	echo_string(r1, 'r6 equ ebp\nr6w equ bp\n');
 	echo_string(r1, 'r7 equ esp\nr7w equ sp\n\n');
	#endif;
	
	echo_string(r1, 'fp0 equ ST0\nfp1 equ ST1\nfp2 equ ST2\nfp3 equ ST3\n');
	echo_string(r1, 'fp4 equ ST4\nfp5 equ ST5\nfp6 equ ST6\nfp7 equ ST7\n\n');
	

	echo_string(r1, ';Default Macros\n');
	echo_string(r1, 'macro UTF16_STRING name, [string]\n{\n');
	echo_string(r1, 'common\n\tname:\nlocal label,label2\n\tlabel:\n');
	echo_string(r1, '\tdw ((label2-label)/2)-3\n\tdw ((label2-label)/2)-3\n');
	echo_string(r1, '\tdw string\n\tlabel2:\n\tdw 0\n}\n\n');
	echo_string(r1, 'macro UTF8_STRING name, [string]\n{\n');
	echo_string(r1, 'common\n\tname:\nlocal label,label2\n\tlabel:\n');
	echo_string(r1, '\tdb (label2-label)-3\n\tdb (label2-label)-3\n');
	echo_string(r1, '\tdb string\n\tlabel2:\n\tdb 0\n}\n\n');
	pop r1;
};

proc include_public_extrns(){
	push r1, r2, r3, r4, r5;
	//unsigned int i;
	r1 = 0;
	r5 = file[0].handle;
	r2 = HASH_TABLE_SIZE;
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
	while (r1 < r2){
		//if ((hash_table[i].hash != 0)&&(hash_table[i].token_type == TYPE_PROC)){
		r0 = 0;
		r3 = hash_table[r1].hash;
		if(r3 != r0){
			r3 = hash_table[r1].token_type;
			r0 = TYPE_PROC;
			if(r3 == r0){
				r4 = HASH_main;
				//if (i == 0x36768) {
				if(r1 == r4){
					//fprintf(file[0].handle, "public _B0_%s as 'main'\n", hash_table[i].token);
					echo_string(r5, 'public _B0_');
					r0 = &hash_table[r1].token;
					echo_string(r5, r0);
					echo_string(r5, ' as \'main\'\n');
				//} else {
				} else {
					//fprintf(file[0].handle, "public _B0_%s\n", hash_table[i].token);
					r0 = EXPLICIT_EXPORT;
					if(r0){
						r3 = hash_table[r1].token_import_lib;
						r0 = TYPE_EPROC;
						if(r3 == r0){
							echo_string(r5, 'public _B0_');
							r0 = &hash_table[r1].token;
							echo_string(r5, r0);
							echo_string(r5, ' as \'');
							r3 = &hash_table[r1].token_import_name;
							echo_string(r5, r3);
							echo_string(r5, '\'');
						}
						echo_cr(r5);
					} else {
						echo_string(r5, 'public _B0_');
						r0 = &hash_table[r1].token;
						echo_string(r5, r0);
						r3 = hash_table[r1].token_import_lib;
						r0 = TYPE_EPROC;
						if(r3 == r0){
							echo_string(r5, ' as \'');
							r3 = &hash_table[r1].token_import_name;
							echo_string(r5, r3);
							echo_string(r5, '\'');
						}
						echo_cr(r5);					
					}
				//}
				}
		//}
		}}
		r1 = r1 + 1;
	//};
	}
	//fprintf(file[0].handle, "\n\n");
	echo_string(r5, '\n\n');
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//if ((hash_table[i].hash != 0)&&(hash_table[i].token_type == TYPE_EPROC))
			//fprintf(file[0].handle, "extrn %s\n", hash_table[i].token);
	//};
	r1 = 0;
	while(r1 < r2){
		r0 = 0;
		r3 = hash_table[r1].hash;
		if(r3 != r0){
			r3 = hash_table[r1].token_type;
			r0 = TYPE_EPROC;
			if(r3 == r0){
				echo_string(r5, 'extrn ');
				r0 = &hash_table[r1].token;
				echo_string(r5, r0);
				echo_cr(r5);
			}
		}
		r1 = r1 + 1;
	}
	//fprintf(file[0].handle, "\n\n");
	echo_string(r5, '\n\n');
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//if ((hash_table[i].hash != 0)&&(hash_table[i].token_type == 0))
			//fprintf(file[0].handle, "extrn _B0_%s\n", hash_table[i].token);
	//};
	r1 = 0;
	r0 = EXPLICIT_EXPORT;
	if (r1 == r0){
		while(r1 < r2){
			r0 = 0;
			r3 = hash_table[r1].hash;
			if(r3 != r0){
				r3 = hash_table[r1].token_type;
				if(r3 == r0){
					//echo_string(r5, 'extrn _B0_');
					//r0 = &hash_table[r1].token;
					//echo_string(r5, r0);
					//echo_cr(r5);
				}
			}
			r1 = r1 + 1;
		}
	}
	pop r5, r4, r3, r2, r1;
};

proc include_public_extrns_pe(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//unsigned int i = 0, j = 0;
	r15 = file[0].handle;
	r14 = HASH_TABLE_SIZE;
	r13 = DEBUG;
	
	// Let's start by scanning the hash_table and ensuring each EPROC has a parent ELIB defined
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//if (hash_table[i].token_type == TYPE_EPROC){
			//if (hash_table[i].token_import_lib == 0x0)
				//abort_b0("External Procedure has not been linked to a parent DLL");		
		//}
	//};	
	r0 = 0;
	r1 = r0;
	r2 = TYPE_EPROC;
	while (r1 < r14){
		r3 = hash_table[r1].token_type;
		if(r3 == r2){
			r4 = hash_table[r1].token_import_lib;
			if(r4 == r0){
				abort_b0('External Procedure has not been linked to a parent DLL');
			}
		}
		r1 = r1 + 1;
	}
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//if ((hash_table[i].token_type == TYPE_ELIB))
			//fprintf(file[0].handle, "dd 0,0,0, RVA %s_name, RVA %s_table\n", hash_table[i].token, hash_table[i].token);
	//};	
	r1 = 0;
	r2 = TYPE_ELIB;
	while (r1 < r14){
		r3 = hash_table[r1].token_type;
		if (r3 == r2){
			r4 = &hash_table[r1].token;
			echo_string(r15, '\tdd 0,0,0, RVA ');
			echo_string(r15, r4);
			echo_string(r15, '_name, RVA ');
			echo_string(r15, r4);
			echo_string(r15, '_table\n');
		}
		r1 = r1 + 1;
	}

	//fprintf(file[0].handle, "dd 0,0,0,0,0\n\n");
	echo_string(r15, '\tdd 0,0,0,0,0\n\n');

	r1 = 0;
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
	while(r1 < r14){
		r3 = hash_table[r1].token_type;
		//if ((hash_table[i].token_type == TYPE_ELIB)){
		if(r3 == r2){
			//fprintf(file[0].handle, "%s_table:\n", hash_table[i].token);
			r4 = &hash_table[r1].token;
			echo_string(r15, '\t');
			echo_string(r15, r4);
			echo_string(r15, '_table:\n');
			r8 = 0;
			//for (j = 0; j < HASH_TABLE_SIZE; j++){
			while(r8 < r14){
				r9 = hash_table[r8].token_import_lib;
				//if (hash_table[j].token_import_lib == i){
				if(r9 == r1){
					// That is this token is matched to a known ELIB!
					r10 = &hash_table[r8].token;
					//#ifndef i386
					#ifndef i386;
					//fprintf(file[0].handle, "\t%s dq RVA _%s\n", hash_table[j].token, hash_table[j].token);
					echo_string(r15, '\t\t');
					echo_string(r15, r10);
					echo_string(r15, ' dq RVA _');
					echo_string(r15, r10);
					echo_cr(r15);
					//#else
					#else;
					//fprintf(file[0].handle, "\t%s dd RVA _%s\n", hash_table[j].token, hash_table[j].token);
					echo_string(r15, '\t\t');
					echo_string(r15, r10);
					echo_string(r15, ' dd RVA _');
					echo_string(r15, r10);
					echo_cr(r15);
					//#endif
					#endif;
				//}
				}
				r8 = r8 + 1;
			//}
			}
			//#ifndef i386
			#ifndef i386;
			//fprintf(file[0].handle, "\t\tdq 0\n\n");
			echo_string(r15, '\t\tdq 0\n\n');
			//#else
			#else;
			//fprintf(file[0].handle, "\t\tdd 0\n\n");
			echo_string(r15, '\t\tdd 0\n\n');
			//#endif
			#endif;
		//}
		}
		r1 = r1 + 1;
	//};
	}

	r1 = 0;
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
	while(r1 < r14){
		r3 = hash_table[r1].token_type;
		//if ((hash_table[i].token_type == TYPE_ELIB)){
		if(r3 == r2){
			//if (DEBUG)
				//printf("%s is '%s',0\n", hash_table[i].token, hash_table[i].token_import_name);
			if(r13){
				r0 = &hash_table[r1].token;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, ' is \'');
				r0 = &hash_table[r1].token_import_name;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, '\',0\n');
			}
			r0 = &hash_table[r1].token_import_name;
			r4 = 0;
			r4b = [r0+2];
			r4 = r4 && 0ffh;
			r0 = 0;
			//if (hash_table[i].token_import_name[0] == 0x0)
			if(r4 == r0){
				//abort_b0("External Library has not had DLL name defined");
				abort_b0('External Library has not had DLL name defined');
			}
			//fprintf(file[0].handle, "%s_name db '%s',0\n", hash_table[i].token, hash_table[i].token_import_name);
			echo_string(r15, '\t');
			r0 = &hash_table[r1].token;
			echo_string(r15, r0);
			echo_string(r15, '_name db \'');
			r0 = &hash_table[r1].token_import_name;
			echo_string(r15, r0);
			echo_string(r15, '\',0\n');
		//}
		}
		r1 = r1 + 1;
	//};		
	}
	//fprintf(file[0].handle, "\n");
	echo_cr(r15);

	r1 = 0;
	r2 = TYPE_EPROC;
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
	while(r1 < r14){
		r3 = hash_table[r1].token_type;
		//if ((hash_table[i].token_type == TYPE_EPROC)){
		if(r3 == r2){
			//if (DEBUG)
				//printf("%s is '%s',0\n", hash_table[i].token, hash_table[i].token_import_name);
			if(r13){
				r0 = &hash_table[r1].token;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, ' is \'');
				r0 = &hash_table[r1].token_import_name;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, '\',0\n');
			}
			r0 = &hash_table[r1].token_import_name;
			r4 = 0;
			r4b = [r0+2];
			r4 = r4 && 0ffh;
			r0 = 0;
			//if (hash_table[i].token_import_name[0] == 0x0)
			if(r4 == r0){
				//abort_b0("External Procedure has not had a name defined");
				abort_b0('External Procedure has not had a name defined');
			}
			//fprintf(file[0].handle, "_%s dw 0\n\tdb '%s',0\n", hash_table[i].token, hash_table[i].token_import_name);
			echo_string(r15, '\t_');
			r0 = &hash_table[r1].token;
			echo_string(r15, r0);
			echo_string(r15, ' dw 0\n\t\tdb \'');
			r0 = &hash_table[r1].token_import_name;
			echo_string(r15, r0);
			echo_string(r15, '\',0\n');
		//}
		}
		r1 = r1 + 1;
	//};
	}
			
	//fprintf(file[0].handle, "\n\n");
	echo_string(r15, '\n\n');
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};

proc str_is_gtr(hash1, hash2){
	push r1, r14, r15;
	r14 = hash1;
	r15 = hash2;
	r14 = &hash_table[r14].token_import_name;
	r15 = &hash_table[r15].token_import_name;
	r0 = 0;
	r1 = 0;
	r0b = [r14];
	r1b = [r15];
	while (r0 == r1){
		r14 = r14 + 1;
		r15 = r15 + 1;
		r0b = [r14];
		r1b = [r15];
	}
	if (r0 > r1){
		r0 = 1;
	} else {
		r0 = 0;
	}
	pop r15, r14, r1;
	return(r0);
}

proc include_public_procs_pe(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//unsigned int i = 0, j = 0;
	r15 = file[0].handle;
	r14 = HASH_TABLE_SIZE;
	r13 = DEBUG;
	r12 = 0;
	r11 = TOKEN_STACK_SIZE; // This is the max number of exported DLL functions.
	r10 = &DLL_EXPORTS;
	
	//Get export count number and build the export table;
	r1 = 0;
	while (r1 < r14){
		r0 = 0;
		r3 = hash_table[r1].hash;
		if(r3 != r0){
			r3 = hash_table[r1].token_type;
			r0 = TYPE_PROC;
			if(r3 == r0){
				r3 = hash_table[r1].token_import_lib;
				r0 = TYPE_EPROC;
				if(r3 == r0){
					[r10+r12*8] = r1;		//Save the index to the file into the export table
					r12 = r12 + 1;
					//echo_integer(STDOUT, r1);
					//echo_string(STDOUT, ' - ');
					//r0 = &hash_table[r1].token_import_name;
					//echo_string(STDOUT, r0);
					//echo_cr(STDOUT);
				}
			}
		}
		r1 = r1 + 1;
		if(r12 > r11){
			abort_b0('DLL export table overflow');
		}
	}
	
	//And now we sort the exported name list... (well just &DLL_EXPORTS).
	//
	//	function bubblesort (A : list[1..n]) {
    //		var int i, j;
    //		for i from n downto 1 {
    //			for j from 1 to i-1 { 
    //				if (A[j] > A[j+1])
    //					swap(A[j], A[j+1])
    //			}
    //		}
	//	}
	//
	// Yep we're using a bubble sort... so shoot me. :P
	// Seriously, on small lists bubble sort is fairly quick, esp,
	// if under 10 elements. I don't expect people to write
	// huge DLLs with 1000's of exports using b0.
	// But you never know...
	//
	
	// r10 = &list (need to preserve)
	// r12 = num of items in list. (need to preserve)
	// r1 = pointer into list.
	
	r1 = r12;	// This will be i from above
	r2 = 1;		// count down to this figure;
	r3 = r1 - r2;// This will be j ceiling
	r4 = 0;		// This will be j from above.
	
	while (r1 > r2){
		while (r4 < r3){
			r8 = [r10+r4*8];
			r9 = [r10+r4*8+8];
			r0 = str_is_gtr(r8, r9);  // rtns 1 if string r8 is greater than r9
			if (r0){
				[r10+r4*8] = r9;
				[r10+r4*8+8] = r8;
				//echo_string(STDOUT, 's');
			} //else {
				//echo_string(STDOUT, ' ');
			//}
			r4 = r4 + r2;
		} 
		// Print the current sort list;
		//r5 = 0;
		//while (r5 < r12){
		//	r8 = [r10+r5*8];
		//	r8 = &hash_table[r8].token_import_name;
		//	echo_string(STDOUT, r8);
		//	echo_string(STDOUT, ', ');
		//	r5 = r5 + 1;
		//	}
		//echo_cr(STDOUT);
		
		r1 = r1 - r2;
		r3 = r1 - r2;
		r4 = 0;
	}
	
	echo_string(r15, '\nsection \'.edata\' export data readable writeable\n\n');
	echo_string(r15, '\tdd 0            ; DLL Charactristics\n');
	echo_string(r15, '\tdd 0            ; DateTime Stamp\n');
	echo_string(r15, '\tdw 1            ; Major version\n');
	echo_string(r15, '\tdw 0            ; Minor version\n');
	echo_string(r15, '\tdd RVA DllName  ; Pointer to DLL Name\n');
	echo_string(r15, '\tdd 1            ; Ordinal Base\n');
	echo_string(r15, '\tdd ');
	echo_integer(r15, r12);
	echo_string(r15, '            ; Number of Functions\n');  
	echo_string(r15, '\tdd ');
	echo_integer(r15, r12);
	echo_string(r15, '            ; Number of Ordinals\n');	
	echo_string(r15, '\tdd RVA AddrTbl  ; Pointer to Function Address Table\n');
	echo_string(r15, '\tdd RVA NameTbl  ; Pointer to Function Name Table\n');
	echo_string(r15, '\tdd RVA OrdnTbl  ; Pointer to Function Ordinal Table\n\n');
	
	echo_string(r15, '\tAddrTbl:\n');
	r1 = 0;
	while (r1 < r12){
		r2 = [r10+r1*8];
		echo_string(r15, '\t\tdd RVA _B0_');
		r0 = &hash_table[r2].token;
		echo_string(r15, r0);
		echo_cr(r15);
		r1 = r1 + 1;
	}
	echo_cr(r15);
	
	echo_string(r15, '\tNameTbl:\n');
	r1 = 0;
	while (r1 < r12){
		r2 = [r10+r1*8];
		echo_string(r15, '\t\tdd RVA __B0_');
		r0 = &hash_table[r2].token;
		echo_string(r15, r0);
		echo_cr(r15);
		r1 = r1 + 1;
	}
	echo_cr(r15);

	echo_string(r15, '\tOrdnTbl:\n');
	
	r1 = 0;
	while (r1 < r12){
		r2 = [r10+r1*8];
		echo_string(r15, '\t\tdw ');
		echo_integer(r15, r1);
		echo_cr(r15);
		r1 = r1 + 1;
	}
	echo_cr(r15);

	echo_string(r15, '\tDllName db \'');
	r0 = &DLL_FILENAME;
	r0 = r0 - 2;
	echo_string(r15, r0);
	echo_string(r15, '\',0\n\n');
	
	r1 = 0;
	while (r1 < r12){
		r2 = [r10+r1*8];	
		echo_string(r15, '\t__B0_');
		r0 = &hash_table[r2].token;
		echo_string(r15, r0);
		echo_string(r15, ' db \'');
		r0 = &hash_table[r2].token_import_name;
		echo_string(r15, r0);
		echo_string(r15, '\',0\n');
		r1 = r1 + 1;
	}
	echo_cr(r15);

	
	echo_string(r15, '\n\n');
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
}

proc include_resource_file_pe(){
	push r0, r1, r14, r15;
	//unsigned int i = 0, j = 0;
	r15 = file[0].handle;
	r14 = DEBUG;
	r1 = &RSRC_FILENAME;
	r0 = 0;
	r0b = [r1];
	if(r0){
		// We have a resource filename.
		echo_string(r15, 'section \'.rsrc\' data readable resource from \'');
		r1 = r1 - 2;
		echo_string(r15, r1);
		echo_string(r15, '\'\n');
	}
	echo_string(r15, '\n\n');
	if(r14){
		echo_string(STDOUT, '.rsrc section = \'');
		echo_string(STDOUT, r1);
		echo_string(STDOUT, '\'\n');
	}		
	pop r15, r14, r1, r0;
	return(r0);
}


proc process_int_operation(i){
	v_base = 0;
	v_isStruc = 0;
	v_offset = 0;
	v_offset_type = 0;
	v_size = 0;
	v_index = 0;
	v_target = 0;
	v_global = 0;
	v_reg = 0;

	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12, r13, r14, r15;
	r15 = code;
	r14 = &token_stack;
	r13 = token;
	r12 = i;
	r11 = DEBUG;
	r1 = [r14+r13*8];
	r2 = TOKEN_ARRAY_START;

	//if ( token_stack[token] == TOKEN_ARRAY_START) {
	if(r1 == r2){
		//Process global memory reference;
		//fprintf(code, "\tmov [");
		echo_string(r15, '\tmov [');
		//token++;	//Increase token pointer;
		r13 = r13 + 1;
		token = r13;
		//Global_Pointer(i);
		Global_Pointer(r12);
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//fprintf(code, "], ");
		echo_string(r15, '], ');
		//token++;
		r13 = token;
		r13 = r13 + 1;
		token = r13;
		//TokenIs(TOKEN_EQUATE);
		TokenIs(TOKEN_EQUATE);
		//token++;
		r13 = token;
		r13 = r13 + 1;
		token = r13;
		r1 = [r14+r13*8];
		r2 = TOKEN_NUM_INTEGER;
		r0 = 0;
		if(r1 == r2) { r0 = 1; }
		r2 = TOKEN_NUM_DECIMAL;
		if(r1 == r2) { r0 = 1; }
		r2 = TOKEN_MINUS;
		if(r1 == r2) { r0 = 1; }
		//if ((token_stack[token] < TOKEN_OFFSET)||(token_stack[token]==TOKEN_MINUS)) {
		if(r0){
			//fprintf(code, "dword ");
			echo_string(r15, 'dword ');
			//if(token_stack[token] == TOKEN_MINUS){
				//fprintf(code, "-");
				//token++;
			//}
			if(r1 == r2){
				echo_character(r15, CHAR_MINUS);
				r13 = r13 + 1;
				token = r13;
			}
			//outputNumber(i, NUM_INTEGER);
			r1 = [r14+r13*8];
			r2 = TOKEN_NUM_INTEGER;
			if (r1 == r2){
				r1 = [r14+r13*8+8];
				r2 = 0ffffffffh;  // Immediate MUST be limited to 32bits
				if(r1 > r2){
					abort_b0('Immediate too large');
				}
				outputNumber(r12, NUM_INTEGER, r15);
			} else {
				outputNumber(r12, NUM_DECIMAL, r15);
			}
			//fprintf(code, "\n");
			echo_cr(r15);
		//} else {
		} else {	
			//isHash(token_stack[token]);
			isHash(r1);
			//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & (TYPE_REG+TYPE_REG_SHORT) ) > 0) {
				//fprintf(code, "%s\n", hash_table[token_stack[token]-HASH_OFFSET].token);
			//} else {
				//abort_b0("Integer Register Expected");
			//}
			r1 = r1 - HASH_OFFSET;
			r2 = hash_table[r1].token_type;
			r2 = r2 && TYPE_REG+TYPE_REG_SHORT;
			if(r2){
				r2 = &hash_table[r1].token;
				echo_string(r15, r2);
				echo_cr(r15);
			} else {
				abort_b0('Integer Register Expected');
			}
			//token++;
			r13 = token;
			r13 = r13 + 1;
			token = r13;
		}
		//atStackEnd(i);
		atStackEnd(r12);
	//} else {
	} else {
		//we must have a register, function, or label
		//if (token_stack[token] == TOKEN_ARRAY_END)
			//abort_b0("Unexpected token ']'");
		r2 = TOKEN_ARRAY_END;
		if(r1 == r2){
			abort_b0('Unexpected token \']\'');
		}
		r2 = r1 - HASH_OFFSET;
		r3 = hash_table[r2].token_type;
		r4 = r3 && 0fh;
		//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & 0xf) > 0) {
		if(r4){
			// We have a label;
			//if(DEBUG)
				//printf("Processing line with variable destination\n");
			if(r11){
				echo_string(STDOUT, 'Processing line with variable destination\n');
			}
			// Let's first find if we are handling a structure before continuing.
			//BuildLabelInfo(i);
			BuildLabelInfo(r12);
			//TokenIs(TOKEN_EQUATE);
			TokenIs(TOKEN_EQUATE);
			//token++;
			r13 = token;
			r13 = r13 + 1;
			token = r13;
			//v_target = token;
			v_target = r13;
			//if (token_stack[token] < TOKEN_OFFSET) {
				//if (DEBUG)
					//printf("Immediate being stored into memory location");
				
			//} else {
				//isHash(token_stack[token]);
				//TokenIsLabelType(TYPE_REG);
			//}
			r2 = [r14+r13*8];
			r0 = TOKEN_NUM_INTEGER;
			if(r2 == r0){
				if(r11){
					echo_string(STDOUT, 'Immediate being stored into memory location\n');
				}
			} else {
				isHash(r2);
				TokenIsLabelType(TYPE_REG);
			}
			
			// Now we have all our information, so let build the instruction...
			//if(DEBUG){
				//DisplayLabelInfo();	
			//}
			if(r11){
				DisplayLabelInfo();	
			}
			//if ((state == '3') || (state == '6') || (state == '8'))
				//abort_b0("Unable to store an integer in a floating point variable");
			r0 = state;
			r1 = 57h;
			if (r0 < r1){
				r1 = CHAR_SPACE;
				if(r0 != r1){
					abort_b0('Unable to store an integer in a floating point or vector variable');
				}
			}
			r0 = v_isStruc;
			r1 = 1;
			//if (v_isStruc == 1) {
			if (r0 == r1){
				//Let's handle the structure def intelligently, (what I'm doing below isn't intelligent).
				// What we do, is calculate the offset for any struc operation, and then do a
				// mov [r6|r14|r15], reg|immediate operation.
				//Set_v_reg();	//v_reg is the register we are going to use.
				Set_v_reg();
				//fprintf(code, "\tpush %s\n", hash_table[v_reg].token);
				r0 = v_reg;
				r1 = &hash_table[r0].token;
				echo_string(r15, '\tpush ');
				echo_string(r15, r1);
				echo_cr(r15);
				
				//Calculate_label_address(i);
				Calculate_label_address(r12);
				
				//Now we are ready to store the value...
				//switch(state){
					//case 'b' : fprintf(code, "\tmov byte [%s], ", hash_table[v_reg].token); break;
					//case 'w' : fprintf(code, "\tmov word [%s], ", hash_table[v_reg].token); break;
					//#ifndef i386
					//case 'd' : fprintf(code, "\tmov dword [%s], ", hash_table[v_reg].token); break;
					//default  : fprintf(code, "\tmov qword [%s], ", hash_table[v_reg].token); break;
					//#else
					//default  : fprintf(code, "\tmov dword [%s], ", hash_table[v_reg].token); break;
					//#endif
				//}
				r5 = state;
				r3 = CHAR_b; //b
				if (r5 == r3){
					echo_string(r15, '\tmov byte [');
					echo_string(r15, r1);
					echo_string(r15, '], ');
				} else {
					r3 = CHAR_w; // w
					if(r5 == r3){
						echo_string(r15, '\tmov word [');
						echo_string(r15, r1);
						echo_string(r15, '], ');
					} else {
						#ifndef i386;
						r3 = CHAR_d;
						#else;
						r3 = CHAR_SPACE;
						#endif;
						if(r5 == r3){
							echo_string(r15, '\tmov dword [');
							echo_string(r15, r1);
							echo_string(r15, '], ');
						} else {
							echo_string(r15, '\tmov qword [');
							echo_string(r15, r1);
							echo_string(r15, '], ');
						}
					}
				}
				//token = v_target;
				r13 = v_target;
				token = r13;
				r2 = [r14+r13*8];
				r1 = TOKEN_NUM_INTEGER;
				//if (token_stack[token] < TOKEN_OFFSET) {
					// We have an immediate load.
					//outputNumber(i, NUM_INTEGER);
					//fprintf(code, "\n");
					//atStackEnd(i);
				//} else {
					// We should have a register
					//TokenIsLabelType(TYPE_REG);
					//fprintf(code, "%s%c\n", hash_table[token_stack[token]-HASH_OFFSET].token, state);
					//token++;
					//atStackEnd(i);
				//}
				if(r2 == r1){
					outputNumber(r12, NUM_INTEGER, r15);
					echo_cr(r15);
					atStackEnd(r12);
				} else {
					TokenIsLabelType(TYPE_REG);
					r2 = r2 - HASH_OFFSET;
					r1 = &hash_table[r2].token;
					echo_string(r15, r1);
					echo_character(r15, r5);
					echo_cr(r15);
					r13 = token;
					r13 = r13 + 1;
					token = r13;
					atStackEnd(r12);
				}
				//fprintf(code, "\tpop %s\n", hash_table[v_reg].token);
				r1 = v_reg;
				r2 = &hash_table[r1].token;
				echo_string(r15, '\tpop ');
				echo_string(r15, r2);
				echo_cr(r15);
				
			//} else {
			} else {
				// Non-structure definition, so this should be quick.
				
				//switch(state){
				//	case 'b' : fprintf(code, "\tmov byte "); break;
					//case 'w' : fprintf(code, "\tmov word "); break;
					//#ifndef i386
					//case 'd' : fprintf(code, "\tmov dword "); break;
					//default  : fprintf(code, "\tmov qword "); break;
					//#else
					//default  : fprintf(code, "\tmov dword "); break;
					//#endif
				//}
				r5 = state;
				r3 = CHAR_b; //b
				if (r5 == r3){
					echo_string(r15, '\tmov byte ');
				} else {
					r3 = CHAR_w; // w
					if(r5 == r3){
						echo_string(r15, '\tmov word ');
					} else {
						#ifndef i386;
						r3 = CHAR_d;
						#else;
						r3 = CHAR_SPACE;
						#endif;
						if(r5 == r3){
							echo_string(r15, '\tmov dword ');
						} else {
							echo_string(r15, '\tmov qword ');
						}
					}
				}				
				//Calculate_NSLabel_address(i);
				Calculate_NSLabel_address(r12);
				
				//fprintf(code, ", ");
				echo_string(r15, ', ');
				
				//token = v_target;
				r13 = v_target;
				token = r13;
				r2 = [r14+r13*8];
				r1 = TOKEN_NUM_INTEGER;
				//if (token_stack[token] < TOKEN_OFFSET) {
					// We have an immediate load.
					//outputNumber(i, NUM_INTEGER);
					//fprintf(code, "\n");
					//atStackEnd(i);
				//} else {
					// We should have a register
					//TokenIsLabelType(TYPE_REG);
					//fprintf(code, "%s%c\n", hash_table[token_stack[token]-HASH_OFFSET].token, state);
					//token++;
					//atStackEnd(i);
				//}
				if(r2 == r1){
					outputNumber(r12, NUM_INTEGER, r15);
					echo_cr(r15);
					atStackEnd(r12);
				} else {
					TokenIsLabelType(TYPE_REG);
					r2 = r2 - HASH_OFFSET;
					r1 = &hash_table[r2].token;
					echo_string(r15, r1);
					echo_character(r15, r5);
					echo_cr(r15);
					r13 = token;
					r13 = r13 + 1;
					token = r13;
					atStackEnd(r12);
				}
			//}
			}
			//token = i;
			r13 = r12;
			token = r13;
		//} else {
		} else {
			r1 = TYPE_REG;
			//if (hash_table[token_stack[token]-HASH_OFFSET].token_type == TYPE_REG) {
			if(r3 == r1){
				//if(DEBUG)
					//printf("Processing line with register destination\n");
				if(r11) { 
					echo_string(STDOUT, 'Processing line with register destination\n');
				}
				//target = token_stack[token]-HASH_OFFSET; //Store hash of target.
				r2 = [r14+r13*8];
				r2 = r2 - HASH_OFFSET;
				target = r2;
				//token++;
				r13 = r13 + 1;
				token = r13;
				//TokenIs(TOKEN_EQUATE);
				TokenIs(TOKEN_EQUATE);
				//token++; // Let's skip ahead for a second.
				r13 = token;
				r13 = r13 + 1;
				token = r13;
				r4 = 0;
				r2 = [r14+r13*8];
				r3 = TOKEN_STRING;
				if (r2 == r3){
					r4 = 1;
				}
				r3 = TOKEN_POINTER;
				if(r2 == r3){
					r4 = 1;
				}
				if(r4){
				//if ((token_stack[token] == TOKEN_POINTER)||(token_stack[token] == TOKEN_STRING)) {
					// We are dealing with a pointer to either a string or label
					//if (token_stack[token] == TOKEN_POINTER) token++;
					if(r2 == r3){
						r13 = r13 + 1;
						token = r13;
						r2 = [r14+r13*8];
					}
					// Advance if token is a pointer, otherwise just wait.
					r3 = TOKEN_ARRAY_START;
					//if (token_stack[token] == TOKEN_ARRAY_START) {
					if(r2 == r3){
						//fprintf(code, "\tlea %s, [", hash_table[target].token);
						echo_string(r15, '\tlea ');
						r0 = target;
						r0 = &hash_table[r0].token;
						echo_string(r15, r0);
						echo_string(r15, ', [');
						//token++;	//Increase token pointer;
						r13 = token;
						r13 = r13 + 1;
						token = r13;
						//Global_Pointer(i);
						Global_Pointer(r12);
						//TokenIs(TOKEN_ARRAY_END);
						TokenIs(TOKEN_ARRAY_END);
						//fprintf(code, "]\n");
						echo_string(r15, ']\n');
						//token++;
						r13 = token;
						r13 = r13 + 1;
						token = r13;
						//atStackEnd(i);
						atStackEnd(r12);
					} else {
						r3 = TOKEN_STRING;
						//if (token_stack[token] == TOKEN_STRING) {
						if(r2 == r3){
							//outputDynamicString(i);
							//atStackEnd(i);
							outputDynamicString(r12);
							atStackEnd(r12);
						//} else {
						} else {
							// We are dealing with a label, but lets first check
							//isHash(token_stack[token]);
							isHash(r2);
							r3 = r2 - HASH_OFFSET;
							r3 = hash_table[r3].token_type;
							r4 = 0;
							if (r3 == r4){
								r4 = 1;
							}
							r1 = TYPE_PROC;
							if(r3 == r1){ r4 = 1; }
							r1 = TYPE_EPROC;
							if(r3 == r1){ r4 = 1; }
							if(r4){
							//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type == TYPE_PROC)||
								//(hash_table[token_stack[token]-HASH_OFFSET].token_type == TYPE_EPROC)||
								//(hash_table[token_stack[token]-HASH_OFFSET].token_type == 0)){
								//Process pointer to PROC!
								//if (hash_table[token_stack[token]-HASH_OFFSET].token_type == TYPE_EPROC) {
								if (r3 == r1){
									//fprintf(code, "\tmov %s, %s\n", hash_table[target].token, hash_table[token_stack[token]-HASH_OFFSET].token);
									r1 = target;
									r1 = &hash_table[r1].token;
									r3 = r2 - HASH_OFFSET;
									r3 = &hash_table[r3].token;
									echo_string(r15, '\tmov ');
									echo_string(r15, r1);
									echo_string(r15, ', ');
									echo_string(r15, r3);
									echo_cr(r15);
								//} else {
								} else {
									//fprintf(code, "\tmov %s, _B0_%s\n", hash_table[target].token, hash_table[token_stack[token]-HASH_OFFSET].token);								
									r1 = target;
									r1 = &hash_table[r1].token;
									r3 = r2 - HASH_OFFSET;
									r3 = &hash_table[r3].token;
									echo_string(r15, '\tmov ');
									echo_string(r15, r1);
									echo_string(r15, ', _B0_');
									echo_string(r15, r3);
									echo_cr(r15);
								//};
								}
								//token++;
								r13 = token;
								r13 = r13 + 1;
								token = r13;
								//TokenIs(TOKEN_PARA_START);
								TokenIs(TOKEN_PARA_START);
								//token++; // Let's skip ahead for a second.
								r13 = token;
								r13 = r13 + 1;
								token = r13;
								//TokenIs(TOKEN_PARA_END);
								TokenIs(TOKEN_PARA_END);
								//token++;
								r13 = token;
								r13 = r13 + 1;
								token = r13;
								//atStackEnd(i);
								atStackEnd(r12);
							//} else {
							} else {
								//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & 0xf) == 0) abort_b0("Expected Data Label");
								r3 = r3 && 0fh;
								r0 = 0;
								if(r3 == r0){
									abort_b0('Expected Data Label');
								}
								// We definitely have a label.
								//BuildLabelInfo(i);
								BuildLabelInfo(r12);
								// we use target here instead of v_target!
								//v_target = 0;
								v_target = 0;
								//if(DEBUG){
									//DisplayLabelInfo();	
								//}
								if(r11){
									DisplayLabelInfo();	
								}
								//atStackEnd(i);
								atStackEnd(r12);
								r0 = 1;
								r1 = v_isStruc;
								if(r1 == r0){
								//if (v_isStruc == 1) {
									// What we do, is calculate the offset for any struc operation, and then do a
									// mov target, r6|r14|r15 operation.
	
									//Set_v_reg();	//v_reg is the register we are going to use.
									Set_v_reg();
	
									//fprintf(code, "\tpush %s\n", hash_table[v_reg].token);
									r1 = v_reg;
									r2 = &hash_table[r1].token;
									echo_string(r15, '\tpush ');
									echo_string(r15, r2);
									echo_cr(r15);
					
									//Calculate_label_address(i);
									Calculate_label_address(r12);
									
									//fprintf (code, "\tmov %s, %s\n\tpop %s\n", hash_table[target].token, hash_table[v_reg].token, hash_table[v_reg].token);
									r1 = target;
									r1 = &hash_table[r1].token;
									echo_string(r15, '\tmov ');
									echo_string(r15, r1);
									echo_string(r15, ', ');
									echo_string(r15, r2);
									echo_string(r15, '\n\tpop ');
									echo_string(r15, r2);
									echo_cr(r15);
									
								//} else {
								} else {
									// We have a standard variable.
									r5 = state;
									//if(state != '8') //We handle f80 and xmm differently
										//fprintf(code, "\tlea %s, ", hash_table[target].token);
									
									r1 = 1;
									r0 = CHAR_8; if(r5 == r0) { r1 = r1 ^ r1; };
									r0 = CHAR_U; if(r5 == r0) { r1 = r1 ^ r1; };
									r0 = CHAR_V; if(r5 == r0) { r1 = r1 ^ r1; };
									r0 = CHAR_W; if(r5 == r0) { r1 = r1 ^ r1; };
									state = r5;
									if(r1){
										r1 = target;
										r1 = &hash_table[r1].token;
										echo_string(r15, '\tlea ');
										echo_string(r15, r1);
										echo_string(r15, ', ');
									}
									//Calculate_NSLabel_address(i);
									Calculate_NSLabel_address(r12);
									//fprintf(code, "\n");
									echo_cr(r15);
								//}
								}
							//}
							}
						//}
						}
					}
				//} else {
				} else {
					// We have a reg, label, immediate, or proc. (pointers have already been dealth with).
					r4 = 0;
					r3 = TOKEN_NUM_INTEGER;
					if (r2 == r3) { r4 = 1; }
					r3 = TOKEN_MINUS;
					if(r2 == r3) { r4 = 1; }
					if (r4){
					//if ((token_stack[token] < TOKEN_OFFSET) || (token_stack[token] == TOKEN_MINUS)) {
						// We have an immediate load
						//fprintf(code, "\tmov %s, ", hash_table[target].token);
						r5 = target;
						r5 = &hash_table[r5].token;
						echo_string(r15, '\tmov ');
						echo_string(r15, r5);
						echo_string(r15, ', ');
						//if (token_stack[token] == TOKEN_MINUS) {
							//token++;
							//fprintf(code, "-");
						//}
						if(r2 == r3){
							r13 = token;
							r13 = r13 + 1;
							token = r13;
							echo_string(r15, '-');
						}
						//outputNumber(i, NUM_INTEGER);
						outputNumber(r12, NUM_INTEGER, r15);
						//fprintf(code, "\n");
						echo_cr(r15);
						//atStackEnd(i);
						atStackEnd(r12);
					//} else {
					} else {
						// We have a reg, label or proc
						r3 = TOKEN_ARRAY_START;
						//if (token_stack[token] == TOKEN_ARRAY_START) {
						if(r2 == r3){
							// We have a global load into a register
							r4 = target;
							r4 = &hash_table[r4].token;
							//fprintf(code, "\tmov %s, [", hash_table[target].token);
							echo_string(r15, '\tmov ');
							echo_string(r15, r4);
							echo_string(r15, ', [');
							//token++;
							r13 = token;
							r13 = r13 + 1;
							token = r13;
							//Global_Pointer(i);
							Global_Pointer(r12);
							//TokenIs(TOKEN_ARRAY_END);
							TokenIs(TOKEN_ARRAY_END);
							//fprintf(code, "]\n");
							echo_string(r15, ']\n');
							//token++;
							r13 = token;
							r13 = r13 + 1;
							token = r13;
							//atStackEnd(i);
							atStackEnd(r12);
						
						//} else {
						} else {
							// We have a reg, label or proc
							// At this stage, the next token should be a reg, label or proc.
							// Anything else is incorrect!
							//isHash(token_stack[token]);
							isHash(r2);
							//if (hash_table[token_stack[token]-HASH_OFFSET].token_type == TYPE_KEYWORD)
								//abort_b0("Unexpected Keyword");
							r3 = r2 - HASH_OFFSET;
							r3 = hash_table[r3].token_type;
							r4 = TYPE_KEYWORD;
							if(r3 == r4){
								abort_b0('Unexpected Keyword');
							}
							// The only thing we should be left with are the regs, labels or procs!
							//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & 0xf) > 0) {
							r4 = r3 && 0fh;
							if(r4){
								// We have a label
								//if(DEBUG)
									//printf("Processing line with register destination with label source\n");
								if(r11){
										echo_string(STDOUT, 'Processing line with register destination with label source\n');
								}
								//BuildLabelInfo(i);
								BuildLabelInfo(r12);
								// we use target here instead of v_target!
								//v_target = 0;
								v_target = 0;
								//if(DEBUG){
									//DisplayLabelInfo();	
								//}
								if(r11){
									DisplayLabelInfo();
								}
								//atStackEnd(i);
								atStackEnd(r12);
								//state will hold the size of the transfer..., On m64 state = '', as this is the default size. No override needed.
								//if ((state == '3') || (state == '6') || (state == '8'))
									//abort_b0("Unable to load integer register with floating point variable");
								r0 = state;
								r1 = CHAR_W;
								if(r0 <= r1){
									r1 = CHAR_SPACE;
									if(r0 != r1){
										abort_b0('Unable to load integer register with floating point or vector variable');
									}
								}
								r0 = v_isStruc;
								r1 = 1;
								//if (v_isStruc == 1) {
								if(r0 == r1){
									//Let's handle the structure def intelligently, (what I'm doing below isn't intelligent).
									// What we do, is calculate the offset for any struc operation, and then do a
									// mov [r6|r14|r15], reg|immediate operation.
								
									//Set_v_reg();	//v_reg is the register we are going to use.
									Set_v_reg();
//
									//fprintf(code, "\tpush %s\n", hash_table[v_reg].token);
									r0 = v_reg;
									r1 = &hash_table[r0].token;
									echo_string(r15, '\tpush ');
									echo_string(r15, r1);
									echo_cr(r15);
									
				
									//Calculate_label_address(i);
									Calculate_label_address(r12);
									
									r0 = target;
									r1 = &hash_table[r0].token;
									r0 = v_reg;
									r2 = &hash_table[r0].token;
									r3 = state;
									r4 = CHAR_b;
									//Now we are ready to store the value...
									//switch(state){
										//case 'b' : fprintf(code, "\tmovzx %s, byte [%s]\n", hash_table[target].token, hash_table[v_reg].token); break;
										//case 'w' : fprintf(code, "\tmovzx %s, word [%s]\n", hash_table[target].token, hash_table[v_reg].token); break;
										//#ifndef i386
										//case 'd' : fprintf(code, "\tmov %sd, dword [%s]\n", hash_table[target].token, hash_table[v_reg].token); break;
										//default  : fprintf(code, "\tmov %s, qword [%s]\n", hash_table[target].token, hash_table[v_reg].token); break;
										//#else
										//default  : fprintf(code, "\tmov %s, dword [%s]\n", hash_table[target].token, hash_table[v_reg].token); break;
										//#endif
									//}
									if(r3 == r4){
										echo_string(r15, '\tmovzx ');
										echo_string(r15, r1);
										echo_string(r15, ', byte [');
										echo_string(r15, r2);
										echo_string(r15, ']\n');
									} else {
										r4 = CHAR_w;
										if(r3 == r4){
											echo_string(r15, '\tmovzx ');
											echo_string(r15, r1);
											echo_string(r15, ', word [');
											echo_string(r15, r2);
											echo_string(r15, ']\n');
										} else {
											#ifndef i386;
											r4 = CHAR_d;
											#else;
											r4 = CHAR_SPACE;
											#endif;
											if(r3 == r4){
												echo_string(r15, '\tmov ');
												echo_string(r15, r1);
												echo_string(r15, 'd, dword [');
												echo_string(r15, r2);
												echo_string(r15, ']\n');												
											} else {
												echo_string(r15, '\tmov ');
												echo_string(r15, r1);
												echo_string(r15, ', qword [');
												echo_string(r15, r2);
												echo_string(r15, ']\n');												
											}
										}
									}
									//token = v_target;
									r13 = v_target;
									token = r13;
									//fprintf(code, "\tpop %s\n", hash_table[v_reg].token);
									r0 = v_reg;
									r1 = &hash_table[r0].token;
									echo_string(r15, '\tpop ');
									echo_string(r15, r1);
									echo_cr(r15);
									
								//} else {
								} else {
									// Non-structure definition, so this should be quick.
									//switch(state){
										//case 'b' : fprintf(code, "\tmovzx %s, byte ", hash_table[target].token); break;
										//case 'w' : fprintf(code, "\tmovzx %s, word ", hash_table[target].token); break;
										//#ifndef i386
										//case 'd' : fprintf(code, "\tmov %sd, dword ", hash_table[target].token); break;
										//default  : fprintf(code, "\tmov %s, qword ", hash_table[target].token); break;
										//#else
										//default  : fprintf(code, "\tmov %s, dword ", hash_table[target].token); break;
										//#endif
									//}
									r0 = target;
									r1 = &hash_table[r0].token;
									r3 = state;
									r4 = CHAR_b;
									if(r3 == r4){
										echo_string(r15, '\tmovzx ');
										echo_string(r15, r1);
										echo_string(r15, ', byte ');
									} else {
										r4 = CHAR_w;
										if(r3 == r4){
											echo_string(r15, '\tmovzx ');
											echo_string(r15, r1);
											echo_string(r15, ', word ');
										} else {
											#ifndef i386;
											r4 = CHAR_d;
											#else;
											r4 = CHAR_SPACE;
											#endif;
											if(r3 == r4){
												echo_string(r15, '\tmov ');
												echo_string(r15, r1);
												echo_string(r15, 'd, dword ');
											} else {
												echo_string(r15, '\tmov ');
												echo_string(r15, r1);
												echo_string(r15, ', qword ');
											}
										}
									}
									
									//Calculate_NSLabel_address(i);
									Calculate_NSLabel_address(r12);
									
									//fprintf(code, "\n");
									echo_cr(r15);
								//}
								}
							//} else {
							} else {
								//if (hash_table[token_stack[token]-HASH_OFFSET].token_type == TYPE_REG) {
								r4 = TYPE_REG;
								if(r3 == r4){
									// We have a register!
									//token++;	// Step forward 1
									r13 = token;
									r13 = r13 + 1;
									token = r13;
									//if (token != i) {
									if(r13 != r12){
										//if ((token_stack[token] != TOKEN_MULTIPLY) &&
											//(token_stack[token] != TOKEN_DIVIDE) &&
											//(token_stack[token] != TOKEN_MODULUS) &&
											//(token_stack[token] != TOKEN_S_MULTIPLY) &&
											//(token_stack[token] != TOKEN_S_DIVIDE) &&
											//(token_stack[token] != TOKEN_S_MODULUS)) {
												//if (target != (token_stack[token-1]-HASH_OFFSET))
													// Only output if target and first operand are different.
													//fprintf(code, "\tmov %s, %s\n", hash_table[target].token, hash_table[token_stack[token-1]-HASH_OFFSET].token);
											//};
										r13 = token;
										r2 = [r14+r13*8];
										r1 = r2 - TOKEN_MULTIPLY;
										r3 = 5h;
										if(r1 > r3){
											r2 = r13 - 1;
											r2 = [r14+r2*8];
											r2 = r2 - HASH_OFFSET;
											r1 = target;
											if(r1!= r2){
												r1 = &hash_table[r1].token;
												r2 = &hash_table[r2].token;
												echo_string(r15, '\tmov ');
												echo_string(r15, r1);
												echo_string(r15, ', ');
												echo_string(r15, r2);
												echo_cr(r15);
											}
										}
										//state = token_stack[token];
										r3 = [r14+r13*8];
										state = r3;
										r4 = TOKEN_AND;
										r1 = target;
										r1 = &hash_table[r1].token;
										//switch(state) {
											//case TOKEN_AND:  // If our operation is a basic AND
												//fprintf(code, "\tand %s, ", hash_table[target].token);
												//break;
										if(r3 == r4){
											echo_string(r15, '\tand ');
											echo_string(r15, r1);
											echo_string(r15, ', ');
										} else {
											//case TOKEN_OR:
												//fprintf(code, "\tor %s, ", hash_table[target].token);
												//break;
											r4 = TOKEN_OR;
											if(r3 == r4){
												echo_string(r15, '\tor ');
												echo_string(r15, r1);
												echo_string(r15, ', ');
											} else{												
											//case TOKEN_XOR:
												//fprintf(code, "\txor %s, ", hash_table[target].token);
												//break;
												r4 = TOKEN_XOR;
												if(r3 == r4){
													echo_string(r15, '\txor ');
													echo_string(r15, r1);
													echo_string(r15, ', ');
												} else{												
												
											//case TOKEN_ADD:
												//fprintf(code, "\tadd %s, ", hash_table[target].token);
												//break;
													r4 = TOKEN_ADD;
													if(r3 == r4){
														echo_string(r15, '\tadd ');
														echo_string(r15, r1);
														echo_string(r15, ', ');
													} else{												
												
											//case TOKEN_MINUS:
												//fprintf(code, "\tsub %s, ", hash_table[target].token);
												//break;
														r4 = TOKEN_MINUS;
														if(r3 == r4){
															echo_string(r15, '\tsub ');
															echo_string(r15, r1);
															echo_string(r15, ', ');
														} else{												
												
											//case TOKEN_RSHIFT:
												//fprintf(code, "\tshr %s, ", hash_table[target].token);
												//break;
															r4 = TOKEN_RSHIFT;
															if(r3 == r4){
																echo_string(r15, '\tshr ');
																echo_string(r15, r1);
																echo_string(r15, ', ');
															} else{												
												
											//case TOKEN_LSHIFT:
												//fprintf(code, "\tshl %s, ", hash_table[target].token);
												//break;
															r4 = TOKEN_LSHIFT;
															if(r3 == r4){
																echo_string(r15, '\tshl ');
																echo_string(r15, r1);
																echo_string(r15, ', ');
															} else{												

											//case TOKEN_RROTATE:
												//fprintf(code, "\tror %s, ", hash_table[target].token);
												//break;
															r4 = TOKEN_RROTATE;
															if(r3 == r4){
																echo_string(r15, '\tror ');
																echo_string(r15, r1);
																echo_string(r15, ', ');
															} else{												
												
											//case TOKEN_LROTATE:
												//fprintf(code, "\trol %s, ", hash_table[target].token);
												//break;
															r4 = TOKEN_LROTATE;
															if(r3 == r4){
																echo_string(r15, '\trol ');
																echo_string(r15, r1);
																echo_string(r15, ', ');
															} else{												

											//case TOKEN_MULTIPLY:
												//if ((token_stack[token-1]-HASH_OFFSET) != HASH_r0)
													//abort_b0("Multiply Operations REQUIRE r0 as source");
												//fprintf(code, "\tmul ");
												//break;
															r2 = r13 - 1;
															r1 = [r14+r2*8];
															r1 = r1 - HASH_OFFSET;
															r2 = HASH_r0;
															r4 = TOKEN_MULTIPLY;
															if(r3 == r4){
																if(r1!=r2){
																	abort_b0('Multiply Operations REQUIRE r0 as source');
																}
																echo_string(r15, '\tmul ');
															} else {

											//case TOKEN_DIVIDE:
												//if ((token_stack[token-1]-HASH_OFFSET) != HASH_r0)
													//abort_b0("Division Operations REQUIRE r0 as source");
												//fprintf(code, "\tdiv ");
												//break;
															r4 = TOKEN_DIVIDE;
															if(r3 == r4){
																if(r1!=r2){
																	abort_b0('Division Operations REQUIRE r0 as source');
																}
																echo_string(r15, '\tdiv ');
															} else {
												
											//case TOKEN_MODULUS:
												//if ((token_stack[token-1]-HASH_OFFSET) != HASH_r0)
													//abort_b0("Modulus Operations REQUIRE r0 as source");
												//fprintf(code, "\tdiv ");
												//break;
															r4 = TOKEN_MODULUS;
															if(r3 == r4){
																if(r1!=r2){
																	abort_b0('Modulus Operations REQUIRE r0 as source');
																}
																echo_string(r15, '\tdiv ');
															} else {
												
											//case TOKEN_S_MULTIPLY:
												//if ((token_stack[token-1]-HASH_OFFSET) != HASH_r0)
													//abort_b0("Signed Multiply Operations REQUIRE r0 as source");
												//fprintf(code, "\timul ");
												//break;
															r4 = TOKEN_S_MULTIPLY;
															if(r3 == r4){
																if(r1!=r2){
																	abort_b0('Signed Multiply Operations REQUIRE r0 as source');
																}
																echo_string(r15, '\timul ');
															} else {
											
											//case TOKEN_S_DIVIDE:
												//if ((token_stack[token-1]-HASH_OFFSET) != HASH_r0)
													//abort_b0("Signed Division Operations REQUIRE r0 as source");
												//fprintf(code, "\tidiv ");
												//break;
															r4 = TOKEN_S_DIVIDE;
															if(r3 == r4){
																if(r1!=r2){
																	abort_b0('Signed Division Operations REQUIRE r0 as source');
																}
																echo_string(r15, '\tidiv ');
															} else {
												
											//case TOKEN_S_MODULUS:
												//if ((token_stack[token-1]-HASH_OFFSET) != HASH_r0)
													//abort_b0("Signed Modulus Operations REQUIRE r0 as source");
												//fprintf(code, "\tidiv ");
												//break;
															r4 = TOKEN_S_MODULUS;
															if(r3 == r4){
																if(r1!=r2){
																	abort_b0('Signed Modulus Operations REQUIRE r0 as source');
																}
																echo_string(r15, '\tidiv ');
															} else {

											//default:
												//abort_b0("Invalid Construct");
												//break;
																abort_b0('Invalid Construct');
															}
										}}}}}}}}}}}}}}
										//}
										// We have constructed our operand
										//token++;
										r13 = token;
										r13 = r13 + 1;
										token = r13;
										// Now lets see what the second operand is...
										r1 = [r14+r13*8];
										r4 = 0;
										r2 = TOKEN_NUM_INTEGER;
										if(r1 == r2){ r4 = 1; }
										r2 = TOKEN_MINUS;
										if(r1 == r2) { r4 = 1; }
										if(r4){
										//if ((token_stack[token] < TOKEN_OFFSET) || (token_stack[token] == TOKEN_MINUS)) {
											// Looks like an immediate
											//if ((state == TOKEN_MULTIPLY) ||
												//(state == TOKEN_DIVIDE) ||
												//(state == TOKEN_MODULUS) ||
												//(state == TOKEN_S_MULTIPLY) ||
												//(state == TOKEN_S_DIVIDE) ||
												//(state == TOKEN_S_MODULUS)) {
													// Mul, and div require a register!
													//abort_b0("Unexpected immediate value");
												//}
												r2 = r3; // r3 is our state;
												r2 = r2 - TOKEN_MULTIPLY;
												r4 = 5h;
												if(r2 <= r4){
													abort_b0('Unexpected immediate value');
												}
											// We have an immediate load
											r4 = TOKEN_MINUS;
											if(r1 == r4){
											//if (token_stack[token] == TOKEN_MINUS) {
												//if ((state == TOKEN_RSHIFT) ||
													//(state == TOKEN_LSHIFT) ||
													////(state == TOKEN_RROTATE) ||
													//(state == TOKEN_LROTATE)) {
														// Shifts MUST have a positive!
														//abort_b0("Shift/Rotate operations require a POSITIVE shift value");
												//}
												r2 = r3; // r3 is our state;
												r2 = r2 - TOKEN_RROTATE;
												r4 = 3h;
												if(r2 <= r4){
													abort_b0('Shift/Rotate operations require a POSITIVE shift value');
												}
												//token++;
												r13 = token;
												r13 = r13 + 1;
												token = r13;
												//fprintf(code, "-");
												echo_string(r15, '-');
											//}
											}
											TokenIs(TOKEN_NUM_INTEGER);
											r1 = [r14+r13*8+8];
											r2 = 0ffffffffh;
											if(r1 > r2){
												abort_b0('Immediate value larger than 32bits');
											}
											//outputNumber(i, NUM_INTEGER);
											outputNumber(r12, NUM_INTEGER, r15);
											//fprintf(code, "\n");
											echo_cr(r15);
										//} else {
										} else {
											// Must be a REG, so lets get rid of the rest;
											//if (token_stack[token] < HASH_OFFSET)
												//abort_b0("Expected Token/Label");
											r4 = HASH_OFFSET;
											if(r1 < r4){
												abort_b0('Expected Token/Label');
											}
											
											// Lets see if we have a shift operation, and handle appropriately.
											//if ((state == TOKEN_RSHIFT) || (state == TOKEN_LSHIFT) ||
												//(state == TOKEN_RROTATE) || (state == TOKEN_LROTATE)){
											r3 = state;
											r2 = r3 - TOKEN_RROTATE;
											r4 = 3h;
											if(r2 <= r4){
												//if (((token_stack[token]-HASH_OFFSET) != HASH_r2) &&
													//((token_stack[token]-HASH_OFFSET) != HASH_r2b))
													//abort_b0("Shift/Rotate Operations REQUIRE r2 / r2b or Immediate as second operand");
												r13 = token;
												r5 = [r14+r13*8];
												r5 = r5 - HASH_OFFSET;
												r4 = HASH_r2;
												if(r5 != r4){
													r4 = HASH_r2b;
													if(r5 != r4){
														abort_b0('Shift/Rotate Operations REQUIRE r2 / r2b or Immediate as second operand');
													}
												}
												//fprintf(code, "r2b\n");
												echo_string(r15, 'r2b\n');
											//} else {
											} else {
												//TokenIsLabelType(TYPE_REG);
												TokenIsLabelType(TYPE_REG);
												// Everything must be okay, so lets output our second operand.
												//fprintf(code, "%s\n", hash_table[token_stack[token]-HASH_OFFSET].token);
												r13 = token;
												r5 = [r14+r13*8];
												r5 = r5 - HASH_OFFSET;
												r5 = &hash_table[r5].token;
												echo_string(r15, r5);
												echo_cr(r15);
											//}
											}
											// Load the destination register if required!
											//switch(state) {
												//case TOKEN_MULTIPLY:
												//case TOKEN_DIVIDE:
												//case TOKEN_S_MULTIPLY:
												//case TOKEN_S_DIVIDE:
													//if (target != HASH_r0)
														//fprintf(code, "\tmov %s, r0\n", hash_table[target].token);
													//break;
												//case TOKEN_MODULUS:
												//case TOKEN_S_MODULUS:
													//if (target != HASH_r3)
														//fprintf(code, "\tmov %s, r3\n", hash_table[target].token);
													//break;
											//}
											r3 = state;
											r4 = TOKEN_MULTIPLY;
											r1 = target;
											r2 = HASH_r0;
											r5 = &hash_table[r1].token;
											if(r3 == r4){
												if(r1!=r2){
													echo_string(r15, '\tmov ');
													echo_string(r15, r5);
													echo_string(r15, ', r0\n');
												}
											} else {
												r4 = TOKEN_DIVIDE;
												if(r3 == r4){
													if(r1!=r2){
														echo_string(r15, '\tmov ');
														echo_string(r15, r5);
														echo_string(r15, ', r0\n');
													}
												} else {
													r4 = TOKEN_S_DIVIDE;
													if(r3 == r4){
														if(r1!=r2){
															echo_string(r15, '\tmov ');
															echo_string(r15, r5);
															echo_string(r15, ', r0\n');
														}
													} else {
														r4 = TOKEN_S_MULTIPLY;
														if(r3 == r4){
															if(r1!=r2){
																echo_string(r15, '\tmov ');
																echo_string(r15, r5);
																echo_string(r15, ', r0\n');
															}
														} else {
															r4 = TOKEN_MODULUS;
															r2 = HASH_r3;
															if(r3 == r4){
																if(r1!=r2){
																	echo_string(r15, '\tmov ');
																	echo_string(r15, r5);
																	echo_string(r15, ', r3\n');
																}
															} else {
																r4 = TOKEN_S_MODULUS;
																if(r3 == r4){
																	if(r1!=r2){
																		echo_string(r15, '\tmov ');
																		echo_string(r15, r5);
																		echo_string(r15, ', r3\n');
																	}
																}
															}
														}
													}
												}
											}
											//token++;
											r13 = token;
											r13 = r13 + 1;
											token = r13;
										//}
										}
										//atStackEnd(i);
										atStackEnd(r12);
									//} else {
									} else {
										// We have a single register load!
										r2 = token;
										r2 = r2 - 1;
										r3 = [r14+r2*8];
										r3 = r3 - HASH_OFFSET;
										r2 = target;
										//if (target != (token_stack[token-1]-HASH_OFFSET))
											// Don't output code, if r0 = r0; type is present.
											//fprintf(code, "\tmov %s, %s\n", hash_table[target].token, hash_table[token_stack[token-1]-HASH_OFFSET].token);
										if(r2 != r3){
											r2 = &hash_table[r2].token;
											r3 = &hash_table[r3].token;
											echo_string(r15, '\tmov ');
											echo_string(r15, r2);
											echo_string(r15, ', ');
											echo_string(r15, r3);
											echo_cr(r15);
										}
									//}
									}
								//} else {
								} else {
									// We must have a proc!
									//callProc((token_stack[token])-HASH_OFFSET, target, i);
									r13 = token;
									r2 = [r14+r13*8];
									r2 = r2 - HASH_OFFSET;
									r1 = target;
									callProc(r2, r1, r12);
								//}
								}
							//}
							}
						//}
						}
					//}
					}
				//}
				}
			//} else {
			} else {
				//if (hash_table[token_stack[token]-HASH_OFFSET].token_type == TYPE_REG_SHORT) {
				r4 = TYPE_REG_SHORT;
				if(r3 == r4){
					// Look like we have a short reg...
					// This is going to be easy, as short regs can only be used with pointer operations or immediate loads.
					if(r11){
						echo_string(STDOUT, 'Processing small register load operation\n');
					}
					//fprintf(code, "\tmov %s, [", hash_table[token_stack[token]-HASH_OFFSET].token);
					r13 = token;
					r2 = [r14+r13*8];
					r2 = r2 - HASH_OFFSET;
					r2 = &hash_table[r2].token;
					echo_string(r15, '\tmov ');
					echo_string(r15, r2);
					echo_string(r15, ', ');
					//token++;
					r13 = r13 + 1;
					token = r13;
					//TokenIs(TOKEN_EQUATE);
					TokenIs(TOKEN_EQUATE);
					//token++;
					r13 = r13 + 1;
					token = r13;
					r5 = [r14+r13*8];
					r4 = TOKEN_ARRAY_START;
					if (r4 != r5) {
						//Process immediate load
						r4 = TOKEN_MINUS;
						if (r4 != r5){
							r4 = TOKEN_NUM_INTEGER;
							if (r4 != r5){
								abort_b0('Expected Immediate Integer or Pointer');
							}
						}
						r4 = TOKEN_MINUS;
						if (r5 == r4){
							echo_string(r15, '-');
							r13 = r13 + 1;
							token = r13;
						}
						r5 = [r14+r13*8];
						r4 = TOKEN_NUM_INTEGER;
						if (r4 != r5){
							abort_b0('Expected Immediate Integer');
						}
						r13 = r13 + 1;
						token = r13;
						r5 = [r14+r13*8];
						// r5 = our integer;
						echo_integer(r15, r5);
						echo_string(r15, '\n');
						r13 = r12;
						token = r13;							
					} else {			
						// Process pointer operation		
						echo_string(r15, '[');
						//TokenIs(TOKEN_ARRAY_START);
						TokenIs(TOKEN_ARRAY_START);
						//token++;
						r13 = r13 + 1;
						token = r13;
						//Global_Pointer(i);
						Global_Pointer(r12);
						//TokenIs(TOKEN_ARRAY_END);
						TokenIs(TOKEN_ARRAY_END);
						//fprintf(code, "]\n");
						echo_string(r15, ']\n');
						//token++;
						r13 = r12;
						token = r13;
					}
				//} else {
				} else {
					// Whatever we have left treat as proc.
					//callProc(token_stack[token]-HASH_OFFSET, HASH_r0, i);
					r13 = token;
					r2 = [r14+r13*8];
					r2 = r2 - HASH_OFFSET;
					callProc(r2, HASH_r0, r12);
				//}
				}
			//}
			}
		//}
		}
	}
	//return(0);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
}

proc process_fpu_operation(i) {
	v_base = 0;
	v_isStruc = 0;
	v_offset = 0;
	v_offset_type = 0;
	v_size = 0;
	v_index = 0;
	v_target = 0;
	v_global = 0;
	v_reg = 0;
	
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12, r13, r14, r15;
	r15 = code;
	r14 = &token_stack;
	r13 = token;
	r12 = i;
	r11 = DEBUG;
	r1 = [r14+r13*8];
	r2 = TOKEN_ARRAY_START;

	//if ( token_stack[token] == TOKEN_ARRAY_START) {
	if(r1 == r2){
		//Process global memory reference;
		//fprintf(code, "\tfstp tword [");
		echo_string(r15, '\tfstp tword [');
		//token++;	//Increase token pointer;
		r13 = r13 + 1;
		token = r13;
		//Global_Pointer(i);
		Global_Pointer(r12);
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//fprintf(code, "]\n");
		echo_string(r15, ']\n');
		//token++;
		r13 = token;
		r13 = r13 + 1;
		token = r13;
		//TokenIs(TOKEN_EQUATE);
		TokenIs(TOKEN_EQUATE);
		//token++;
		r13 = r13 + 1;
		token = r13;
		r1 = [r14+r13*8];
		r2 = HASH_fp0+HASH_OFFSET;
		//if (token_stack[token] != HASH_fp0+HASH_OFFSET)
			//abort_b0("fp0 Expected");
		if(r1 != r2){
			abort_b0('fp0 Expected');
		}
		//token++;
		r13 = r13 + 1;
		token = r13;
		//atStackEnd(i);
		atStackEnd(r12);
	//} else {
	} else {
		// We can have a label or FPU reg?
		// we must have a register, function, or label
		//if (token_stack[token] == TOKEN_ARRAY_END)
			//abort_b0("Unexpected token ']'");
		r2 = TOKEN_ARRAY_END;
		if(r1 == r2){
			abort_b0('Unexpected token \']\'');
		}
		r2 = r1 - HASH_OFFSET;
		r3 = hash_table[r2].token_type;
		r4 = r3 && 0fh;
		//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & 0xf) > 0) {
		if(r4){
			// We have a label;
			//if(DEBUG)
				//printf("Processing line with variable destination\n");
			if(r11){
				echo_string(STDOUT, 'Processing line with variable destination\n');
			}
			//BuildLabelInfo(i);
			BuildLabelInfo(r12);
			// Quick check to see what our variable is,
			// cannot load with vector type.
			//
			r1 = 0;
			r0 = TYPE_V4I; if(r4 == r0) { r1 = 1; };
			r0 = TYPE_V4F; if(r4 == r0) { r1 = 1; };
			r0 = TYPE_V2F; if(r4 == r0) { r1 = 1; };
			if (r1){
				abort_b0('Unable to store FPU register in vector variable');
			}
			//TokenIs(TOKEN_EQUATE);
			//
			TokenIs(TOKEN_EQUATE);
			//token++;
			r13 = token;
			r13 = r13 + 1;
			token = r13;
			//v_target = token;
			v_target = r13;
			r1 = [r14+r13*8];
			r2 = HASH_fp0+HASH_OFFSET;
			//if (token_stack[token] != HASH_fp0+HASH_OFFSET)
				//abort_b0("fp0 Expected");
			if(r1 != r2){
				abort_b0('fp0 Expected');
			}
			//token++;
			r13 = r13 + 1;
			token = r13;
			//atStackEnd(i);
			atStackEnd(r12);

			// Now we have all our information, so let build the instruction...
			//if(DEBUG){
				//DisplayLabelInfo();	
			//}
			if(r11){
				DisplayLabelInfo();
			}
			
			r5 = 0;
			r2 = v_isStruc;
			r1 = 1;
			r3 = state;
			r4 = 38h; //'8'
			
			//if ((v_isStruc == 1)||(state=='8')) {
			if(r2 == r1){ r5 = 1; }
			if(r3 == r4){ r5 = 1; }
			if(r5){
				// What we do, is calculate the offset for any struc operation, and then do a
				// fstp [r6|r14|r15] operation.

				//Set_v_reg();	//v_reg is the register we are going to use.
				Set_v_reg();

				//fprintf(code, "\tpush %s\n", hash_table[v_reg].token);
				r0 = v_reg;
				r1 = &hash_table[r0].token;
				echo_string(r15, '\tpush ');
				echo_string(r15, r1);
				echo_cr(r15);
				
				//Calculate_label_address(i);
				Calculate_label_address(r12);
				
				//Now we are ready to store the value...
				r0 = state;
				r1 = CHAR_b; // 'b'
				r2 = v_reg;
				r2 = &hash_table[r2].token;
				//switch(state){
				if (r0 == r1){
					//case 'b' : abort_b0("Cannot store FPU into byte");	break;
					abort_b0('Cannot store FPU into byte');
				} else {
					r1 = CHAR_w;
					if (r0 == r1){
						//case 'w' : fprintf(code, "\tfistp word [%s]\n", hash_table[v_reg].token); break;
						echo_string(r15, '\tfistp word [');
						echo_string(r15, r2);
						echo_string(r15, ']\n');
					} else {
						//#ifndef i386
						//case 'd' : fprintf(code, "\tfistp dword [%s]\n", hash_table[v_reg].token); break;
						//case ' ' : fprintf(code, "\tfistp qword [%s]\n", hash_table[v_reg].token); break;
						//#else
						//case ' ' : fprintf(code, "\tfistp dword [%s]\n", hash_table[v_reg].token); break;
						//#endif
						#ifndef i386;
						r1 = CHAR_d; // 'w'
						#else;
						r1 = CHAR_SPACE; // ' '
						#endif;
						if(r0 == r1){
							echo_string(r15, '\tfistp dword [');
							echo_string(r15, r2);
							echo_string(r15, ']\n');
						} else {
							r1 = CHAR_SPACE;
							if(r0 == r1){
								echo_string(r15, '\tfistp qword [');
								echo_string(r15, r2);
								echo_string(r15, ']\n');
							} else {
								r1 = CHAR_3;
								if (r0 == r1){
									//case '3' : fprintf(code, "\tfstp dword [%s]\n", hash_table[v_reg].token); break;
									echo_string(r15, '\tfstp dword [');
									echo_string(r15, r2);
									echo_string(r15, ']\n');
								} else {
									r1 = CHAR_6;
									if (r0 == r1){
										//case '6' : fprintf(code, "\tfstp qword [%s]\n", hash_table[v_reg].token); break;
										echo_string(r15, '\tfstp qword [');
										echo_string(r15, r2);
										echo_string(r15, ']\n');
									} else {
										//default  : fprintf(code, "\tfstp tword [%s]\n", hash_table[v_reg].token); break;
										echo_string(r15, '\tfstp tword [');
										echo_string(r15, r2);
										echo_string(r15, ']\n');
									}
								}
							}
						}
					}
				}
				//}
				//fprintf(code, "\tpop %s\n", hash_table[v_reg].token);
				echo_string(r15, '\tpop ');
				echo_string(r15, r2);
				echo_cr(r15);
			//} else {
			} else {
				// Non-structure definition, so this should be quick.
				r0 = state;
				r1 = CHAR_b; // 'b'
				if (r0 == r1){
					//case 'b' : abort_b0("Cannot store FPU into byte");	break;
					abort_b0('Cannot store FPU into byte');
				} else {
					r1 = CHAR_w;
					if (r0 == r1){
						//case 'w' : fprintf(code, "\tfistp word "); break;
						echo_string(r15, '\tfistp word ');
					} else {
						//#ifndef i386
						//case 'd' : fprintf(code, "\tfistp dword "); break;
						//case ' ' : fprintf(code, "\tfistp qword "); break;
						//#else
						//case ' ' : fprintf(code, "\tfistp dword "); break;
						//#endif
						#ifndef i386;
						r1 = CHAR_d; // 'w'
						#else;
						r1 = CHAR_SPACE; // ' '
						#endif;
						if(r0 == r1){
							echo_string(r15, '\tfistp dword ');
						} else {
							r1 = CHAR_SPACE;
							if(r0 == r1){
								echo_string(r15, '\tfistp qword ');
							} else {
								r1 = CHAR_3;
								if (r0 == r1){
									//case '3' : fprintf(code, "\tfstp dword "); break;
									echo_string(r15, '\tfstp dword ');
								} else {
									r1 = CHAR_6;
									if (r0 == r1){
										//case '6' : fprintf(code, "\tfstp qword "); break;
										echo_string(r15, '\tfstp qword ');
									} else {
										echo_string(r15, '\tfstp tword ');
									}
								}
							}
						}
					}
				}
				//Calculate_NSLabel_address(i);
				Calculate_NSLabel_address(r12);
				//fprintf(code, "\n");
				echo_cr(r15);
			//}
			}
			//token = i;
			r13 = token;
			i = r13;
		//} else {
		} else {
			// We should have a FPU REG
			//TokenIsLabelType(TYPE_REG_FPU);
			TokenIsLabelType(TYPE_REG_FPU);
			//if(DEBUG)
				//printf("Processing line with FPU register destination\n");
			if(r11){
				echo_string(STDOUT, 'Processing line with FPU register destination\n');
			}
			//target = token_stack[token]-HASH_OFFSET; //Store hash of target.
			r13 = token;
			r1 = [r14+r13*8];
			r2 = r1 - HASH_OFFSET;
			target = r2;
			//token++;
			r13 = r13 + 1;
			token = r13;
			//TokenIs(TOKEN_EQUATE);
			TokenIs(TOKEN_EQUATE);
			//token++;
			r13 = r13 + 1;
			token = r13;
			r0 = HASH_fp0;
			//if (target == HASH_fp0){
			if(r2 == r0){
				// Handle fp0 = something;
				r1 = [r14+r13*8];
				r4 = 0;
				r2 = TOKEN_NUM_DECIMAL;
				if (r1 == r2){ r4 = 1; }
				r2 = TOKEN_NUM_INTEGER;
				if (r1 == r2){ r4 = 1; }
				r2 = TOKEN_MINUS;
				if (r1 == r2){ r4 = 1; }
				//if ((token_stack[token] < TOKEN_OFFSET) || (token_stack[token] == TOKEN_MINUS)){
				if(r4){
					// We have a direct number load.
					r15 = data;
					//fprintf(data, "B0_DynNum%d dt ", dynamic_string_count);
					echo_string(r15, 'B0_DynNum');
					r4 = dynamic_string_count;
					echo_hex(r15, r4);
					echo_string(r15, ' dt ');
					//if (token_stack[token] == TOKEN_MINUS){
						//fprintf(data, "-");
						//token++;
					//}
					if(r1 == r2){
						echo_string(r15, '-');
						r13 = r13 + 1;
						token = r13;
					}
					//if (token_stack[token] > TOKEN_OFFSET)
						//abort_b0("Immediate Expected");
					r1 = [r14+r13*8];
					r2 = TOKEN_NUM_DECIMAL;
					if (r1 == r2){
						//outputNumberD(i,NUM_DECIMAL);
						outputNumber(r12,NUM_DECIMAL, r15);
					} else {
						outputNumber(r12,NUM_INTEGER, r15);
						echo_string(r15, '.0');
					}
					//fprintf(data, "\n");
					echo_cr(r15);
					r15 = code;
					//fprintf(code, "\tfld tword [B0_DynNum%d]\n", dynamic_string_count);
					echo_string(r15, '\tfld tword [B0_DynNum');
					echo_hex(r15, r4);
					echo_string(r15, ']\n');
					//dynamic_string_count++; // Inc the number of dynamic strings we have
					r4 = r4 + 1;
					dynamic_string_count = r4;
					//atStackEnd(i);
					atStackEnd(r12);
				//} else {
				} else {
					// We have a label or register or global!
					r2 = TOKEN_ARRAY_START;
					//if (token_stack[token] == TOKEN_ARRAY_START){
					if(r1 == r2){
						// Looks like we have a global
						//fprintf(code, "\tfld tword [");
						echo_string(r15, '\tfld tword [');
						//token++;	//Increase token pointer;
						r13 = r13 + 1;
						token = r13;
						//Global_Pointer(i);
						Global_Pointer(r12);
						//TokenIs(TOKEN_ARRAY_END);
						TokenIs(TOKEN_ARRAY_END);
						//fprintf(code, "]\n");
						echo_string(r15, ']\n');
						//token++;
						r13 = token;
						r13 = r13 + 1;
						token = r13;
						//atStackEnd(i);
						atStackEnd(r12);
					//} else {
					} else {
						// We can only have a reg or label
						//if (token_stack[token] < HASH_OFFSET)
							//abort_b0("Expected Label or FPU Register");
						r2 = HASH_OFFSET;
						if (r1 < r2){
							abort_b0('Expected Label or FPU Register');
						}
						r1 = r1 - r2;
						r2 = hash_table[r1].token_type;
						r3 = r2 && 0fh;
						//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & 0xf) > 0) {
						if(r3){
							// We have a label
							//if(DEBUG)
								//printf("Loading fp0 with variable\n");
							if(r11){
								echo_string(STDOUT, 'Loading fp0 with variable\n');
							}
							//v_target = 0;
							v_target = 0;
							//BuildLabelInfo(i);
							BuildLabelInfo(r12);
							//atStackEnd(i);
							atStackEnd(r12);
							r1 = 0;
							r0 = TYPE_V4I; if(r3 == r0) { r1 = 1; };
							r0 = TYPE_V4F; if(r3 == r0) { r1 = 1; };
							r0 = TYPE_V2F; if(r3 == r0) { r1 = 1; };
							if (r1){
								abort_b0('Unable to load FPU register from vector variable');
							}
							// Now we have all our information, so let build the instruction...
							//if(DEBUG){
								//DisplayLabelInfo();	
							//}
							if(r11){
								DisplayLabelInfo();
							}
							r5 = 0;
							r2 = v_isStruc;
							r1 = 1;
							r3 = state;
							r4 = 38h; //'8'
							
							//if ((v_isStruc == 1)||(state=='8')) {
							if(r2 == r1){ r5 = 1; }
							if(r3 == r4){ r5 = 1; }
							if(r5){
								// What we do, is calculate the offset for any struc operation, and then do a
								// fstp [r6|r14|r15] operation.
	
								//Set_v_reg();	//v_reg is the register we are going to use.
								Set_v_reg();
								//fprintf(code, "\tpush %s\n", hash_table[v_reg].token);
								r5 = v_reg;
								r5 = &hash_table[r5].token;
								echo_string(r15, '\tpush ');
								echo_string(r15, r5);
								echo_cr(r15);
								
								//Calculate_label_address(i);
								Calculate_label_address(r12);
												
								//Now we are ready to store the value...
								//switch(state){
									//case 'b' : abort_b0("Cannot store FPU into byte");	break;
									//case 'w' : fprintf(code, "\tfild word [%s]\n", hash_table[v_reg].token); break;
									//#ifndef i386
									//case 'd' : fprintf(code, "\tfild dword [%s]\n", hash_table[v_reg].token); break;
									//case ' ' : fprintf(code, "\tfild qword [%s]\n", hash_table[v_reg].token); break;
									//#else
									//case ' ' : fprintf(code, "\tfild dword [%s]\n", hash_table[v_reg].token); break;
									//#endif
									//case '3' : fprintf(code, "\tfld dword [%s]\n", hash_table[v_reg].token); break;
									//case '6' : fprintf(code, "\tfld qword [%s]\n", hash_table[v_reg].token); break;
									//default  : fprintf(code, "\tfld tword [%s]\n", hash_table[v_reg].token); break;
								//}
												//Now we are ready to store the value...
								r0 = state;
								r1 = CHAR_b; // 'b'
								r2 = v_reg;
								r2 = &hash_table[r2].token;
								//switch(state){
								if (r0 == r1){
									abort_b0('Cannot load FPU from byte');
								} else {
									r1 = CHAR_w;
									if (r0 == r1){
										echo_string(r15, '\tfild word [');
										echo_string(r15, r2);
										echo_string(r15, ']\n');
									} else {
										#ifndef i386;
										r1 = CHAR_d; // 'w'
										#else;
										r1 = CHAR_SPACE; // ' '
										#endif;
										if(r0 == r1){
											echo_string(r15, '\tfild dword [');
											echo_string(r15, r2);
											echo_string(r15, ']\n');
										} else {
											r1 = CHAR_SPACE;
											if(r0 == r1){
												echo_string(r15, '\tfild qword [');
												echo_string(r15, r2);
												echo_string(r15, ']\n');
											} else {
												r1 = CHAR_3;
												if (r0 == r1){
													echo_string(r15, '\tfld dword [');
													echo_string(r15, r2);
													echo_string(r15, ']\n');
												} else {
													r1 = CHAR_6;
													if (r0 == r1){
														echo_string(r15, '\tfld qword [');
														echo_string(r15, r2);
														echo_string(r15, ']\n');
													} else {
														echo_string(r15, '\tfld tword [');
														echo_string(r15, r2);
														echo_string(r15, ']\n');
													}
												}
											}
										}
									}
								}
								//}

								//fprintf(code, "\tpop %s\n", hash_table[v_reg].token);
								r5 = v_reg;
								r5 = &hash_table[r5].token;
								echo_string(r15, '\tpop ');
								echo_string(r15, r5);
								echo_cr(r15);
				
							//} else {
							} else {
								// Non-structure definition, so this should be quick.
								//switch(state){
									//case 'b' : abort_b0("Cannot store FPU into byte");	break;
									//case 'w' : fprintf(code, "\tfild word "); break;
									//#ifndef i386
									//case 'd' : fprintf(code, "\tfild dword "); break;
									//case ' ' : fprintf(code, "\tfild qword "); break;
									//#else
									//case ' ' : fprintf(code, "\tfild dword "); break;
									//#endif
									//case '3' : fprintf(code, "\tfld dword "); break;
									//case '6' : fprintf(code, "\tfld qword "); break;
								//}
								//Calculate_NSLabel_address(i);
								//fprintf(code, "\n");
								r0 = state;
								r1 = CHAR_b; // 'b'
								if (r0 == r1){
									abort_b0('Cannot store FPU into byte');
								} else {
									r1 = CHAR_w;
									if (r0 == r1){
										echo_string(r15, '\tfild word ');
									} else {
										#ifndef i386;
										r1 = CHAR_d; // 'w'
										#else;
										r1 = CHAR_SPACE; // ' '
										#endif;
										if(r0 == r1){
											echo_string(r15, '\tfild dword ');
										} else {
											r1 = CHAR_SPACE;
											if(r0 == r1){
												echo_string(r15, '\tfild qword ');
											} else {
												r1 = CHAR_3;
												if (r0 == r1){
													echo_string(r15, '\tfld dword ');
												} else {
													r1 = CHAR_6;
													if (r0 == r1){
														echo_string(r15, '\tfld qword ');
													} else {
														echo_string(r15, '\tfld tword ');
													}
												}
											}
										}
									}
								}
								Calculate_NSLabel_address(r12);
								echo_cr(r15);
							//}
							}
						//} else {
						} else {
							// We MUST have a FPU Reg.
							//TokenIsLabelType(TYPE_REG_FPU);
							TokenIsLabelType(TYPE_REG_FPU);
							r13 = token;
							// All we can have here is a TOS load, or a math operation.
							r1 = [r14+r13*8];
							r2 = HASH_fp0+HASH_OFFSET;
							//if (token_stack[token] == HASH_fp0+HASH_OFFSET){
							if (r1 == r2){
								// We MUST have a math function
								//token++;
								r13 = r13 + 1;
								token = r13;
								//if (token != i){
								if (r13 != r12){
									//Process our math operator
									r1 = [r14+r13*8];
									//state = token_stack[token];
									state = r1;
									//token++;
									r13 = r13 + 1;
									token = r13;
									//if (token == i)
										//abort_b0("Expected FPU Register");
									if (r13 == r12){
										abort_b0('Expected FPU Register');
									}
									//TokenIsLabelType(TYPE_REG_FPU);
									TokenIsLabelType(TYPE_REG_FPU);
									r13 = token;
									//switch(state){
									r1 = [r14+r13*8];
									r3 = r1 - HASH_OFFSET;
									r2 = &hash_table[r3].token;
									r0 = state;
									r1 = TOKEN_ADD;
									if(r0 == r1){
										//case TOKEN_ADD: fprintf(code, "\tfadd fp0, %s\n", hash_table[token_stack[token]-HASH_OFFSET].token); break;
										echo_string(r15, '\tfadd fp0, ');
										echo_string(r15, r2);
										echo_cr(r15);
									} else {
										r1 = TOKEN_MINUS;
										if(r0 == r1){
											//case TOKEN_MINUS: fprintf(code, "\tfsub fp0, %s\n", hash_table[token_stack[token]-HASH_OFFSET].token); break;
										echo_string(r15, '\tfsub fp0, ');
										echo_string(r15, r2);
										echo_cr(r15);
										} else {
											r1 = TOKEN_MULTIPLY;
											if(r0 == r1){
												//case TOKEN_MULTIPLY:
												echo_string(r15, '\tfmul fp0, ');
												echo_string(r15, r2);
												echo_cr(r15);
											} else {
												r1 = TOKEN_S_MULTIPLY;
												if(r0 == r1){
													//case TOKEN_S_MULTIPLY: fprintf(code, "\tfmul fp0, %s\n", hash_table[token_stack[token]-HASH_OFFSET].token); break;
													echo_string(r15, '\tfmul fp0, ');
													echo_string(r15, r2);
													echo_cr(r15);
												} else {
													r1 = TOKEN_DIVIDE;
													if(r0 == r1){
														//case TOKEN_DIVIDE:
														echo_string(r15, '\tfdiv fp0, ');
														echo_string(r15, r2);
														echo_cr(r15);
													} else {
														r1 = TOKEN_S_DIVIDE;
														if(r0 == r1){
															//case TOKEN_S_DIVIDE: fprintf(code, "\tfdiv fp0, %s\n", hash_table[token_stack[token]-HASH_OFFSET].token); break;
															echo_string(r15, '\tfdiv fp0, ');
															echo_string(r15, r2);
															echo_cr(r15);
														} else {
															r1 = TOKEN_MODULUS;
															if(r0 == r1){
																//case TOKEN_MODULUS:
																r1 = HASH_fp1;
																if (r3 != r1){ 
																	abort_b0('Floating Point Modulus requires 2nd operand to be fp1');
																}
																echo_string(r15, '\tfprem1\n');
															} else {
																r1 = TOKEN_S_MODULUS;
																if(r0 == r1){
																//case TOKEN_S_MODULUS:
																	//if (token_stack[token] != HASH_fp1+HASH_OFFSET)
																		//abort_b0("Floating Point Modulus requires 2nd operand to be fp1");
																	//fprintf(code, "\tfprem1\n");											
																	//break;
																	r1 = HASH_fp1;
																	if (r3 != r1){ 
																		abort_b0('Floating Point Modulus requires 2nd operand to be fp1');
																	}
																	echo_string(r15, '\tfprem1\n');
																} else {
																	//default: abort_b0("Invalid construct"); break;
																	abort_b0('Invalid construct');
																}
															}
														}
													}
												}
											}
										}
									}
									//}
									//token++;
									r13 = token;
									r13 = r13 + 1;
									token = r13;
									//atStackEnd(i);
									atStackEnd(r12);
								//} else {
								} else {
									// Looks like a dup ST0 operation.
									//fprintf(code, "\tfld fp0\n");
									echo_string(r15, '\tfld fp0\n');
									//atStackEnd(i);
									atStackEnd(r12);
								//}
								}
							//} else {
							} else {
								// We MUST have a TOS load or a reverse math operation.
								//target = token_stack[token]-HASH_OFFSET;
								r1 = [r14+r13*8];
								r2 = r1 - HASH_OFFSET;
								target = r2;
								//token++;
								r13 = r13 + 1;
								token = r13;
								//if (token != i){
								if(r13 != r12){
									//Process our math operator
									r1 = [r14+r13*8];
									//state = token_stack[token];
									state = r1;
									//token++;
									r13 = r13 + 1;
									token = r13;
									//if (token == i)
										//abort_b0("Expected FPU Register");
									if(r13 == r12){
										abort_b0('Expected FPU Register');
									}
									//TokenIsLabelType(TYPE_REG_FPU);
									TokenIsLabelType(TYPE_REG_FPU);
									r13 = token;
									r1 = [r14+r13*8];
									r2 = HASH_fp0+HASH_OFFSET;
									//if (token_stack[token] != HASH_fp0+HASH_OFFSET)
										//abort_b0("Operand register is not the same as the target register");
									if(r1 != r2){
										abort_b0('Operand register is not the same as the target register');
									}
									r0 = state;
									//switch(state){
										//case TOKEN_ADD: fprintf(code, "\tfadd fp0, %s\n", hash_table[target].token); break;
										//case TOKEN_MINUS: fprintf(code, "\tfsubr fp0, %s\n", hash_table[target].token); break;
										//case TOKEN_MULTIPLY:
										//case TOKEN_S_MULTIPLY: fprintf(code, "\tfmul fp0, %s\n", hash_table[target].token); break;
										//case TOKEN_DIVIDE:
										//case TOKEN_S_DIVIDE: fprintf(code, "\tfdivr fp0, %s\n", hash_table[target].token); break;
										//default: abort_b0("Invalid construct"); break;
									//}
									r0 = target;
									//r1 = [r14+r0*8];
									//r1 = r1 - HASH_OFFSET;
									r2 = &hash_table[r0].token;
									r0 = state;
									r1 = TOKEN_ADD;
									if(r0 == r1){
										echo_string(r15, '\tfadd fp0, ');
										echo_string(r15, r2);
										echo_cr(r15);
									} else {
										r1 = TOKEN_MINUS;
										if(r0 == r1){
											echo_string(r15, '\tfsubr fp0, ');
											echo_string(r15, r2);
											echo_cr(r15);
										} else {
											r1 = TOKEN_MULTIPLY;
											if(r0 == r1){
												echo_string(r15, '\tfmul fp0, ');
												echo_string(r15, r2);
												echo_cr(r15);
											} else {
												r1 = TOKEN_S_MULTIPLY;
												if(r0 == r1){
													echo_string(r15, '\tfmul fp0, ');
													echo_string(r15, r2);
													echo_cr(r15);
												} else {
													r1 = TOKEN_DIVIDE;
													if(r0 == r1){
														echo_string(r15, '\tfdivr fp0, ');
														echo_string(r15, r2);
														echo_cr(r15);
													} else {
														r1 = TOKEN_S_DIVIDE;
														if(r0 == r1){
															echo_string(r15, '\tfdivr fp0, ');
															echo_string(r15, r2);
															echo_cr(r15);
														} else {
															abort_b0('Invalid construct');
														}
													}
												}
											}
										}
									}
									//token++;
									r13 = token;
									r13 = r13 + 1;
									token = r13;
									//atStackEnd(i);	
									atStackEnd(r12);
								//} else {
								} else {
									//fprintf(code, "\tfld %s\n", hash_table[target].token);
									r1 = &hash_table[r2].token;
									echo_string(r15, '\tfld ');
									echo_string(r15, r1);
									echo_cr(r15);
								//}								
								}
							//}
							}
						//}
						}
					//}
					}
				//}
				}
			//} else {
			} else {
				// We should have a fp = fp0; or fp = fp {math} fp0;
				r1 = [r14+r13*8];
				r1 = r1 - HASH_OFFSET;
				r0 = target;
				//if (target == token_stack[token]-HASH_OFFSET){
				if(r0 == r1){
					//token++;
					r13 = r13 + 1;
					token = r13;
					//if (token != i){
					if(r13 != r12){
						//Process our math operator
						//state = token_stack[token];
						r1 = [r14+r13*8];
						state = r1;
						//token++;
						r13 = r13 + 1;
						token = r13;
						//if (token == i)
							//abort_b0("Expected FPU Register");
						if(r13 == r12){
							abort_b0('Expected FPU Register');
						}
						//TokenIsLabelType(TYPE_REG_FPU);
						TokenIsLabelType(TYPE_REG_FPU);
						r13 = token;
						//if (token_stack[token] != HASH_fp0+HASH_OFFSET)
							//abort_b0("fp0 Expected");
						r1 = [r14+r13*8];
						r2 = HASH_fp0+HASH_OFFSET;
						if (r1 != r2){
							abort_b0('fp0 Expected');
						}
						//switch(state){
							//case TOKEN_ADD:	fprintf(code, "\tfadd %s, fp0\n", hash_table[target].token); break;
							//case TOKEN_MINUS: fprintf(code, "\tfsub %s, fp0\n", hash_table[target].token); break;
							//case TOKEN_MULTIPLY:
							//case TOKEN_S_MULTIPLY: fprintf(code, "\tfmul %s, fp0\n", hash_table[target].token); break;
							//case TOKEN_DIVIDE:
							//case TOKEN_S_DIVIDE: fprintf(code, "\tfdiv %s, fp0\n", hash_table[target].token); break;
							//default: abort_b0("Invalid construct"); break;
						//}
						//r1 = [r14+r13*8];
						//r1 = r1 - HASH_OFFSET;
						r1 = target;
						r2 = &hash_table[r1].token;
						r0 = state;
						r1 = TOKEN_ADD;
						if(r0 == r1){
							echo_string(r15, '\tfadd ');
							echo_string(r15, r2);
							echo_string(r15, ', fp0\n');
						} else {
							r1 = TOKEN_MINUS;
							if(r0 == r1){
								echo_string(r15, '\tfsub ');
								echo_string(r15, r2);
								echo_string(r15, ', fp0\n');
							} else {
								r1 = TOKEN_MULTIPLY;
								if(r0 == r1){
									echo_string(r15, '\tfmul ');
									echo_string(r15, r2);
									echo_string(r15, ', fp0\n');
								} else {
									r1 = TOKEN_S_MULTIPLY;
									if(r0 == r1){
										echo_string(r15, '\tfmul ');
										echo_string(r15, r2);
										echo_string(r15, ', fp0\n');
									} else {
										r1 = TOKEN_DIVIDE;
										if(r0 == r1){
											echo_string(r15, '\tfdiv ');
											echo_string(r15, r2);
											echo_string(r15, ', fp0\n');
										} else {
											r1 = TOKEN_S_DIVIDE;
											if(r0 == r1){
												echo_string(r15, '\tfdiv ');
												echo_string(r15, r2);
												echo_string(r15, ', fp0\n');
											} else {
												abort_b0('Invalid construct');
											}
										}
									}
								}
							}
						}
						//token++;
						r13 = token;
						r13 = r13 + 1;
						token = r13;
						//atStackEnd(i);	
						atStackEnd(r12);
					//}
					}
				//} else {
				} else {
					//if (token_stack[token] != HASH_fp0+HASH_OFFSET)
						//abort_b0("fp0 Expected");
					r1 = [r14+r13*8];
					r2 = HASH_fp0+HASH_OFFSET;
					if(r1 != r2){
						abort_b0('fp0 Expected');
					}
					//token++;
					r13 = r13 + 1;
					token = r13;
					//if (token != i){
					if(r13 != r12){
						//Process our math operator
						//state = token_stack[token];
						r1 = [r14+r13*8];
						state = r1;
						//token++;
						r13 = r13 + 1;
						token = r13;
						//if (token == i)
							//abort_b0("Expected FPU Register");
						if(r13 == r12){
							abort_b0('Expected FPU Register');
						}
						//TokenIsLabelType(TYPE_REG_FPU);
						TokenIsLabelType(TYPE_REG_FPU);
						r13 = token;
						r1 = [r14+r13*8];
						r2 = target;
						r3 = r2 + HASH_OFFSET;
						//if (token_stack[token] != (target+HASH_OFFSET))
							//abort_b0("Operand register is not the same as the target register");
						if(r1 != r3){
							abort_b0('Operand register is not the same as the target register');
						}
						//switch(state){
							//case TOKEN_ADD: fprintf(code, "\tfadd %s, fp0\n", hash_table[target].token); break;
							//case TOKEN_MINUS: fprintf(code, "\tfsubr %s, fp0\n", hash_table[target].token); break;
							//case TOKEN_MULTIPLY:
							//case TOKEN_S_MULTIPLY: fprintf(code, "\tfmul %s, fp0\n", hash_table[target].token); break;
							//case TOKEN_DIVIDE:
							//case TOKEN_S_DIVIDE: fprintf(code, "\tfdivr %s, fp0\n", hash_table[target].token); break;
							//default: abort_b0("Invalid construct"); break;
						//}
						//r1 = [r14+r13*8];
						//r1 = r1 - HASH_OFFSET;
						r1 = target;
						r2 = &hash_table[r1].token;
						r0 = state;
						r1 = TOKEN_ADD;
						if(r0 == r1){
							echo_string(r15, '\tfadd ');
							echo_string(r15, r2);
							echo_string(r15, ', fp0\n');
						} else {
							r1 = TOKEN_MINUS;
							if(r0 == r1){
								echo_string(r15, '\tfsubr ');
								echo_string(r15, r2);
								echo_string(r15, ', fp0\n');
							} else {
								r1 = TOKEN_MULTIPLY;
								if(r0 == r1){
									echo_string(r15, '\tfmul ');
									echo_string(r15, r2);
									echo_string(r15, ', fp0\n');
								} else {
									r1 = TOKEN_S_MULTIPLY;
									if(r0 == r1){
										echo_string(r15, '\tfmul ');
										echo_string(r15, r2);
										echo_string(r15, ', fp0\n');
									} else {
										r1 = TOKEN_DIVIDE;
										if(r0 == r1){
											echo_string(r15, '\tfdivr ');
											echo_string(r15, r2);
											echo_string(r15, ', fp0\n');
										} else {
											r1 = TOKEN_S_DIVIDE;
											if(r0 == r1){
												echo_string(r15, '\tfdivr ');
												echo_string(r15, r2);
												echo_string(r15, ', fp0\n');
											} else {
												abort_b0('Invalid construct');
											}
										}
									}
								}
							}
						}
						//token++;
						r13 = token;
						r13 = r13 + 1;
						token = r13;
						//atStackEnd(i);	
						atStackEnd(r12);
					//} else {
					} else {
					//	fprintf(code, "\tfxch %s\n", hash_table[target].token);
						r1 = target;
						r1 = &hash_table[r1].token;
						echo_string(r15, '\tfxch ');
						echo_string(r15, r1);
						echo_cr(r15);
					//}
					}
				//};
				}
			//}
			}
		//}
		}
	//}
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
}

proc get_xmm_register(reg){
	push r1, r2;
	r1 = reg;
	r2 = HASH_xmm0;
	if(r1 == r2){
		r0 = 0;
	} else {
	r2 = HASH_xmm1;
	if(r1 == r2){
		r0 = 1;
	} else {	
	r2 = HASH_xmm2;
	if(r1 == r2){
		r0 = 2;
	} else {	
	r2 = HASH_xmm3;
	if(r1 == r2){
		r0 = 3;
	} else {	
	r2 = HASH_xmm4;
	if(r1 == r2){
		r0 = 4;
	} else {	
	r2 = HASH_xmm5;
	if(r1 == r2){
		r0 = 5;
	} else {	
	r2 = HASH_xmm6;
	if(r1 == r2){
		r0 = 6;
	} else {	
	r2 = HASH_xmm7;
	if(r1 == r2){
		r0 = 7;
	} else {	
	r2 = HASH_xmm8;
	if(r1 == r2){
		r0 = 8;
	} else {	
	r2 = HASH_xmm9;
	if(r1 == r2){
		r0 = 9;
	} else {	
	r2 = HASH_xmm10;
	if(r1 == r2){
		r0 = 10;
	} else {	
	r2 = HASH_xmm11;
	if(r1 == r2){
		r0 = 11;
	} else {	
	r2 = HASH_xmm12;
	if(r1 == r2){
		r0 = 12;
	} else {	
	r2 = HASH_xmm13;
	if(r1 == r2){
		r0 = 13;
	} else {	
	r2 = HASH_xmm14;
	if(r1 == r2){
		r0 = 14;
	} else {	
	r2 = HASH_xmm15;
	if(r1 == r2){
		r0 = 15;
	} else {	
		r0 = 0;
	}}}}}}}}}}}}}}}};
	pop r2, r1;
	return(r0);
}

proc set_xmm_mov_operator(target_reg_type, source_reg_type){
	push r1, r2, r3, r4, r5;
	r1 = target_reg_type;
	r2 = source_reg_type;
	r3 = TYPE_V4I;
	r4 = TYPE_V4F;
	r5 = TYPE_V2F;
	if(r1 == r3){
		// Target reg is TYPE_V4I;
		if(r2 == r3){
			r0 = &'\tmovdqu ';  // target and source are same
		} else {
			if(r2 == r4){
				r0 = &'\tcvtps2dq ';		// target = V4I, source = V4F
			} else {
				r0 = &'\tcvttpd2dq ';	// target = V4I, source = V2F
			}
		}
	} else {
		if(r1 == r4){
			// Target if TYPE_V4F;
			if(r2 == r4){
				r0 = &'\tmovdqu ';  // target and source are same
			} else {
				if(r2 == r3){
					r0 = &'\tcvtdq2ps ';	// target = V4F, source = V4I
				} else {
					r0 = &'\tcvtpd2ps ';	// target = V4F, source = V2F
				}
			}
		} else {
			// target must be TYPE_V2F;
			if(r2 == r5){
				r0 = &'\tmovdqu '; // target and source are the same;
			} else {
				if(r2 == r3){
					r0 = &'\tcvtdq2pd ';	// target = V2F, source = V4I
				} else {
					r0 = &'\tcvtps2pd ';	// target = V2F, source = V4F
				}
			}
		}	
	}
	pop r5, r4, r3, r2, r1;
	return(r0);
}

proc process_xmm_operation(i){
	v_base = 0;
	v_isStruc = 0;
	v_offset = 0;
	v_offset_type = 0;
	v_size = 0;
	v_index = 0;
	v_target = 0;
	v_global = 0;
	v_reg = 0;
		
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12, r13, r14, r15;
	r15 = code;
	r14 = &token_stack;
	r13 = token;
	r12 = i;
	r11 = DEBUG;
	r1 = [r14+r13*8];
	r2 = TOKEN_ARRAY_START;

	//if ( token_stack[token] == TOKEN_ARRAY_START) {
	if(r1 == r2){
		echo_string(r15, '\tmovdqu [');
		//token++;	//Increase token pointer;
		r13 = r13 + 1;
		token = r13;
		Global_Pointer(r12);
		TokenIs(TOKEN_ARRAY_END);
		echo_string(r15, '], ');
		//token++;
		r13 = token;
		r13 = r13 + 1;
		token = r13;
		//TokenIs(TOKEN_EQUATE);
		TokenIs(TOKEN_EQUATE);
		//token++;
		r13 = r13 + 1;
		token = r13;
		r1 = [r14+r13*8];
		isHash(r1);
		TokenIsLabelType(TYPE_REG_XMM);
		r1 = r1 - HASH_OFFSET;
		r2 = &hash_table[r1].token;
		echo_string(r15, r2);
		echo_cr(r15);
		//token++;
		r13 = r13 + 1;
		token = r13;
		atStackEnd(r12);
	//} else {
	} else {
		// We can have a label or XMM reg?
		isHash(r1);		// Let's confirm that
		r2 = r1 - HASH_OFFSET;
		r3 = hash_table[r2].token_type;
		r4 = r3 && 0fh;
		if(r4){
			// We have a label;
			if(r11){
				echo_string(STDOUT, 'Processing line with variable destination\n');
			}
			BuildLabelInfo(r12);
			if(r11){
				DisplayLabelInfo();
			}
			TokenIs(TOKEN_EQUATE);
			//token++;
			r13 = token;
			r13 = r13 + 1;
			token = r13;
			v_target = r13;		// point to the target reg just in case we need it later.
			r1 = [r14+r13*8];
			isHash(r1);
			TokenIsLabelType(TYPE_REG_XMM);
			r8 = r1 - HASH_OFFSET;
			if(r11){
				echo_string(STDOUT, 'Getting xmm register type\n');
			}
			r3 = get_xmm_register(r8);
			// This is the index to VectorRegType to see what our current xmm really is.
			// If it's different to the current mode, then we need to modify the 
			// xmm register to be the same as the variable.
			r4 = VectorRegType[r3];
			r5 = state;
			r0 = CHAR_U;
			if (r0 == r5){
				r5 = TYPE_V4I;
			} else {
				r0 = CHAR_V;
				if(r0 == r5){
					r5 = TYPE_V4F;
				} else {
					r0 = CHAR_W;
					if(r0 == r5){
						r5 = TYPE_V2F;
					} else {
						abort_b0('Unable to store Vector Register in non-Vector variable');
					}
				}
			}
			if(r4 != r5){
				if(r11){
					echo_string(STDOUT, 'XMM and variable are different types - VectorReg = ');
					echo_integer(STDOUT, r4);
					echo_string(STDOUT, ' - variable state = ');
					echo_integer(STDOUT, r5);
					echo_cr(STDOUT);
				}
				r0 = set_xmm_mov_operator(r4, r5);
				// Since we are storing a reg into a label, we need to convert
				// the xmm into the same format as the label, then store.
				echo_string(r15, r0);
				r1 = &hash_table[r8].token;
				echo_string(r15, r1);
				echo_string(r15, ', ');
				echo_string(r15, r1);
				echo_cr(r15);
				VectorRegType[r3] = r5;	// Update the reg type.
			}
			//echo_string(STDOUT, 'Here\n');
			// Now we can store the register;
			// Becuase the xmm variables are greater than 16 bytes, we always
			// treat them as structured variables.
			Set_v_reg();
			r2 = v_reg;
			r1 = &hash_table[r2].token;
			echo_string(r15, '\tpush ');
			echo_string(r15, r1);
			echo_cr(r15);
			Calculate_label_address(r12);
			echo_string(r15, '\tmovdqu [');
			echo_string(r15, r1);
			echo_string(r15, '], ');
			r8 = &hash_table[r8].token;
			echo_string(r15, r8);
			echo_string(r15, '\n\tpop ');
			echo_string(r15, r1);
			echo_cr(r15);

			r0 = i;
			token = r0;
		} else {
			// We have a xmm reg?
			TokenIsLabelType(TYPE_REG_XMM);
			// We know the first target reg is token_stack[0];
			if(r11){
				echo_string(STDOUT, 'Processing line with XMM register destination\n');
			}
			//token++;
			r13 = token;
			r13 = r13 + 1;
			token = r13;			
			TokenIs(TOKEN_EQUATE);
			//token++;
			r13 = token;
			r13 = r13 + 1;
			token = r13;
			// We should have a label, reg, or load memory reference.
			r1 = [r14+r13*8];
			r2 = TOKEN_ARRAY_START;
			if(r1 == r2){
				// We have a mem pointer;
				echo_string(r15, '\tmovdqu ');
				r0 = [r14];
				r0 = r0 - HASH_OFFSET;
				r0 = &hash_table[r0].token;
				echo_string(r15, r0);
				echo_string(r15, ', [');
				r13 = r13 + 1;
				token = r13;				
				Global_Pointer(r12);
				TokenIs(TOKEN_ARRAY_END);
				echo_string(r15, ']\n');				
				r13 = token;
				r13 = r13 + 1;
				token = r13;			
				atStackEnd(r12);
			} else {
				// We have xmm_reg = a label or xmm reg.
				isHash(r1);		// Let's confirm that
				r2 = r1 - HASH_OFFSET;
				r3 = hash_table[r2].token_type;
				r4 = r3 && 0fh;
				if(r4){
					// We have a label;
					if(r11){
						echo_string(STDOUT, 'Processing line with variable source and register destination\n');
					}
					BuildLabelInfo(r12);
					if(r11){
						DisplayLabelInfo();
					}
					r1 = [r14];		// Get our xmm register
					r8 = r1 - HASH_OFFSET;
					if(r11){
						echo_string(STDOUT, 'Getting xmm register type\n');
					}
					r3 = get_xmm_register(r8);
					// This is the index to VectorRegType to see what our current xmm really is.
					// If it's different to the current mode, then we need to modify the 
					// xmm register to be the same as the variable.
					r4 = VectorRegType[r3];
					r5 = state;
					r0 = CHAR_U;
					if (r0 == r5){
						r5 = TYPE_V4I;
					} else {
						r0 = CHAR_V;
						if(r0 == r5){
							r5 = TYPE_V4F;
						} else {
							r0 = CHAR_W;
							if(r0 == r5){
								r5 = TYPE_V2F;
							} else {
								abort_b0('Unable to load Vector Register from non-Vector variable');
							}
						}
					}
					r9 = set_xmm_mov_operator(r4, r5);
					VectorRegType[r3] = r5;	// Update the reg type.
					//echo_string(STDOUT, 'Here\n');
					// Now we can store the register;
					// Becuase the xmm variables are greater than 16 bytes, we always
					// treat them as structured variables.
					Set_v_reg();
					r2 = v_reg;
					r1 = &hash_table[r2].token;
					echo_string(r15, '\tpush ');
					echo_string(r15, r1);
					echo_cr(r15);
					Calculate_label_address(r12);
					echo_string(r15, r9);
					r8 = &hash_table[r8].token;
					echo_string(r15, r8);					
					echo_string(r15, ', [');
					echo_string(r15, r1);
					echo_string(r15, ']\n\tpop ');
					echo_string(r15, r1);
					echo_cr(r15);
		
					r0 = i;
					token = r0;
				} else {
					// We must has a xmm_reg
					if(r11){
						echo_string(STDOUT, 'XMM Register = XMM Register;\n');
					}
					TokenIsLabelType(TYPE_REG_XMM);
					// What we must do is see if the regs are same, and if they are same as the current vector mode
					// We can skip this part, else do a convert/mov.
					r8 = [r14];				// destination;
					r9 = [r14+r13*8];		// source
					r8 = r8 - HASH_OFFSET;
					r9 = r9 - HASH_OFFSET;
					r1 = get_xmm_register(r8);
					r2 = get_xmm_register(r9);
					r3 = VectorRegType[r1];		// r3 = Vector mode for the destination
					r4 = VectorRegType[r2];		// r4 = Vector mode for the source
					r5 = VectorMode;
					if(r11){
						echo_string(STDOUT, 'XMM modes checked;\n');
					}
					if (r8 == r9){
						// They are same
						if(r11){
							echo_string(STDOUT, 'xmm0 == xmm0;\n');
						}
						if(r4 != r5){
							if(r11){
								echo_string(STDOUT, 'But modes are different\n');
							}
							// But the mode isn't the same reg type; so convert
							r10 = set_xmm_mov_operator(r5, r4);
							VectorRegType[r1] = r5;
							r3 = r5;
							echo_string(r15, r10);
							echo_string(r15, ' ');
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);
						}
					} else {
						// They are different.
						if(r11){
							echo_string(STDOUT, 'xmm0 != xmm0;\n');
						}
						r10 = set_xmm_mov_operator(r5, r4);
						VectorRegType[r1] = r5;
						r3 = r5;
						echo_string(r15, r10);
						echo_string(r15, ' ');
						r0 = &hash_table[r8].token;
						echo_string(r15, r0);
						echo_string(r15, ', ');
						r0 = &hash_table[r9].token;
						echo_string(r15, r0);
						echo_cr(r15);						
					}
					r13 = r13 + 1;
					token = r13;
					if(r12 != r13){
						// We have something else, like an operator or something;
						r10 = [r14+r13*8];
						// Make r10 = our operator;
						r13 = r13 + 1;
						token = r13;
						if(r0 == r13){
							// Umm we've run out of symbols, better abort
							abort_b0('Expected xmm register');
						}
						TokenIsLabelType(TYPE_REG_XMM);
						r9 = [r14+r13*8];
						r13 = r13 + 1;
						token = r13;
						r9 = r9 - HASH_OFFSET;
						r2 = get_xmm_register(r9);
						r4 = VectorRegType[r2];		// r4 = Vector mode for the second xmm register
						// We now have all the info we need;
						// r0 = ?, r1 = xmm destination register, r2 = source dest register, r3 = Vector Mode for destination
						// r4 = Vector mode for source, r5 = current Vector Mode, r6 = N/A, r7 = N/A
						// r8 = HASH index of dest register, r9 = HASH index of src reg, r10 = TOKEN_OPERATOR
						// r11 = DEBUG, r12 = i, r13 = token, r14 = &token_stack, r15 = code file.
						// First we see if our 2nd xmm reg is the current mode, if not, convert;
						if(r4 != r5){
							// Convert the xmm register;
							// They are different.
							if(r11){
								echo_string(STDOUT, '2nd xmm mode incorrect, correcting\n');
							}
							r0 = set_xmm_mov_operator(r5, r4);
							VectorRegType[r2] = r5;
							r4 = r5;
							echo_string(r15, r0);
							echo_string(r15, ' ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);	
						}
						r0 = TOKEN_ADD;
						if(r0 == r10){
							// Add operator;
							// The operators change depending the current mode;
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpaddd ');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\taddps ');
								} else {
									echo_string(r15, '\taddpd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);							
						
						
						} else {
						r0 = TOKEN_MINUS;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpsubd ');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tsubps ');
								} else {
									echo_string(r15, '\tsubpd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);

						
						} else {
						r0 = TOKEN_MULTIPLY;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Multiplication not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tmulps ');
								} else {
									echo_string(r15, '\tmulpd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);

						
						} else { 
						r0 = TOKEN_DIVIDE;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Division not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tdivps ');
								} else {
									echo_string(r15, '\tdivpd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);

						
						} else {
						r0 = TOKEN_S_MULTIPLY;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Multiplication not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tmulps ');
								} else {
									echo_string(r15, '\tmulpd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);

						
						} else {
						r0 = TOKEN_S_DIVIDE;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Division not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tdivps ');
								} else {
									echo_string(r15, '\tdivpd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);
						
						
						} else {
						r0 = TOKEN_LROTATE;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpshufd ');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tpshufd ');
								} else {
									abort_b0('Shuffle operations not allowed on vector type V2F');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 39h\n');						
						
						
						} else {
						r0 = TOKEN_RROTATE;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpshufd ');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tpshufd ');
								} else {
									abort_b0('Shuffle operations not allowed on vector type V2F');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 93h\n');				
						
						
						} else {
						r0 = TOKEN_LSHIFT;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpslld ');
							} else {
								abort_b0('Shift operations not allowed on vector types V4F or V2F');
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, '\n');
							
						
						} else {
						r0 = TOKEN_RSHIFT;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpsrld ');
							} else {
								abort_b0('Shift operations not allowed on vector types V4F or V2F');
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, '\n');
						
						
						} else {
						r0 = TOKEN_AND;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpand ');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tandps ');
								} else {
									echo_string(r15, '\tandpd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);
						
						
						} else {
						r0 = TOKEN_OR;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpor ');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\torps ');
								} else {
									echo_string(r15, '\torpd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);						
						
						
						} else {
						r0 = TOKEN_XOR;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpxor ');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\txorps ');
								} else {
									echo_string(r15, '\txorpd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_cr(r15);
							
						
						} else {
						r0 = TOKEN_EQUALS;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								echo_string(r15, '\tpcmpgtd ');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							r0 = TYPE_V4I;
							if(r5 != r0){
								echo_string(r15, ', 0\n');
							} else {
								echo_cr(r15);
							}
							
						
						} else {
						r0 = TOKEN_NOTEQUALS;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Comparisons not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 4\n');						
						
						
						} else {
						r0 = TOKEN_LESSTHANEQUALS;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Comparisons not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 2\n');						
						
						
						} else {
						r0 = TOKEN_GREATERTHANEQUALS;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Comparisons not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 5\n');						
						
						
						} else {
						r0 = TOKEN_LESSTHAN;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Comparisons not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 1\n');						
						
						
						} else {
						r0 = TOKEN_GREATERTHAN;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Comparisons not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 6\n');						
						
						
						} else {
						r0 = TOKEN_S_LESSTHANEQUALS;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Comparisons not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 2\n');						
						
						
						} else {
						r0 = TOKEN_S_GREATERTHANEQUALS;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Comparisons not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 5\n');						
						
						
						} else {
						r0 = TOKEN_S_LESSTHAN;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Comparisons not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 1\n');						
						
						
						} else {
						r0 = TOKEN_S_GREATERTHAN;
						if(r0 == r10){
							r0 = TYPE_V4I;
							if(r5 == r0){
								abort_b0('Comparisons not allowed on vector type V4I');
							} else {
								r0 = TYPE_V4F;
								if(r5 == r0){
									echo_string(r15, '\tcmpps ');
								} else {
									echo_string(r15, '\tcmppd ');
								}
							}
							r0 = &hash_table[r8].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r9].token;
							echo_string(r15, r0);
							echo_string(r15, ', 6\n');						
						
						
						} else {
							abort_b0('Invalid operator for Vector Operations');
						}}}}}}}}}}}}}}}}}}}}}}}
					}
					atStackEnd(r12);
				}
			}
		}
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
}

proc process_lib_directive(i){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12, r13, r14, r15;
	
	//atStackStart();
	atStackStart();
	// Looks like we need to include a file.
	//TokenIs(TOKEN_STRING);
	TokenIs(TOKEN_STRING);
	//token++; // skip the start of string token
	r15 = &token_stack;
	r14 = token;
	r13 = DEBUG;
	r14 = r14 + 1;
	token = r14;
	r1 = TOKEN_END_STRING;
	r2 = [r15+r14*8];
	//while (token_stack[token] != TOKEN_END_STRING){
		//filename[token-2] = ((unsigned char)token_stack[token] & 0x7f); // Convert to ASCII
		//filename[token-1] = '\0'; //Null terminate!
		//token++;
		//if ((token-1) >= FILENAME_MAX) abort_b0("INTERNAL: Filename generation overflow! - Increase FILENAME_MAX");
	//}
	r10 = &filename;
	r0 = 0;
	[r10] = r0w;
	r3 = FILENAME_MAX;
	while (r2 != r1){
		r2 = r2 && 07fh;
		[r10+r14] = r2b;
		[r10+r14+1] = r0b;
		r14 = r14 + 1;
		token = r14;
		if(r14 >= r3){
			abort_b0('INTERNAL: Filename generation overflow! - Increase FILENAME_MAX');
		}
		r2 = [r15+r14*8];
	}
	//TokenIs(TOKEN_END_STRING);
	TokenIs(TOKEN_END_STRING);
	//token++;	// Skip TOKEN_END_STRING
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	//atStackEnd(i);
	r0 = i;
	atStackEnd(r0);
	// Save current ch and lch values;
	//file[file_stack_ptr].ch = ch;
	//file[file_stack_ptr].look_ahead_ch = look_ahead_ch;
	r0 = ch;
	r1 = look_ahead_ch;
	r2 = file_stack_ptr;
	file[r2].ch = r0;
	file[r2].look_ahead_ch = r1;
	// Reset values;
	//ch = 00;
	//look_ahead_ch = 00;
	ch = 0;
	look_ahead_ch = 0;
	//file_stack_ptr++;
	r2 = r2 + 1;
	file_stack_ptr = r2;
	//if (file_stack_ptr >= MAX_LIB_DEPTH)
		//abort_b0("INTERNAL: File Table overflow - too many nested files! - Increase MAX_LIB_DEPTH");
	r1 = MAX_LIB_DEPTH;
	if(r2 >= r1){
		abort_b0('INTERNAL: File Table overflow - too many nested files! - Increase MAX_LIB_DEPTH');
	}
	//if (DEBUG)
		//printf("filename = %s\n", filename);
	if(r13){
		echo_string(STDOUT, 'filename = ');
		echo_string(STDOUT, r10);
		echo_cr(STDOUT);
	}
	//file[file_stack_ptr].handle = fopen(( char *) filename, "r");  // Let's see if it's in our current directory
	r0 = _fopen(r10, 'r');
	//if (!file[file_stack_ptr].handle){
	push r0, r4;
			r14 = r0;
			if(r13){
				echo_string(STDOUT, '; handle = ');
				echo_hex(STDOUT, r4);
				echo_cr(STDOUT);
			}
	pop r4, r0;
	if(r0){
		file[r2].handle = r0;
		r1 = &file[r2].filename;
		strcpy(r1, r10);
		file[r2].line_count = 1;
	} else {
		// Now we just need to sort through the various include directories
		//j = 0;
		r1 = total_paths;
		r3 = 0;
		//while (j < total_paths){
		while(r3 < r1){
			r9 = &tmp_filename;
			r8 = &paths[r3].path;
			//strcpy((char *) tmp_filename, paths[j]);
			strcpy(r9, r8);
			//strcat((char *) tmp_filename, (char *) filename);							// attach our include path
			strcat(r9, r10);
			//file[file_stack_ptr].handle = fopen(( char *) tmp_filename, "r"); // Attempt to open
			r4 = _fopen(r9, 'r');
			//echo_string(STDOUT, 'Completed fopen - dir search\n');

			//if (DEBUG)
				//printf("filename = %s; handle = %p\n", tmp_filename, file[file_stack_ptr].handle );
			if(r13){
				echo_string(STDOUT, 'filename = ');
				echo_string(STDOUT, r9);
				echo_string(STDOUT, '; handle = ');
				echo_hex(STDOUT, r4);
				echo_cr(STDOUT);
			}
			//if (file[file_stack_ptr].handle){						// We get a good handle
			if(r4){
				//strcpy((char *) file[file_stack_ptr].filename, ( char *) filename);	// So copy it to our file-open stack
				//file[file_stack_ptr].line_count = 1;				// Reset line count.
				file[r2].handle = r4;
				r1 = &file[r2].filename;
				strcpy(r1, r10);
				file[r2].line_count = 1;
				//if (DEBUG)
					//printf("found file: %s in %s\n", filename, paths[j]);
				if(r13){
					echo_string(STDOUT, 'found file: ');
					echo_string(STDOUT, r10);
					echo_string(STDOUT, ' in ');
					echo_string(STDOUT, r8);
					echo_cr(STDOUT);
				}
				r3 = r1;
				//break;												// and exit.
			//}
			}
			//j++;
			r3 = r3 + 1;
		//}
		}
		//if (!file[file_stack_ptr].handle){
			//abort_b0("Unable to open file");
			//exit(1);
		//}
		r0 = file[r2].handle;
		r1 = 0;
		if (r0 == r1){
			r2 = file_stack_ptr;
			r2 = r2 - 1;
			file_stack_ptr = r2;
			abort_b0('Unable to open lib file');
		}
	//} else {
		//strcpy((char *) file[file_stack_ptr].filename, ( char *)filename);
		//file[file_stack_ptr].line_count = 1;
	//};
	}
	
	push r0;
	if(r13){
		echo_string(STDOUT, 'Completed fopen - end\n');
	}
	pop r0;

	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;	
}

proc process_syscall_directive(i){
	push r1, r2;
	//atStackStart();
	atStackStart();
	//fprintf(code, "\t%s\n", hash_table[token_stack[(token-1)]-HASH_OFFSET].token);
	r1 = code;
	r0 = token_stack;
	r0 = r0 - HASH_OFFSET;
	r2 = &hash_table[r0].token;
	echo_string(r1, '\t');
	echo_string(r1, r2);
	echo_cr(r1);
	//atStackEnd(i);
	r0 = i;
	atStackEnd(r0);
	pop r2, r1;
}

proc process_extern_directive(i){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12, r13, r14, r15;
	m64 k;
	
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = DEBUG;
	//atStackStart();
	atStackStart();
	//IsLabelAllocated();
	IsLabelAllocated();
	//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_EPROC;
	r14 = token;
	r1 = [r15+r14*8];
	r1 = r1 - HASH_OFFSET;
	hash_table[r1].token_type = TYPE_EPROC;
	//token++;
	r14 = r14 + 1;
	token = r14;
	//TokenIs(TOKEN_PARA_START);
	TokenIs(TOKEN_PARA_START);
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	//TokenIs(TOKEN_PARA_END);
	TokenIs(TOKEN_PARA_END);
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	//if (token != i) {
	if(r14 != r13){
		// We must have more in here!
		//TokenIs(HASH_as+HASH_OFFSET); // The next keyword MUST be 'as';
		TokenIs(HASH_as+HASH_OFFSET);
		//token++;
		r14 = token;
		r14 = r14 + 1;
		token = r14;
		//TokenIs(TOKEN_STRING);
		TokenIs(TOKEN_STRING);
		//token++;
		r14 = token;
		r14 = r14 + 1;
		token = r14;
		//j = 0;
		r5 = 0;
		//k = token_stack[1]-HASH_OFFSET;
		r4 = [r15+8];
		r4 = r4 - HASH_OFFSET;
		k = r4;
		r4 = &hash_table[r4].token_import_name;
		r4 = r4 + 2;
		//while ((token_stack[token] != TOKEN_END_STRING) && (token != i)){
			//hash_table[k].token_import_name[j] = ((unsigned char)token_stack[token] & 0x7f);
			//j++;
			//token++;
		//}
		r0 = 0;
		r1 = [r15+r14*8];
		r2 = TOKEN_END_STRING;
		if(r1 != r2) { if(r14 != r13) { r0 = 1; } }
		while (r0){
			r1 = r1 && 07fh;
			[r4+r5] = r1b;
			r14 = r14 + 1;
			r5 = r5 + 1;
			r0 = 0;
			r1 = [r15+r14*8];
			if(r1 != r2) { if(r14 != r13) { r0 = 1; } }
		}
		token = r14;
		//TokenIs(TOKEN_END_STRING);
		TokenIs(TOKEN_END_STRING);
		//token++;
		r14 = token;
		r14 = r14 + 1;
		token = r14;
		//if (token != i){
		if(r14 != r13){
			// Looks like we are even defining the library name where the extern is located in!
			//TokenIs(HASH_in+HASH_OFFSET);
			TokenIs(HASH_in+HASH_OFFSET);
			//token++;
			r14 = token;
			r14 = r14 + 1;
			token = r14;
			//isHash(token_stack[token]);
			r1 = [r15+r14*8];
			isHash(r1);
			//l = token_stack[token]-HASH_OFFSET;
			r2 = r1 - HASH_OFFSET;
			//if ((hash_table[l].token_type != 0x0)&&(hash_table[l].token_type != TYPE_ELIB))
				//abort_b0("Unable to redefine Label/Token"); 
			r3 = hash_table[r2].token_type;
			r4 = 0;
			if (r3 != r4){
				r4 = TYPE_ELIB;
				if(r3 != r4){
					abort_b0('Unable to redefine Label/Token');
				}
			}
			//token++;
			r14 = r14 + 1;
			token = r14;
			//hash_table[l].token_type = TYPE_ELIB;
			hash_table[r2].token_type = TYPE_ELIB;
			// Now link the extern name to the export library token.
			//hash_table[k].token_import_lib = l;
			r4 = k;
			hash_table[r4].token_import_lib = r2;
			//if (token != i){
			if(r14 != r13){
				// Looks like we are defining the actual DLL name as well.
				//TokenIs(HASH_as+HASH_OFFSET); // The next keyword MUST be 'as';
				TokenIs(HASH_as+HASH_OFFSET);
				//token++;
				r14 = token;
				r14 = r14 + 1;
				token = r14;
				//TokenIs(TOKEN_STRING);
				TokenIs(TOKEN_STRING);
				//token++;
				r14 = token;
				r14 = r14 + 1;
				token = r14;
				//j = 0;
				r5 = 0;
				r4 = &hash_table[r2].token_import_name;
				r4 = r4 + 2;
				//while ((token_stack[token] != TOKEN_END_STRING) && (token != i)){
					//hash_table[l].token_import_name[j] = ((unsigned char)token_stack[token] & 0x7f);
					//j++;
					//token++;
				//}
				r0 = 0;
				r1 = [r15+r14*8];
				r2 = TOKEN_END_STRING;
				if(r1 != r2) { if(r14 != r13) { r0 = 1; } }
				while (r0){
					r1 = r1 && 07fh;
					[r4+r5] = r1b;
					r14 = r14 + 1;
					r5 = r5 + 1;
					r0 = 0;
					r1 = [r15+r14*8];
					if(r1 != r2) { if(r14 != r13) { r0 = 1; } }
				}
				token = r14;				
				//TokenIs(TOKEN_END_STRING);
				TokenIs(TOKEN_END_STRING);
				//token++;
				r14 = token;
				r14 = r14 + 1;
				token = r14;
			//}
			}
		//}
		}
	//};
	}
	//atStackEnd(i);
	atStackEnd(r13);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;	
}

proc process_pushpop_directive(i) {
	push r15, r14, r13, r12, r1;
	//atStackStart();
	atStackStart();
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = code;
	//j = token_stack[0]-HASH_OFFSET;
	r1 = [r15];
	r1 = r1 - HASH_OFFSET;
	//while (token < i){
	while(r14 < r13){
		//TokenIsLabelType(TYPE_REG); // Only allow 64 bit regs
		TokenIsLabelType(TYPE_REG);
		r14 = token;
		//fprintf(code, "\t%s %s\n", hash_table[j].token, hash_table[token_stack[token]-HASH_OFFSET].token);
		echo_string(r12, '\t');
		r0 = &hash_table[r1].token;
		echo_string(r12, r0);
		echo_string(r12, ' ');
		r0 = [r15+r14*8];
		r0 = r0 - HASH_OFFSET;
		r0 = &hash_table[r0].token;
		echo_string(r12, r0);
		echo_cr(r12);
		//token++;
		r14 = r14 + 1;
		token = r14;
		//if (token < i){
		if(r14 < r13){
			//TokenIs(TOKEN_COMMA);
			TokenIs(TOKEN_COMMA);
			//token++;
			r14 = token;
			r14 = r14 + 1;
			token = r14;
		//}
		}
	//}
	}
	//atStackEnd(i);
	atStackEnd(r13);
	pop r1, r12, r13, r14, r15;
};
proc process_inout_directive(i){
	push r15, r14, r13, r12, r2, r1;
	r15 = &token_stack;
	r13 = i;
	r12 = code;
	//atStackStart();
	atStackStart();
	//TokenIs(TOKEN_PARA_START);
	TokenIs(TOKEN_PARA_START);
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	//TokenIsLabelType(TYPE_REG);
	TokenIsLabelType(TYPE_REG);
	//if(token_stack[token] != HASH_r3+HASH_OFFSET)
		//abort_b0("Expected register r3");
	r14 = token;
	r1 = [r15+r14*8];
	r2 = HASH_r3+HASH_OFFSET;
	if(r1 != r2){
		abort_b0('Expected register r3');
	}
	//token++;
	r14 = r14 + 1;
	token = r14;
	//TokenIs(TOKEN_COMMA);
	TokenIs(TOKEN_COMMA);
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	r1 = [r15+r14*8];
	r2 = HASH_r0d+HASH_OFFSET;
	//if((token_stack[token] != HASH_r0+HASH_OFFSET)&&
		//#ifndef i386
		//(token_stack[token] != HASH_r0d+HASH_OFFSET)&&
		//#endif
		//(token_stack[token] != HASH_r0w+HASH_OFFSET)&&
		//(token_stack[token] != HASH_r0b+HASH_OFFSET))
			//abort_b0("Expected register r0");
	if(r1 != r2){
		#ifndef i386;
		r2 = HASH_r0d+HASH_OFFSET;
		#endif;
		if(r1 != r2){
			r2 = HASH_r0w+HASH_OFFSET;
			if(r1 != r2){
				r2 = HASH_r0b+HASH_OFFSET;
				if(r1 != r2){
					abort_b0('Expected register r0d, r0w or r0b');
				}
			}
		}
	}
	r1 = r1 - HASH_OFFSET;
	r2 = &hash_table[r1].token;
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	//TokenIs(TOKEN_PARA_END);
	TokenIs(TOKEN_PARA_END);
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	//atStackEnd(i);
	atStackEnd(r13);
	//if (token_stack[0] == HASH_in+HASH_OFFSET){
		//fprintf(code, "\tin %s, r3w\n", hash_table[token_stack[4]-HASH_OFFSET].token);					
	//} else {
		//fprintf(code, "\tout r3w, %s\n", hash_table[token_stack[4]-HASH_OFFSET].token);
	//}
	r0 = [r15];
	r1 = HASH_in+HASH_OFFSET;
	if(r0 == r1){
		echo_string(r12, '\tin ');
		echo_string(r12, r2);
		echo_string(r12, ', r3w\n');
	} else {
		echo_string(r12, '\tout r3w, ');
		echo_string(r12, r2);
		echo_cr(r12);
	}
	pop r1, r2, r12, r13, r14, r15;
};

proc process_calljmp_directive(i){
	push r1, r2, r3, r12, r13, r14, r15;
	r15 = &token_stack;
	r13 = i;
	r12 = code;
	//atStackStart();
	atStackStart();
	r14 = token;
	r1 = [r15+r14*8];
	r0 = TOKEN_ARRAY_START;
	//if (token_stack[token] == TOKEN_ARRAY_START){
	if (r1 == r0){
		//We must have a global pointer
		//token++;
		r14 = r14 + 1;
		token = r14;
		//fprintf(code, "\t%s [", hash_table[token_stack[0]-HASH_OFFSET].token);
		r1 = [r15];
		r1 = r1 - HASH_OFFSET;
		r1 = &hash_table[r1].token;
		echo_string(r12, '\t');
		echo_string(r12, r1);
		echo_string(r12, ' qword [');
		//Global_Pointer(i);
		Global_Pointer(r13);
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//fprintf(code, "]\n");
		echo_string(r12, ']\n');
		//token++;
		r14 = token;
		r14 = r14 + 1;
		token = r14;
	//} else {
	} else {
		// We should have a reg or a procedure();
		//isHash(token_stack[token]);
		isHash(r1);
		r1 = r1 - HASH_OFFSET;
		r2 = &hash_table[r1].token;
		r3 = hash_table[r1].token_type;
		r0 = TYPE_REG;
		r3 = r3 && r0;
		//if (((hash_table[token_stack[token]-HASH_OFFSET].token_type) & TYPE_REG) == TYPE_REG){
		if(r3 == r0){
			// We MUST have a register
			//TokenIsLabelType(TYPE_REG);
			TokenIsLabelType(r0);
			//fprintf(code, "\t%s %s\n", hash_table[token_stack[0]-HASH_OFFSET].token, hash_table[token_stack[token]-HASH_OFFSET].token);
			echo_string(r12, '\t');
			r0 = [r15];
			r0 = r0 - HASH_OFFSET;
			r0 = &hash_table[r0].token;
			echo_string(r12, r0);
			echo_string(r12, ' ');
			echo_string(r12, r2);
			echo_cr(r12);
			//token++;
			r14 = token;
			r14 = r14 + 1;
			token = r14;
		//} else {
		} else {
			//We should have a e_proc!
			//TokenIsLabelType(TYPE_EPROC);
			TokenIsLabelType(TYPE_EPROC);
			//if (SOURCE_TYPE != SOURCE_PE){
				//fprintf(code, "\t%s %s\n", hash_table[token_stack[0]-HASH_OFFSET].token, hash_table[token_stack[token]-HASH_OFFSET].token);
			//} else {
				//fprintf(code, "\t%s [%s]\n", hash_table[token_stack[0]-HASH_OFFSET].token, hash_table[token_stack[token]-HASH_OFFSET].token);
			//}
			r3 = [r15];
			r3 = r3 - HASH_OFFSET;
			r3 = &hash_table[r3].token;
			r0 = SOURCE_TYPE;
			r1 = SOURCE_PE;
			if(r0 != r1){
				r1 = SOURCE_DLL;
				if(r0 != r1){
					echo_string(r12, '\t');
					echo_string(r12, r3);
					echo_string(r12, ' ');
					echo_string(r12, r2);
					echo_cr(r12);
				} else {
					echo_string(r12, '\t');
					echo_string(r12, r3);
					echo_string(r12, ' [');
					echo_string(r12, r2);
					echo_string(r12, ']\n');				
				}
			} else {
				echo_string(r12, '\t');
				echo_string(r12, r3);
				echo_string(r12, ' [');
				echo_string(r12, r2);
				echo_string(r12, ']\n');
			}
			//token++;
			r14 = token;
			r14 = r14 + 1;
			token = r14;
			//TokenIs(TOKEN_PARA_START);
			TokenIs(TOKEN_PARA_START);
			//token++;
			r14 = token;
			r14 = r14 + 1;
			token = r14;
			//TokenIs(TOKEN_PARA_END);
			TokenIs(TOKEN_PARA_END);
			//token++;
			r14 = token;
			r14 = r14 + 1;
			token = r14;
		//}
		}
	//}
	}
	//atStackEnd(i);
	atStackEnd(r13);
	pop r15, r14, r14, r12, r3, r2, r1;
};
proc process_asm_directive(i){
	push r1, r2, r3, r4, r13, r14, r15;
	r15 = i;
	r13 = code;
	//atStackStart();
	atStackStart();
	//atStackEnd(i);
	atStackEnd(r15);
	//if (ch != '{') // Asm statements are to be followed immediately by a block.
		//abort_b0("{ Expected");
	r0 = ch;
	r1 = 07bh;
	if(r0 != r1){
		abort_b0('{ Expected');
	}
	//getChar();
	getChar();
	r3 = look_ahead_ch;
	r4 = EOF;
	if (r3 == r4){
		abort_b0('Unexpected EOF');
	}
	//asm_in_string = 0;
	r14 = 0;
	r0 = 0;
	r1 = ch;
	r2 = 07dh;
	if (r1 != r2) { r0 = 1; }
	if (r14) { r0 = 1; }
	//while ((ch != '}') || (asm_in_string == 1)){
	while(r0){
		//if ((ch == '/')&&(asm_in_string == 0)) { // Skip comments
		r2 = 02fh;
		r0 = 0;
		if(r1 == r2){
			if(r14 == r0){
				//if (look_ahead_ch == '/'){
				r0 = look_ahead_ch;
				if (r0 == r2){
					r1 = ch;
					r2 = CHAR_LF;
					//while (ch != CR){
						//getChar();
					//}
					while(r1 != r2){
						getChar();
						r1 = ch;
						if (r1 == r4){
							abort_b0('Unexpected EOF');
						}
					}
				//}
				}
			}
		//}
		}
		r1 = ch;
		//fprintf(code, "%c", ch);
		echo_character(r13, r1);
		//getChar();
		getChar();
		if (r1 == r4){
			abort_b0('Unexpected EOF');
		}
		//if (ch == '\'') {
			//if (asm_in_string == 1) {
				//asm_in_string = 0;
			//} else {
				//asm_in_string = 1;
			//}
		//}
		r1 = ch;
		r0 = 27h;
		if(r1 == r0){
			if(r14){
				r14 = 0;
			} else {
				r14 = 1;
			}
		}
		r0 = 0;
		r1 = ch;
		r2 = 07dh;
		if (r1 != r2) { r0 = 1; }
		if (r14) { r0 = 1; }
	//}
	}
	//if(DEBUG)
		//printf("\n");
	r0 = DEBUG;
	if(r0) { echo_cr(STDOUT); }
	//block_level--;
	r0 = block_level;
	r0 = r0 - 1;
	block_level = r0;
	pop r15, r14, r13, r4, r3, r2, r1;
};
proc process_token_block_end(i){
	push r1, r2, r3, r4, r12, r13, r14, r15;
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = DEBUG;
	r11 = TOKEN_BLOCK_END;
	//if(DEBUG)
		//printf("processing TOKEN_END_BLOCK\n");
	if(r12){
		echo_string(STDOUT, 'processing TOKEN_END_BLOCK\n');
	}
	r0 = 0;
	r1 = [r15+r14*8];
	if(r1 == r11) { if (r14 < r13) { r0 = 1; } }
	while(r0){
	//while ((token_stack[token] == TOKEN_BLOCK_END) && (token < i)) {
		//if (DEBUG)
			//printf("token = %d, i = %d\n", token, i);
		if(r12){
			echo_string(STDOUT, 'token = ');
			echo_hex(STDOUT, r14);
			echo_string(STDOUT, ', i = ');
			echo_hex(STDOUT, r13);
			echo_string(STDOUT, '\nCalling END_BLOCK in while\n');
		}
		//if (DEBUG)
			//printf("Calling END_BLOCK in while\n");
		r2 = [r15+r14*8+8];
		r0 = HASH_else+HASH_OFFSET;
		//if (token_stack[token+1] != HASH_else+HASH_OFFSET) {
		if(r2 != r0){
			//end_block();
			end_block();
		//} else {
		} else {
			//end_block_else();
			end_block_else();
			//token++;
			//token++;
			r14 = token;
			r14 = r14 + 2;
			token = r14;
			//atStackEnd(i);		// ELSE must ALWAYS be the last token on the stack
			atStackEnd(r13);
			//if (ch != '{')		// Check for stack termination character!
				//abort_b0("Illformed IF-THEN-ELSE statement");
			r0 = ch;
			r1 = CHAR_OCPARAN;
			if(r0 != r1){
				abort_b0('Illformed IF-THEN-ELSE statement');
			}
		//}
		}
		//token++;
		r14 = token;
		r14 = r14 + 1;
		token = r14;
		r0 = 0;
		r1 = [r15+r14*8];
		if(r1 == r11) { if (r14 < r13) { r0 = 1; } }
	//}
	}
	//if (DEBUG)
		//printf("token = %d, i = %d\n", token, i);
	r14 = token;
	if(r12){
		echo_string(STDOUT, 'token = ');
		echo_hex(STDOUT, r14);
		echo_string(STDOUT, ', i = ');
		echo_hex(STDOUT, r13);
		echo_cr(STDOUT);
	}
	//if (token < i) {
	if(r14 < r13){
		// We have something other than ELSE
		// Becuase most items need to be at the start, we simply remove all
		// block ends, and reprocess as per normal.
		// We lucky becuase token = our first non } character!
		//j = i - token; // make j our count!
		r1 = r13 - r14;
		r2 = 0;
		while(r2 < r1){
		//for (k = 0; k < j; k++){
			// Quick move the stack forward
			//token_stack[k] = token_stack[token];
			r0 = [r15+r14*8];
			[r15+r2*8] = r0;
			//token++;
			r14 = r14 + 1;
			r2 = r2 + 1;
			token = r14;
		//}
		}
		//token = 0;		// Set our stack pointer to 0
		token = 0;
		//i = j;			// Set our new stack size to the count!
		r13 = r1;
	//}
	}
	//break;
	r0 = r13;
	pop r15, r14, r13, r12, r4, r3, r2, r1;
	return(r0);
};
proc process_ifwhile_directive(i){
	push r1, r2, r3, r4, r5, r10, r11, r12, r13, r14, r15;
	r11 = code;
	r13 = i;
	//if_while_block(i);
	if_while_block(r13);
	// Now construct the test!
	r14 = block_level;
	r15 = if_while_stack[r14].if_while_test1;
	r12 = hash_table[r15].token_type;
	r1 = TYPE_FLAG;
	//if (hash_table[if_while_stack[block_level].if_while_test1].token_type == TYPE_FLAG) {
	if(r12 == r1){
		// We have a flag comparison, so this is really easy.
		//switch(if_while_stack[block_level].if_while_test1){
		r0 = HASH_CARRY;
		if(r15 == r0){
			//case HASH_CARRY: fprintf(code, "\tjnc .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjnc .B0_END_BLOCK_0000');
		} else {
		r0 = HASH_NOCARRY;
		if(r15 == r0){
			//case HASH_NOCARRY: fprintf(code, "\tjc .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjc .B0_END_BLOCK_0000');
		} else {
		r0 = HASH_OVERFLOW;
		if(r15 == r0){
			//case HASH_OVERFLOW: fprintf(code, "\tjno .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjno .B0_END_BLOCK_0000');
		} else {
		r0 = HASH_NOOVERFLOW;
		if(r15 == r0){
			//case HASH_NOOVERFLOW: fprintf(code, "\tjo .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjo .B0_END_BLOCK_0000');
		} else {
		r0 = HASH_PARITY;
		if(r15 == r0){
			//case HASH_PARITY: fprintf(code, "\tjnp .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjnp .B0_END_BLOCK_0000');
		} else {
		r0 = HASH_NOPARITY;
		if(r15 == r0){
			//case HASH_NOPARITY: fprintf(code, "\tjp .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjp .B0_END_BLOCK_0000');
		} else {
		r0 = HASH_ZERO;
		if(r15 == r0){
			//case HASH_ZERO: 	fprintf(code, "\tjnz .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjnz .B0_END_BLOCK_0000');
		} else {
		r0 = HASH_NOTZERO;
		if(r15 == r0){
			//case HASH_NOTZERO: fprintf(code, "\tjz .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjz .B0_END_BLOCK_0000');
		} else {
		r0 = HASH_SIGN;
		if(r15 == r0){
			//case HASH_SIGN: 	fprintf(code, "\tjns .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjns .B0_END_BLOCK_0000');
		} else {
		r0 = HASH_NOTSIGN;
		if(r15 == r0){
			//case HASH_NOTSIGN: fprintf(code, "\tjs .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
			echo_string(r11, '\tjs .B0_END_BLOCK_0000');
		} else {
			//default: abort_b0("Unknown CPU FLAG"); break;
			abort_b0('Unknown CPU FLAG');
		}}}}}}}}}}
		r0 = if_while_stack[r14].offset;
		echo_hex(r11, r0);
		echo_cr(r11);
	//} else {
	} else {
		// Lets see if this is a FPU or INT operation.
		r1 = TYPE_REG;
		//if (hash_table[if_while_stack[block_level].if_while_test1].token_type == TYPE_REG) {
		if(r12 == r1){
			// Int test
			//if ((hash_table[if_while_stack[block_level].if_while_test2].token_type != TYPE_REG) && (if_while_stack[block_level].if_while_test2 != HASH_zero))
				//abort_b0("Second operand MUST be a integer register");
			r2 = if_while_stack[r14].if_while_test2;
			r3 = hash_table[r2].token_type;
			r4 = HASH_zero;
			if(r3 != r1){
				if(r2 != r4){
					abort_b0('Second operand MUST be a integer register');
				}
			}
			//if (if_while_stack[block_level].if_while_test2 != HASH_zero) {
			r11 = code;
			//fprintf(code, "\tcmp %s, %s\n", hash_table[if_while_stack[block_level].if_while_test1].token, hash_table[if_while_stack[block_level].if_while_test2].token );
			echo_string(r11, '\tcmp ');
			r0 = &hash_table[r15].token;
			echo_string(r11, r0);
			echo_string(r11, ', ');
			r0 = &hash_table[r2].token;
			echo_string(r11, r0);
			echo_cr(r11);

			//switch (if_while_stack[block_level].comparison) {
			r0 = if_while_stack[r14].comparison;
			r1 = TOKEN_EQUALS;
			if (r0 == r1){
				//case TOKEN_EQUALS :	fprintf(code, "\tjne .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjne .B0_END_BLOCK_0000');
			} else {
			r1 = TOKEN_NOTEQUALS;
			if(r0 == r1){
				//case TOKEN_NOTEQUALS : fprintf(code, "\tje .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tje .B0_END_BLOCK_0000');
			} else {
			r1 = TOKEN_LESSTHAN;
			if(r0 == r1){
				//case TOKEN_LESSTHAN : fprintf(code, "\tjae .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjae .B0_END_BLOCK_0000');
			} else {
			r1 = TOKEN_GREATERTHAN;
			if(r0 == r1){
				//case TOKEN_GREATERTHAN : fprintf(code, "\tjbe .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjbe .B0_END_BLOCK_0000');
			} else {
			r1 = TOKEN_LESSTHANEQUALS;
			if(r0 == r1){
				//case TOKEN_LESSTHANEQUALS : fprintf(code, "\tja .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tja .B0_END_BLOCK_0000');
			} else {
			r1 = TOKEN_GREATERTHANEQUALS;
			if(r0 == r1){
				//case TOKEN_GREATERTHANEQUALS : fprintf(code, "\tjb .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjb .B0_END_BLOCK_0000');
			} else {
			r1 = TOKEN_S_LESSTHAN;
			if(r0 == r1){
				//case TOKEN_S_LESSTHAN : fprintf(code, "\tjge .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjge .B0_END_BLOCK_0000');
			} else {
			r1 = TOKEN_S_GREATERTHAN;
			if(r0 == r1){
				//case TOKEN_S_GREATERTHAN : fprintf(code, "\tjle .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjle .B0_END_BLOCK_0000');
			} else {
			r1 = TOKEN_S_LESSTHANEQUALS;
			if(r0 == r1){
				//case TOKEN_S_LESSTHANEQUALS : fprintf(code, "\tjg .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjg .B0_END_BLOCK_0000');
			} else {
			r1 = TOKEN_S_GREATERTHANEQUALS;
			if(r0 == r1){
				//case TOKEN_S_GREATERTHANEQUALS : fprintf(code, "\tjl .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjl .B0_END_BLOCK_0000');
			}}}}}}}}}}
			//}
			r0 = if_while_stack[r14].offset;
			echo_hex(r11, r0);
			echo_cr(r11);
		//} else {
		} else {
			// FPU test
			r15 = if_while_stack[r14].if_while_test1;
			r2 = if_while_stack[r14].if_while_test2;
			r4 = HASH_zero;

			//if (if_while_stack[block_level].if_while_test2 != HASH_zero){
			if(r2 != r4){
				//if (if_while_stack[block_level].if_while_test1 != HASH_fp0)
					//abort_b0("Floating point comparison requires that fp0 be the first operand");
				r1 = HASH_fp0;
				if(r15 != r1){
					abort_b0('Floating point comparison requires that fp0 be the first operand');
				}
				// Non-zero test
				//if (hash_table[if_while_stack[block_level].if_while_test2].token_type != TYPE_REG_FPU)
					//abort_b0("Second operand MUST be a FPU register");
				r10 = hash_table[r2].token_type;
				r4 = TYPE_REG_FPU;
				if(r10 != r4){
					abort_b0('Second operand MUST be a FPU register');
				}
				//fprintf(code, "\tfcomi %s\n", hash_table[if_while_stack[block_level].if_while_test2].token );
				r11 = code;
				r10 = &hash_table[r2].token;
				echo_string(r11, '\tfcomi ');
				echo_string(r11, r10);
				echo_cr(r11);
			//} else {
			} else {
				// Handle test against zero
				//if (hash_table[if_while_stack[block_level].if_while_test1].token_type != TYPE_REG_FPU)
					//abort_b0("Operand MUST be a register");
				r1 = TYPE_REG_FPU;
				if(r12 != r1){
					abort_b0('Operand MUST be a register');
				}
				//fprintf(code, "\tfldz\n\tfcomip ");
				r11 = code;
				echo_string(r11, '\tfldz\n\tfcomip ');
				//switch(if_while_stack[block_level].if_while_test1){
				r0 = HASH_fp0;
				if(r15 == r0){
					//case HASH_fp0: fprintf(code, "fp1\n"); break;
					echo_string(r11, 'fp1\n');
				} else {
				r0 = HASH_fp1;
				if(r15 == r0){
					//case HASH_fp1: fprintf(code, "fp2\n"); break;
					echo_string(r11, 'fp2\n');
				} else {
				r0 = HASH_fp2;
				if(r15 == r0){
					//case HASH_fp2: fprintf(code, "fp3\n"); break;
					echo_string(r11, 'fp3\n');
				} else {
				r0 = HASH_fp3;
				if(r15 == r0){
					//case HASH_fp3: fprintf(code, "fp4\n"); break;
					echo_string(r11, 'fp4\n');
				} else {
				r0 = HASH_fp4;
				if(r15 == r0){
					//case HASH_fp4: fprintf(code, "fp5\n"); break;
					echo_string(r11, 'fp5\n');
				} else {
				r0 = HASH_fp5;
				if(r15 == r0){
					//case HASH_fp5: fprintf(code, "fp6\n"); break;
					echo_string(r11, 'fp6\n');
				} else {
				r0 = HASH_fp6;
				if(r15 == r0){
					//case HASH_fp6: fprintf(code, "fp7\n"); break;
					echo_string(r11, 'fp7\n');
				} else {
				r0 = HASH_fp7;
				if(r15 == r0){
					//case HASH_fp7: abort_b0("Error FPU stack overflow in IF-THEN construct"); break;
					abort_b0('Error FPU stack overflow in IF-THEN construct');
				}}}}}}}}
				//}
			}
			//fprintf(code, "\tje .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset);
			r1 = if_while_stack[r14].comparison;
			r0 = TOKEN_EQUALS;
			if(r1 == r0){
				//case TOKEN_EQUALS :	fprintf(code, "\tjne .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjne .B0_END_BLOCK_0000');
			} else {
			r0 = TOKEN_NOTEQUALS;
			if(r1 == r0){
				//case TOKEN_NOTEQUALS : fprintf(code, "\tje .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tje .B0_END_BLOCK_0000');
			} else {
			r0 = TOKEN_LESSTHAN;
			if(r1 == r0){
				//case TOKEN_LESSTHAN : fprintf(code, "\tjae .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjae .B0_END_BLOCK_0000');
			} else {
			r0 = TOKEN_GREATERTHAN;
			if(r1 == r0){
				//case TOKEN_GREATERTHAN : fprintf(code, "\tjbe .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjbe .B0_END_BLOCK_0000');
			} else {
			r0 = TOKEN_LESSTHANEQUALS;
			if(r1 == r0){
				//case TOKEN_LESSTHANEQUALS : fprintf(code, "\tja .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tja .B0_END_BLOCK_0000');
			} else {
			r0 = TOKEN_GREATERTHANEQUALS;
			if(r1 == r0){
				//case TOKEN_GREATERTHANEQUALS : fprintf(code, "\tjb .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjb .B0_END_BLOCK_0000');
			} else {
			r0 = TOKEN_S_LESSTHAN;
			if(r1 == r0){
				//case TOKEN_S_LESSTHAN : fprintf(code, "\tjae .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjae .B0_END_BLOCK_0000');
			} else {
			r0 = TOKEN_S_GREATERTHAN;
			if(r1 == r0){
				//case TOKEN_S_GREATERTHAN : fprintf(code, "\tjbe .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjbe .B0_END_BLOCK_0000');
			} else {
			r0 = TOKEN_S_LESSTHANEQUALS;
			if(r1 == r0){
				//case TOKEN_S_LESSTHANEQUALS : fprintf(code, "\tja .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tja .B0_END_BLOCK_0000');
			} else {
			r0 = TOKEN_S_GREATERTHANEQUALS;
			if(r1 == r0){
				//case TOKEN_S_GREATERTHANEQUALS : fprintf(code, "\tjb .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset); break;
				echo_string(r11, '\tjb .B0_END_BLOCK_0000');
			}}}}}}}}}}
			r0 = if_while_stack[r14].offset;
			echo_hex(r11, r0);
			echo_cr(r11);
		//}
		}
	//}
	}
	//if ((token_stack[0]-HASH_OFFSET) == HASH_while) 	// Now set the return point.
		//fprintf(code, "\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1));
	r15 = &token_stack;
	r0 = [r15];
	r1 = HASH_while+HASH_OFFSET;
	if(r0 == r1){
		r11 = code;
		echo_string(r11, '\t.B0_END_BLOCK_0000');
		r0 = block_level;
		r1 = if_while_stack[r0].offset;
		r1 = r1 - 1;
		echo_hex(r11, r1);
		echo_string(r11, ':\n');
	}
	//break;
	pop r15, r14, r13, r12, r11, r10, r5, r4, r3, r2, r1;
};

proc process_iflock_directive(i) {
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r15 = code;
	r14 = &token_stack;
	r13 = token;
	r12 = i;
	r11 = DEBUG;
	//atStackStart();
	atStackStart();
	if(r11){ echo_string(STDOUT, 'If can get mutex\n'); }
	r1 = CHAR_OCPARAN;
	r0 = ch;
	if (r0 != r1){
		abort_b0('{ Expected');
	}
	r3 = HASH_if;
	r10 = block_level;
	if_while_stack[r10].type = r3;
	r4 = block_num;
		
	//if_while_stack[block_level].offset = block_num;
	if_while_stack[r10].offset = r4;
	
	r13 = r13 + 1;
	token = r13;
	
	//TokenIs(TOKEN_PARA_START);
	TokenIs(TOKEN_PARA_START);
	//token++; // Lets see what we are testing?
	r13 = token;
	r13 = r13 + 1;
	token = r13;
	//if (token_stack[token] == TOKEN_PARA_END) 
		//abort_b0("Unexpected ')'");
	r1 = [r14+r13*8];
	r0 = TOKEN_PARA_END;
	if (r0 == r1){
		abort_b0('Unexpected \')\'');
	}
	
	// Dummy up the if_while_stack;
	r2 = HASH_zero;
	if_while_stack[r10].if_while_test1 = r2;
	if_while_stack[r10].if_while_test2 = r2;
	r2 = TOKEN_NOTEQUALS;
	if_while_stack[r10].comparison = r2;	

	// We should have either a '[' or a reg;
	r0 = TOKEN_ARRAY_START;
	if(r0 == r1){
		// We have a general pointer;
		if(r11){ echo_string(STDOUT, 'Locking mutex - General Pointer\n'); }
		echo_string(r15, '\tpush r6\n\tpush r0\n\tpush r1\n\tlea r1, [');
		//token++;	//Increase token pointer;
		r13 = r13 + 1;
		token = r13;
		//Global_Pointer(i);
		Global_Pointer(r12);
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//fprintf(code, "], ");
		echo_string(r15, ']\n\tmov r6, 1\n\txor r0, r0\n\tlock cmpxchg [r1], r6\n\tpop r1\n\tpop r0\n\tpop r6\n\tjnz .B0_END_BLOCK_0000');
		// We jump forward.
		echo_hex(r15, r4);
		echo_cr(r15);
	} else {
		// We should have a reg;
		isHash(r1);
		r2 = r1 - HASH_OFFSET;
		// We better have a REG
		if(r11){ echo_string(STDOUT, 'Attempt Locking mutex - Single Register Pointer\n'); }
		TokenIsLabelType(TYPE_REG);
		r1 = HASH_r6;
		if(r1 == r2){
			// memory address is r6, so use r15 as test reg.
			r1 = &hash_table[HASH_r15].token;
		} else {
			r1 = HASH_r0;
			if(r2 == r1){
				// Our memory address is r0;
				r3 = r2;
				r2 = HASH_r1;
				echo_string(r15, '\tpush r1\n\tmov r1, r0\n');
			}
			r1 = &hash_table[HASH_r6].token;
		}
		r2 = &hash_table[r2].token;
		echo_string(r15, '\tpush ');
		echo_string(r15, r1);
		echo_string(r15, '\n\tpush r0\n\txor r0, r0\n\tmov ');
		echo_string(r15, r1);
		echo_string(r15, ', 1\n\tlock cmpxchg [');
		echo_string(r15, r2);
		echo_string(r15, '], ');
		echo_string(r15, r1);
		echo_string(r15, '\n\tpop r0\n\tpop ');
		echo_string(r15, r1);
		echo_cr(r15);
		r0 = HASH_r0;
		if(r3 == r0){
			echo_string(r15, '\tpop r1\n');
		}
		echo_string(r15, '\tjnz .B0_END_BLOCK_0000');
		// We jump forward.
		echo_hex(r15, r4);
		echo_cr(r15);

	}
	r13 = token;
	r13 = r13 + 1;
	token = r13;
	TokenIs(TOKEN_PARA_END);
	r13 = r13 + 1;
	token = r13;
	atStackEnd(r13);	
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};

proc process_lock_directive(i) {
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r15 = code;
	r14 = &token_stack;
	r13 = token;
	r12 = i;
	r11 = DEBUG;
	//atStackStart();
	atStackStart();
	if(r11){ echo_string(STDOUT, 'Locking mutex - spinlock\n'); }
	TokenIs(TOKEN_PARA_START);
	r13 = token;
	r13 = r13 + 1;
	token = r13;
	r1 = [r14+r13*8];
	r0 = TOKEN_ARRAY_START;
	if(r1 == r0){
		// We have a general pointer;
		if(r11){ echo_string(STDOUT, 'Locking mutex - General Pointer\n'); }
		echo_string(r15, '\tpush r6\n\tpush r0\n\tpush r1\n\tlea r1, [');
		//token++;	//Increase token pointer;
		r13 = r13 + 1;
		token = r13;
		//Global_Pointer(i);
		Global_Pointer(r12);
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//fprintf(code, "], ");
		echo_string(r15, ']\n\t@@:\n\tmov r6, 1\n\txor r0, r0\n\tlock cmpxchg [r1], r6\n\tjnz @b\n\tpop r1\n\tpop r0\n\tpop r6\n');
	} else {
		// We should have a reg;
		isHash(r1);
		r2 = r1 - HASH_OFFSET;
		// We better have a REG
		if(r11){ echo_string(STDOUT, 'Locking mutex - Single Register Pointer\n'); }
		TokenIsLabelType(TYPE_REG);
		r1 = HASH_r6;
		if(r1 == r2){
			// memory address is r6, so use r15 as test reg.
			r1 = &hash_table[HASH_r15].token;
		} else {
			r1 = HASH_r0;
			if(r2 == r1){
				// Our memory address is r0;
				r3 = r2;
				r2 = HASH_r1;
				echo_string(r15, '\tpush r1\n\tmov r1, r0\n');
			}
			r1 = &hash_table[HASH_r6].token;
		}
		r2 = &hash_table[r2].token;  // This is our memory address.
		echo_string(r15, '\tpush ');
		echo_string(r15, r1);
		echo_string(r15, '\n\tpush r0\n\t@@:\n\txor r0, r0\n\tmov ');
		echo_string(r15, r1);
		echo_string(r15, ', 1\n\tlock cmpxchg [');
		echo_string(r15, r2);
		echo_string(r15, '], ');
		echo_string(r15, r1);
		echo_string(r15, '\n\tjnz @b\n\tpop r0\n\tpop ');
		echo_string(r15, r1);
		echo_string(r15, '\n');
		r0 = HASH_r0;
		if(r3 == r0){
			echo_string(r15, '\tpop r1\n');
		}
	}
	r13 = token;
	r13 = r13 + 1;
	token = r13;
	TokenIs(TOKEN_PARA_END);
	r13 = r13 + 1;
	token = r13;
	atStackEnd(r13);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};

proc process_unlock_directive(i) {
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r15 = code;
	r14 = &token_stack;
	r13 = token;
	r12 = i;
	r11 = DEBUG;
	//atStackStart();
	atStackStart();
	if(r11){ echo_string(STDOUT, 'Unlocking mutex\n'); }
	TokenIs(TOKEN_PARA_START);
	r13 = token;
	r13 = r13 + 1;
	token = r13;
	r1 = [r14+r13*8];
	r0 = TOKEN_ARRAY_START;
	if(r1 == r0){
		// We have a general pointer;
		if(r11){ echo_string(STDOUT, 'Unlocking mutex - General Pointer\n'); }
		echo_string(r15, '\tpush r6\n\txor r6, r6\n\tmov [');
		//token++;	//Increase token pointer;
		r13 = r13 + 1;
		token = r13;
		//Global_Pointer(i);
		Global_Pointer(r12);
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//fprintf(code, "], ");
		echo_string(r15, '], r6\n\tpop r6\n');		
	} else {
		// We should have a reg;
		isHash(r1);
		r2 = r1 - HASH_OFFSET;
		// We better have a REG
		if(r11){ echo_string(STDOUT, 'Unlocking mutex - Single Register Pointer\n'); }
		TokenIsLabelType(TYPE_REG);
		r1 = HASH_r6;
		if(r1 == r2){
			r1 = &hash_table[HASH_r15].token;
		} else {
			r1 = &hash_table[HASH_r6].token;
		}
		r2 = &hash_table[r2].token;
		echo_string(r15, '\tpush ');
		echo_string(r15, r1);
		echo_string(r15, '\n\txor ');
		echo_string(r15, r1);
		echo_string(r15, ', ');
		echo_string(r15, r1);
		echo_string(r15, '\n\tmov [');
		echo_string(r15, r2);
		echo_string(r15, '], ');
		echo_string(r15, r1);
		echo_string(r15, '\n\tpop ');
		echo_string(r15, r1);
		echo_string(r15, '\n');
	}
	r13 = token;
	r13 = r13 + 1;
	token = r13;
	TokenIs(TOKEN_PARA_END);
	r13 = r13 + 1;
	token = r13;
	atStackEnd(r13);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};

proc process_proc_directive(i){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = DEBUG;
	//atStackStart();
	atStackStart();
	//if(DEBUG)
		//printf("Defining proc2\n");
	if(r12){ echo_string(STDOUT, 'Defining proc1\n'); }
	//if (ch != '{')	// Proc decl statements are to be followed immediately by a block.
		//abort_b0("{ Expected");
	r0 = ch;
	r1 = CHAR_OCPARAN;
	if(r0 != r1){
		abort_b0('{ Expected');
	}
	//isHash(token_stack[token]);
	r14 = token;
	r1 = [r15+r14*8];
	isHash(r1);
	//if (global != 0) 
		//abort_b0("Unable to nest proc definitions");
	r0 = global;
	r2 = 0;
	if(r0 != r2){ 
		r2 = global;
		r2 = r2 - HASH_OFFSET;
		r1 = &hash_table[r2].token;
		echo_string(STDOUT, 'Global = ');
		echo_string(STDOUT, r1);
		echo_cr(STDOUT);
		abort_b0('Unable to nest proc definitions'); 
	}
	//global = token_stack[token];
	global = r1;
	//if (hash_table[(global-HASH_OFFSET)].token_type == 0) {
		//hash_table[(global-HASH_OFFSET)].token_type = TYPE_PROC;
	//} else {
		//abort_b0("Unable to redeclare procedure?");
	//}
	r2 = r1 - HASH_OFFSET;
	r0 = 0;
	r3 = hash_table[r2].token_type;
	if(r3 == r0){
		hash_table[r2].token_type = TYPE_PROC;
		hash_table[r4].token_import_lib = 0;
	} else {
		abort_b0('Unable to redeclare procedure?');
	}
	r3 = &hash_table[r2].token;
	//fprintf(code, "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
	//fprintf(code, "; %s Function Code;\n", hash_table[(global-HASH_OFFSET)].token);
	//fprintf(code, ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n");				
	//fprintf(data, "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
	//fprintf(data, "; %s Function Variables ;\n", hash_table[(global-HASH_OFFSET)].token);
	//fprintf(data, ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n");
	//fprintf(bss,  "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
	//fprintf(bss,  "; %s Function BSS Variables ;\n", hash_table[(global-HASH_OFFSET)].token);
	//fprintf(bss,  ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n");
	//fprintf(code, "align 8\n");
	//fprintf(code, "_B0_%s:\n", hash_table[(global-HASH_OFFSET)].token);
	r11 = code;
	echo_string(r11, '\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; ');
	echo_string(r11, r3);
	echo_string(r11, ' Function Code ;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\nalign 8\n_B0_');
	echo_string(r11, r3);
	echo_string(r11, ':\n');
	r11 = data;
	echo_string(r11, '\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; ');
	echo_string(r11, r3);
	echo_string(r11, ' Function Variables ;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n');
	r11 = bss;
	echo_string(r11, '\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; ');
	echo_string(r11, r3);
	echo_string(r11, ' Function BSS Variables ;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n');
	//local_var_offset = 0;

	//if(DEBUG)
		//printf("Defining proc2\n");
	if(r12) { echo_string(STDOUT, 'Defining proc - '); echo_string(STDOUT, r3); echo_cr(STDOUT); }

	local_var_offset = 0;
	// Now clean up the hash table of all local variables.
	r1 = 0;
	r2 = HASH_TABLE_SIZE;
	//for (j = 0; j < HASH_TABLE_SIZE; j++) {
	while(r1 < r2){
		r3 = hash_table[r1].token_type;
		r3 = r3 && TYPE_LOCAL;
		//if ((hash_table[j].token_type & (TYPE_LOCAL)) > 0 ){
		if(r3){
			//if(DEBUG)
				//printf("Erasing 0x%x -> 0x%lx = %s ,Type: 0x%x\n", j, hash_table[j].hash, hash_table[j].token, hash_table[j].token_type);
			if(r12){
				echo_string(STDOUT, 'Erasing ');
				echo_hex(STDOUT, r1);
				echo_string(STDOUT, ' -> ');
				r0 = hash_table[r1].hash;
				echo_hex(STDOUT, r0);
				echo_string(STDOUT, ' = ');
				r0 = &hash_table[r1].token;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, ' ,Type: ');
				r0 = hash_table[r1].token_type;
				echo_hex(STDOUT, r0);
				echo_cr(STDOUT);
			}
			//hash_table[j].token_type = 0;
			hash_table[r1].token_type = 0;
			//hash_table[j].local_offset = 0;
			hash_table[r1].local_offset = 0;

			//hash_table[r1].hash = 0;
			//r0 = &hash_table[r1].token;
			//[r0] = 0;
			//hash_table[r1].define_int = 0;
			//hash_table[r1].struc_ptr = 0;
		//}
		}
		r1 = r1 + 1;
	//};
	}
	// Now process the parameters
	// token should be on the proc
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	// move to the first para?
	//TokenIs(TOKEN_PARA_START);
	TokenIs(TOKEN_PARA_START);
	//token++; // Lets see what we are testing?
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	r1 = [r15+r14*8];
	r2 = TOKEN_PARA_END;
	//if (token_stack[token] == TOKEN_PARA_END) {
	if (r1 == r2){
		// I guess we have no parameters.
		//token++;
		//r14 = r14 + 1;
		//token = r14;
		//atStackEnd(i);
		//atStackEnd(r13);
		//hash_table[(global-HASH_OFFSET)].local_offset = local_var_offset;
		r0 = global;
		r0 = r0 - HASH_OFFSET;
		r1 = local_var_offset;
		hash_table[r0].local_offset = r1;
		//if(DEBUG)
			//printf("Proc defined - no variables\n");
		//break;	// Let's get outa here!
		if(r12){
			echo_string(STDOUT, 'Proc defined - no variables\n');
		} 
		//pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
		//return();
	} else {
	//}
		// Alrightly all proc parameters are type m64 so this going to be a bit easier?
		//while(token_stack[token] != TOKEN_PARA_END) {
		while(r1 != r2){
			//IsLabelAllocated();
			IsLabelAllocated();
			//#ifndef i386
			//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M64+TYPE_LOCAL;
			//#else
			//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M32+TYPE_LOCAL;
			//#endif
			r3 = [r15+r14*8];
			r3 = r3 - HASH_OFFSET;
			#ifndef i386;
			hash_table[r3].token_type = TYPE_M64+TYPE_LOCAL;
			#else;
			hash_table[r3].token_type = TYPE_M32+TYPE_LOCAL;
			#endif;
			//hash_table[(global-HASH_OFFSET)].local_offset = local_var_offset;
			r4 = local_var_offset;
			r5 = global;
			r5 = r5 - HASH_OFFSET;
			hash_table[r5].local_offset = r4;
			//fprintf(data, "_B0_%s_%s equ %d\n", hash_table[(global-HASH_OFFSET)].token, hash_table[(token_stack[token]-HASH_OFFSET)].token , local_var_offset);
			r11 = data;
			echo_string(r11, '_B0_');
			r0 = &hash_table[r5].token;
			echo_string(r11, r0);
			echo_string(r11, '_');
			r0 = &hash_table[r3].token;
			echo_string(r11, r0);
			echo_string(r11, ' equ ');
			echo_hex(r11, r4);
			echo_cr(r11);
		//#ifndef i386
			//local_var_offset += 8;
		//#else
			//local_var_offset += 4;
		//#endif
			#ifndef i386;
			r4 = r4 + 8;
			#else;
			r4 = r4 + 4;
			#endif;
			local_var_offset = r4;
			//token++;
			r14 = r14 + 1;
			token = r14;
			r1 = [r15+r14*8];
			r8 = TOKEN_COMMA;
			//if(token_stack[token] == TOKEN_COMMA)
				//token++;
			if(r1 == r8){
				r14 = r14 + 1;
				token = r14;
				r1 = [r15+r14*8];
			}
		//}
		}
	}
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	// Let's see if we are defining a proc which can be called externally.
	if(r14 != r13){
		TokenIs(HASH_OFFSET+HASH_as);
		r14 = r14 + 1;
		token = r14;
		if(r12){
			echo_string(STDOUT, 'Defining proc as external\n');
		}
		TokenIs(TOKEN_STRING);
		r14 = r14 + 1;
		token = r14;
		// We now have the start of the string.
		// make r8 = to our string destination.
		r4 = token_stack[1];		
		r4 = r4 - HASH_OFFSET;						// r4 is our hash
		hash_table[r4].token_import_lib = TYPE_EPROC;
		r8 = &hash_table[r4].token_import_name;		// r8 now points to our string.
		r8 = r8 + 2;
		r1 = TOKEN_END_STRING;
		r0 = [r15+r14*8];
		while (r0 != r1){
			// Copy string to DLL Filename;
			[r8] = r0;
			r8 = r8 + 1;
			r14 = r14 + 1;
			token = r14;
			r0 = [r15+r14*8];
		}
		r0 = 0;
		[r8] = r0;	// Null terminate the string
		r14 = r14 + 1;
		token = r14;	// skip the TOKEN_END_STRING.
		if(r12){
			echo_string(STDOUT, 'Proc "');
			r8 = &hash_table[r4].token;
			echo_string(STDOUT, r8);
			echo_string(STDOUT, '" to be exported as "');
			r8 = &hash_table[r4].token_import_name;
			echo_string(STDOUT, r8);
			echo_string(STDOUT, '"\n');
		}
	}
	//atStackEnd(i);
	atStackEnd(r13);
	//if(DEBUG)
		//printf("Proc defined - variables defined\n");
	if(r12){
		echo_string(STDOUT, 'Proc defined - variables defined\n');
	}
	//break;
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};
proc process_data_directive(i){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = DEBUG;
	r11 = global;
	r10 = &token_buffer;
	r9 = toki;
	//if(DEBUG)
		//printf("Processing Variable Def\n");
	if(r12){
		echo_string(STDOUT, 'Processing Variable Def\n');
	}
	//atStackStart();
	atStackStart();
	r14 = token;
	r0 = 0;
	//if (global == 0) {
	if(r11 == r0){
		//if (token_stack[token] == TOKEN_ARRAY_START) {
		r1 = [r15+r14*8];
		r2 = TOKEN_ARRAY_START;
		if (r1 == r2){
			r14 = r14 + 1;
			token = r14;
			TokenIs(TOKEN_NUM_INTEGER);
			r10 = [r15+r14*8+8];
			r14 = r14 + 2;
			token = r14;
			TokenIs(TOKEN_ARRAY_END);
			//token++; // Skip end of array size indicator.
			r14 = r14 + 1;
			token = r14;
			//isHash(token_stack[token]);
			r2 = [r15+r14*8];
			isHash(r2);
			r8 = bss;
			r2 = r2 - HASH_OFFSET;
			r3 = &hash_table[r2].token;
			IsLabelAllocated();
			echo_string(r8, '_B0_');
			echo_string(r8, r3);
			r0 = [r15];
			r1 = HASH_m8+HASH_OFFSET;
			//switch (token_stack[0]) {
			if(r0 == r1){
				//case HASH_m8+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rb %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token , token_buffer);
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M8+TYPE_ARRAY+TYPE_GLOBAL;
					//break;
				echo_string(r8, ' rb ');
				hash_table[r2].token_type = TYPE_M8+TYPE_ARRAY+TYPE_GLOBAL;
			} else {
			
			r1 = HASH_m16+HASH_OFFSET;
			if (r0 == r1){
				//case HASH_m16+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rw %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token, token_buffer );
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M16+TYPE_ARRAY+TYPE_GLOBAL;
					//break;
				echo_string(r8, ' rw ');
				hash_table[r2].token_type = TYPE_M16+TYPE_ARRAY+TYPE_GLOBAL;
			} else {
			
			r1 = HASH_m32+HASH_OFFSET;
			if (r0 == r1){
				//case HASH_m32+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rd %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token, token_buffer );
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M32+TYPE_ARRAY+TYPE_GLOBAL;
					///break;
				echo_string(r8, ' rd ');
				hash_table[r2].token_type = TYPE_M32+TYPE_ARRAY+TYPE_GLOBAL;
			} else {
			
			#ifndef i386;
			r1 = HASH_m64+HASH_OFFSET;
			#else;
			r1 = HASH_m32+HASH_OFFSET;
			#endif;
			if (r0 == r1){
			//#ifndef i386
				//case HASH_m64+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rq %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token, token_buffer );
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M64+TYPE_ARRAY+TYPE_GLOBAL;
					//break;
			//#endif
				echo_string(r8, ' rq ');
				hash_table[r2].token_type = TYPE_M64+TYPE_ARRAY+TYPE_GLOBAL;
			} else {
			
			r1 = HASH_f32+HASH_OFFSET;
			if (r0 == r1){
				//case HASH_f32+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rd %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token, token_buffer );
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F32+TYPE_ARRAY+TYPE_GLOBAL;
					//break;
				echo_string(r8, ' rd ');
				hash_table[r2].token_type = TYPE_F32+TYPE_ARRAY+TYPE_GLOBAL;
			} else {
			
			r1 = HASH_f64+HASH_OFFSET;
			if (r0 == r1){
				//case HASH_f64+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rq %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token, token_buffer );
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F64+TYPE_ARRAY+TYPE_GLOBAL;
					//break;
				echo_string(r8, ' rq ');
				hash_table[r2].token_type = TYPE_F64+TYPE_ARRAY+TYPE_GLOBAL;
			} else {

			r1 = HASH_f80+HASH_OFFSET;
			if (r0 == r1){
				//case HASH_f64+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rq %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token, token_buffer );
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F64+TYPE_ARRAY+TYPE_GLOBAL;
					//break;
				echo_string(r8, ' rt ');
				hash_table[r2].token_type = TYPE_F80+TYPE_ARRAY+TYPE_GLOBAL;
			} else {
			
			r1 = HASH_v4i+HASH_OFFSET;
			if (r0 == r1){
				//case HASH_f64+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rq %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token, token_buffer );
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F64+TYPE_ARRAY+TYPE_GLOBAL;
					//break;
				echo_string(r8, ' rq 2*');
				hash_table[r2].token_type = TYPE_V4I+TYPE_ARRAY+TYPE_GLOBAL;
			} else {
			
			r1 = HASH_v4f+HASH_OFFSET;
			if (r0 == r1){
				//case HASH_f64+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rq %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token, token_buffer );
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F64+TYPE_ARRAY+TYPE_GLOBAL;
					//break;
				echo_string(r8, ' rq 2*');
				hash_table[r2].token_type = TYPE_V4F+TYPE_ARRAY+TYPE_GLOBAL;
			} else {
			
			r1 = HASH_v2f+HASH_OFFSET;
			if (r0 == r1){
				//case HASH_f80+HASH_OFFSET :
					//fprintf(bss, "_B0_%s rt %s\n", hash_table[(token_stack[token]-HASH_OFFSET)].token, token_buffer );
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F80+TYPE_ARRAY+TYPE_GLOBAL;
					//break;
				echo_string(r8, ' rq 2*');
				hash_table[r2].token_type = TYPE_V2F+TYPE_ARRAY+TYPE_GLOBAL;
			}}}}}}}}}}
			//}
			//token++;
			echo_integer(r8, r10);
			echo_cr(r8);

			r14 = token;
			r14 = r14 + 1;
			token = r14;
			//atStackEnd(i);
			atStackEnd(r13);
		//} else {
		} else {
			//isHash(token_stack[token]);
			r2 = [r15+r14*8];
			isHash(r2);
			r2 = r2 - HASH_OFFSET;
			r3 = &hash_table[r2].token;
			r1 = r14 - 1;
			r0 = [r15+r1*8];
			r1 = HASH_m8+HASH_OFFSET;
			
			//switch (token_stack[token-1]) {
			if(r0 == r1){
				//case HASH_m8+HASH_OFFSET :
					//if ((token+1)!=i){
						//fprintf(data, "_B0_%s db ", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//} else {
						//fprintf(bss, "_B0_%s rb 1\n", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//}
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M8+TYPE_GLOBAL;
					//break;
				r1 = r14 + 1;
				//r0 = [r15+r14*8];
				if (r1 != r13){
					r8 = data;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' db ');
				} else {
					r8 = bss;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' rb 1\n');
				}
				IsLabelAllocated();
				hash_table[r2].token_type = TYPE_M8+TYPE_GLOBAL;
			} else {
				
			r1 = HASH_m16+HASH_OFFSET;
			if(r0 == r1){
				//case HASH_m16+HASH_OFFSET :
					//if ((token+1)!=i){
						//fprintf(data, "_B0_%s dw ", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//} else {
						//fprintf(bss, "_B0_%s rw 1\n", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//}
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M16+TYPE_GLOBAL;
					//break;
				r1 = r14 + 1;
				//r0 = [r15+r14*8];
				if (r1 != r13){
					r8 = data;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' dw ');
				} else {
					r8 = bss;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' rw 1\n');
				}
				IsLabelAllocated();
				hash_table[r2].token_type = TYPE_M16+TYPE_GLOBAL;
			} else {
				
			r1 = HASH_m32+HASH_OFFSET;
			if(r0 == r1){
				//case HASH_m32+HASH_OFFSET :
					//if ((token+1)!=i){
						//fprintf(data, "_B0_%s dd ", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					///} else {
						//fprintf(bss, "_B0_%s rd 1\n", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//}
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M32+TYPE_GLOBAL;
					//break;
				r1 = r14 + 1;
				//r0 = [r15+r14*8];
				if (r1 != r13){
					r8 = data;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' dd ');
				} else {
					r8 = bss;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' rd 1\n');
				}
				IsLabelAllocated();
				hash_table[r2].token_type = TYPE_M32+TYPE_GLOBAL;
			} else {
				
			#ifndef i386;
			r1 = HASH_m64+HASH_OFFSET;
			#else;
			r1 = HASH_m32+HASH_OFFSET;
			#endif;
			if(r0 == r1){
			//#ifndef i386
				//case HASH_m64+HASH_OFFSET :
					//if ((token+1)!=i){
						//fprintf(data, "_B0_%s dq ", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//} else {
						//fprintf(bss, "_B0_%s rq 1\n", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//}
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M64+TYPE_GLOBAL;
					//break;
			//#endif
				r1 = r14 + 1;
				//r0 = [r15+r14*8];
				if (r1 != r13){
					r8 = data;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' dq ');
				} else {
					r8 = bss;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' rq 1\n');
				}
				IsLabelAllocated();
				hash_table[r2].token_type = TYPE_M64+TYPE_GLOBAL;
			} else {
				
			r1 = HASH_f32+HASH_OFFSET;
			if(r0 == r1){
				//case HASH_f32+HASH_OFFSET :
					//if ((token+1)!=i){
						//fprintf(data, "_B0_%s dd ", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//} else {
						//fprintf(bss, "_B0_%s rd 1\n", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//}
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F32+TYPE_GLOBAL;
					//break;
				r1 = r14 + 1;
				//r0 = [r15+r14*8];
				if (r1 != r13){
					r8 = data;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' dd ');
				} else {
					r8 = bss;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' rd 1\n');
				}
				IsLabelAllocated();
				hash_table[r2].token_type = TYPE_F32+TYPE_GLOBAL;
			} else {
				
			r1 = HASH_f64+HASH_OFFSET;
			if(r0 == r1){
				//case HASH_f64+HASH_OFFSET :
					//if ((token+1)!=i){
						//fprintf(data, "_B0_%s dq ", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//} else {
						//fprintf(bss, "_B0_%s rq 1\n", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//}
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F64+TYPE_GLOBAL;
					//break;
				r1 = r14 + 1;
				//r0 = [r15+r14*8];
				if (r1 != r13){
					r8 = data;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' dq ');
				} else {
					r8 = bss;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' rq 1\n');
				}
				IsLabelAllocated();
				hash_table[r2].token_type = TYPE_F64+TYPE_GLOBAL;
			} else {
			
			r1 = HASH_f80+HASH_OFFSET;
			if(r0 == r1){
				//case HASH_f80+HASH_OFFSET :
					//if ((token+1)!=i){
						//fprintf(data, "_B0_%s dq ", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//} else {
						//fprintf(bss, "_B0_%s rq 1\n", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//}
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F64+TYPE_GLOBAL;
					//break;
				r1 = r14 + 1;
				//r0 = [r15+r14*8];
				if (r1 != r13){
					r8 = data;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' dt ');
				} else {
					r8 = bss;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' rt 1\n');
				}
				IsLabelAllocated();
				hash_table[r2].token_type = TYPE_F80+TYPE_GLOBAL;
				
			} else {
				//case HASH_f80+HASH_OFFSET :
					//if ((token+1)!=i){
						//fprintf(data, "_B0_%s dt ", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//} else {
						//fprintf(bss, "_B0_%s rt 1\n", hash_table[(token_stack[token]-HASH_OFFSET)].token );
					//}
					//IsLabelAllocated();
					//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F80+TYPE_GLOBAL;
					//break;
				r4 = r0;
				r1 = r14 + 1;
				//r0 = [r15+r14*8];
				if (r1 != r13){
					abort_b0('Vector Types cannot be pre-defined');
				} else {
					r8 = bss;
					echo_string(r8, '_B0_');
					echo_string(r8, r3);
					echo_string(r8, ' rq 2\n');
				}
				IsLabelAllocated();
				r1 = HASH_v4f+HASH_OFFSET;
				if(r4 == r1){
					hash_table[r2].token_type = TYPE_V4F+TYPE_GLOBAL;
				}
				r1 = HASH_v2f+HASH_OFFSET;
				if(r4 == r1){
					hash_table[r2].token_type = TYPE_V2F+TYPE_GLOBAL;
				}
				r1 = HASH_v4i+HASH_OFFSET;
				if(r4 == r1){
					hash_table[r2].token_type = TYPE_V4I+TYPE_GLOBAL;
				}
				
				
				}}}}}}}
			//}
			//token++;
			r14 = token;
			r14 = r14 + 1;
			token = r14;
			//if (token != i) {
			if(r14 != r13){
				r8 = data;
				// We have tokens that follow?
				//TokenIs(TOKEN_EQUATE);
				TokenIs(TOKEN_EQUATE);
				//token++;
				r14 = r14 + 1;
				token = r14;
				//while (token < i){
				while (r14 < r13){
					r1 = [r15+r14*8];
					r0 = TOKEN_STRING;
					//if (token_stack[token] == TOKEN_STRING) {
					if(r0 == r1){
						//TokenIs(TOKEN_STRING);
						TokenIs(TOKEN_STRING);
						//token++;
						r14 = r14 + 1;
						token = r14;
						//if ((token_stack[token-4] == HASH_f32+HASH_OFFSET) ||
							//(token_stack[token-4] == HASH_f64+HASH_OFFSET) ||
							//(token_stack[token-4] == HASH_f80+HASH_OFFSET))
							//abort_b0("Strings cannot be encoded using f32, f64 or f80.");
						r0 = 0;
						r2 = [r15+r14*8-32];
						r3 = HASH_f32+HASH_OFFSET;
						if (r2 == r3) { r0 = 1; }
						r3 = HASH_f64+HASH_OFFSET;
						if (r2 == r3) { r0 = 1; }
						r3 = HASH_f80+HASH_OFFSET;
						if (r2 == r3) { r0 = 1; }
						if(r0){
							abort_b0('Strings cannot be encoded using f32, f64 or f80.');
						}
						// Before outputing the string, lets find the length of the string.
						//j = 0;
						r5 = 0;
						//while (token_stack[token] != TOKEN_END_STRING){
							//j++;
							//token++;
						//}
						r3 = r14;
						r0 = [r15+r3*8];
						r2 = TOKEN_END_STRING;
						r4 = TOKEN_MAX_SIZE;
						while (r0 != r2){
							r5 = r5 + 1;
							r3 = r3 + 1;
							r0 = [r15+r3*8];
							if(r3 >= r4){ abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE'); }
						}
						//token = token - j; // Reset the token back to it's correct value
						r0 = UTF8_STRINGS;
						r1 = 0;
						//if (UTF8_STRINGS == 0){
						if(r0 == r1){
							//if (token_stack[token-4] == HASH_m8+HASH_OFFSET)
								//abort_b0("To enable UTF8 encoded strings, please use the -UTF8 switch or\n #COMPILER_OPTION directive");
							r2 = [r15+r14*8-32];
							r3 = HASH_m8+HASH_OFFSET;
							if(r2 == r3){
								abort_b0('To enable UTF8 encoded strings, please use the -UTF8 switch or\n #COMPILER_OPTION directive');
							}
							//fprintf(data, "0%xh,0%xh,", j, j);
							echo_hex(r8, r5);
							echo_string(r8, ',');
							echo_hex(r8, r5);
							echo_string(r8, ',');
							//outputString(i);
							outputString(r13);
						//} else {
						} else {
							//j = 0;
							r5 = 0;
							//k = token;
							r3 = r14;
							r2 = TOKEN_END_STRING;
							r0 = [r15+r3*8];
							//while (token_stack[token] != TOKEN_END_STRING){
							while(r0 != r2){
								r1 = 080h;
								//if (token_stack[token] < 0x80) {
									//j++;
								if(r0 < r1){
									r5 = r5 + 1;
								//} else {
								} else {
									r1 = 0800h;
									//if (token_stack[token] < 0x800) {
									if(r0 < r1){
										// 2 byte encoding
										//j = j+2;
										r5 = r5 + 2;
									//} else {
									} else {
										r1 = 010000h;
										//if (token_stack[token] < 0x10000){
										if(r0 < r1){
											// 3 byte encoding
											//j = j+3;
											r5 = r5 + 3;
										//} else {
										} else {
											// 4 byte encoding
											//j = j+4;
											r5 = r5 + 4;
										//}
										}
									//}
									}
								//}
								}
								//token++;
								r3 = r3 + 1;
								r0 = [r15+r3*8];
							//}
							}
							//token = k; // Reset the token back to it's correct value
							r1 = 256;
							//if (j > 256){
							if(r5 > r1){
								//if(HeaderPrinted == 0)
									//PrintHeader();
								//printf("WARNING: String is too long for UTF8 encoding, setting length marker to 255\n");
								//printf("Filename: %s Line: %d.\n",file[file_stack_ptr].filename, (file[file_stack_ptr].line_count));
								//j = 255;
								r1 = 0;
								r0 = WarningsDisabled;
								if(r1 == r0){
									r0 = HeaderPrinted;
									r1 = 0;
									if(r0 == r1){
										PrintHeader();
									}
									echo_string(STDOUT, 'WARNING: String is too long for UTF8 encoding, setting length marker to 255\n');
									echo_string(STDOUT, 'Filename: ');
									r0 = file_stack_ptr;
									r0 = &file[r0].filename;
									echo_string(STDOUT, r0);
									echo_string(STDOUT, ' Line: ');
									r0 = file_stack_ptr;
									r0 = file[r0].line_count;
									echo_integer(STDOUT, r0);
									echo_cr(STDOUT);
								}
								r5 = 255;
							//};
							}
							//fprintf(data, "0%xh,0%xh,", j, j);
							echo_hex(r8, r5);
							echo_string(r8, ',');
							echo_hex(r8, r5);
							echo_string(r8, ',');
							//outputStringUTF8(i);
							outputStringUTF8(r13);
						//}
						}
						//TokenIs(TOKEN_END_STRING);
						TokenIs(TOKEN_END_STRING);
						//token++;
						r14 = token;
						r14 = r14 + 1;
						token = r14;
					//} else {
					} else {
						//if (token_stack[token] == TOKEN_MINUS){
							//fprintf(data, "-");
							//token++;
						//}
						r14 = token;
						r0 = [r15+r14*8];
						r1 = TOKEN_MINUS;
						if(r0 == r1){
							echo_string(r8, '-');
							r14 = r14 + 1;
							token = r14;
							r0 = [r15+r14*8];
						}
						r1 = TOKEN_NUM_INTEGER;
						//if (token_stack[token] > TOKEN_OFFSET)
							//abort_b0("Immediate Expected");
						if(r0 != r1){
							r1 = TOKEN_NUM_DECIMAL;
							if(r0 != r1){
								abort_b0('Immediate Expected');
							}
						}
						//switch(token_stack[0]) {
							//case HASH_m8+HASH_OFFSET :
							//case HASH_m16+HASH_OFFSET :
							//case HASH_m32+HASH_OFFSET :
						//#ifndef i386
							//case HASH_m64+HASH_OFFSET :
						//#endif
										//outputNumberD(i, NUM_INTEGER);
										//break;
							//case HASH_f32+HASH_OFFSET :
							//case HASH_f64+HASH_OFFSET :
							//case HASH_f80+HASH_OFFSET :
										//outputNumberD(i, NUM_DECIMAL);
										//break;
						//}
						r2 = [r15];
						r1 = HASH_m8+HASH_OFFSET;
						if (r2 == r1) { outputNumber(r13, NUM_INTEGER, r8); } else {
						r1 = HASH_m16+HASH_OFFSET;
						if (r2 == r1) { outputNumber(r13, NUM_INTEGER, r8); } else {
						r1 = HASH_m32+HASH_OFFSET;
						if (r2 == r1) { outputNumber(r13, NUM_INTEGER, r8); } else {
						#ifndef i386;
						r1 = HASH_m64+HASH_OFFSET;
						#endif;
						if (r2 == r1) { outputNumber(r13, NUM_INTEGER, r8); } else {
						r1 = HASH_f32+HASH_OFFSET;
						if (r2 == r1) { outputNumber(r13, NUM_DECIMAL, r8); } else {
						r1 = HASH_f64+HASH_OFFSET;
						if (r2 == r1) { outputNumber(r13, NUM_DECIMAL, r8); } else {
						r1 = HASH_f80+HASH_OFFSET;
						if (r2 == r1) { outputNumber(r13, NUM_DECIMAL, r8); }
						}}}}}}
						
					//}
					}
					
					//if((token_stack[token] == TOKEN_COMMA) && (token != i)){
						//fprintf(data, ",");
						//token++;
					//}
					r14 = token;
					r0 = [r15+r14*8];
					r1 = TOKEN_COMMA;
					if(r0 == r1){
						if(r14 != r13){
							echo_string(r8, ',');
							r14 = r14 + 1;
							token = r14;
						}
					}
				//}
				}
				//fprintf(data, "\n");
				echo_cr(r8);
			//}
			}
			//atStackEnd(i);
			atStackEnd(r13);
		//}
		}
	//} else {
	} else {
		// We have a local, and global -> current proc
		r1 = [r15+r14*8];
		r2 = TOKEN_ARRAY_START;
		if (r1 == r2){
		//if (token_stack[token] == TOKEN_ARRAY_START) {
			// This gets a little complicated?
			//toki = 0;
			//token++;
			r9 = 0;
			r4 = r9;
			r14 = r14 + 1;
			token = r14;
			TokenIs(TOKEN_NUM_INTEGER);
			r10 = [r15+r14*8+8];		// r10 is the size;
			r14 = r14 + 2;
			token = r14;
			TokenIs(TOKEN_ARRAY_END);
			//token++; // Skip end of array size indicator.
			r14 = r14 + 1;
			token = r14;
		//} else {
		} else {
			//token_buffer[0] = '1';
			//token_buffer[1] = 0;
			r10 = 1;
		//}
		}
		//token buffer is our size in ASCII
		//isHash(token_stack[token]);
		r1 = [r15+r14*8];
		isHash(r1);
		//fprintf(data, "_B0_%s_%s equ %d\n", hash_table[(global-HASH_OFFSET)].token, hash_table[(token_stack[token]-HASH_OFFSET)].token , local_var_offset);
		r8 = data;
		echo_string(r8, '_B0_');
		r0 = r11 - HASH_OFFSET;
		r0 = &hash_table[r0].token;
		echo_string(r8, r0);
		echo_string(r8, '_');
		r0 = r1 - HASH_OFFSET;
		r0 = &hash_table[r0].token;
		echo_string(r8, r0);
		echo_string(r8, ' equ ');
		r0 = local_var_offset;
		echo_hex(r8, r0);
		echo_cr(r8);
		//switch (token_stack[0]) {
		r1 = [r15];
		r0 = HASH_m8+HASH_OFFSET;
		if(r1 == r0){
			//case HASH_m8+HASH_OFFSET :
				//IsLabelAllocated();
				//local_var_offset = local_var_offset + (dhtoi(token_buffer));
				//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M8+TYPE_LOCAL;
				//break;
			IsLabelAllocated();
			r1 = local_var_offset;
			r0 = r10 + r1;
			local_var_offset = r0;
			r0 = [r15+r14*8];
			r0 = r0 - HASH_OFFSET;
			hash_table[r0].token_type = TYPE_M8+TYPE_LOCAL;
		} else {
			
		r0 = HASH_m16+HASH_OFFSET;
		if(r1 == r0){
			//case HASH_m16+HASH_OFFSET :
				//IsLabelAllocated();
				//local_var_offset = local_var_offset + (dhtoi(token_buffer) * 2);
				//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M16+TYPE_LOCAL;
				//break;
			IsLabelAllocated();
			r0 = r10 << 1;
			r1 = local_var_offset;
			r0 = r0 + r1;
			local_var_offset = r0;
			r0 = [r15+r14*8];
			r0 = r0 - HASH_OFFSET;
			hash_table[r0].token_type = TYPE_M16+TYPE_LOCAL;
		} else {
			
		r0 = HASH_m32+HASH_OFFSET;
		if(r1 == r0){
			//case HASH_m32+HASH_OFFSET :
				//IsLabelAllocated();
				//local_var_offset = local_var_offset + (dhtoi(token_buffer) * 4);
				//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M32+TYPE_LOCAL;
				//break;
			IsLabelAllocated();
			r0 = r10 << 2;
			r1 = local_var_offset;
			r0 = r0 + r1;
			local_var_offset = r0;
			r0 = [r15+r14*8];
			r0 = r0 - HASH_OFFSET;
			hash_table[r0].token_type = TYPE_M32+TYPE_LOCAL;
		} else {
			
		#ifndef i386;
		r0 = HASH_m64+HASH_OFFSET;
		#else;
		r0 = HASH_m32+HASH_OFFSET;
		#endif;
		if(r1 == r0){
		//#ifndef i386
			//case HASH_m64+HASH_OFFSET :
				//IsLabelAllocated();
				//local_var_offset = local_var_offset + (dhtoi(token_buffer) * 8);
				//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_M64+TYPE_LOCAL;
				//break;
		//#endif
			IsLabelAllocated();
			r0 = r10 << 3;
			r1 = local_var_offset;
			r0 = r0 + r1;
			local_var_offset = r0;
			r0 = [r15+r14*8];
			r0 = r0 - HASH_OFFSET;
			hash_table[r0].token_type = TYPE_M64+TYPE_LOCAL;
		} else {
			
		r0 = HASH_f32+HASH_OFFSET;
		if(r1 == r0){
			//case HASH_f32+HASH_OFFSET :
				//IsLabelAllocated();
				//local_var_offset = local_var_offset + (dhtoi(token_buffer) * 4);
				//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F32+TYPE_LOCAL;
				//break;
			IsLabelAllocated();
			r0 = r10 << 2;
			r1 = local_var_offset;
			r0 = r0 + r1;
			local_var_offset = r0;
			r0 = [r15+r14*8];
			r0 = r0 - HASH_OFFSET;
			hash_table[r0].token_type = TYPE_F32+TYPE_LOCAL;
		} else {
			
		r0 = HASH_f64+HASH_OFFSET;
		if(r1 == r0){
			//case HASH_f64+HASH_OFFSET :
				//IsLabelAllocated();
				//local_var_offset = local_var_offset + (dhtoi(token_buffer) * 8);
				//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F64+TYPE_LOCAL;
				//break;
			IsLabelAllocated();
			r0 = r10 << 3;
			r1 = local_var_offset;
			r0 = r0 + r1;
			local_var_offset = r0;
			r0 = [r15+r14*8];
			r0 = r0 - HASH_OFFSET;
			hash_table[r0].token_type = TYPE_F64+TYPE_LOCAL;
		} else {
		
		r0 = HASH_f80+HASH_OFFSET;
		if(r1 == r0){
				// case HASH_f80+HASH_OFFSET :
				//IsLabelAllocated();
				//local_var_offset = local_var_offset + (dhtoi(token_buffer) * 10);
				//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_F80+TYPE_LOCAL;
				//break;
			IsLabelAllocated();
			r10 = &[r10+r10*4]; // multiple by 5.
			r0 = r10 << 1;
			r1 = local_var_offset;
			r0 = r0 + r1;
			local_var_offset = r0;
			r0 = [r15+r14*8];
			r0 = r0 - HASH_OFFSET;
			hash_table[r0].token_type = TYPE_F80+TYPE_LOCAL;
		//}
		} else {
			r2 = r1;  //Save the has we need it later;
			IsLabelAllocated();
			r0 = r10 << 4;
			r1 = local_var_offset;
			r0 = r0 + r1;
			local_var_offset = r0;
			r0 = [r15+r14*8];
			r0 = r0 - HASH_OFFSET;
			r1 = HASH_v4i+HASH_OFFSET;
			if(r1 == r2){ hash_table[r0].token_type = TYPE_V4I+TYPE_LOCAL;
			} else {
			r1 = HASH_v4f+HASH_OFFSET;
			if(r1 == r2){ hash_table[r0].token_type = TYPE_V4F+TYPE_LOCAL;
			} else {
			r1 = HASH_v2f+HASH_OFFSET;
			if(r1 == r2){ hash_table[r0].token_type = TYPE_V2F+TYPE_LOCAL;
			}}}
			
		
		}}}}}}}
		//set the used stack frame for the current proc.
		//hash_table[(global-HASH_OFFSET)].local_offset = local_var_offset;
		r1 = global;
		r1 = r1 - HASH_OFFSET;
		r0 = local_var_offset;
		hash_table[r1].local_offset = r0;
		//token++;
		r14 = token;
		r14 = r14 + 1;
		token = r14;
		//atStackEnd(i);
		atStackEnd(r13);
	//}
	}
	//if(DEBUG)
		//printf("End Processing Variable Def\n");
	if(r12){
		echo_string(STDOUT, 'End Processing Variable Def\n');
	}
	//break;
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};

proc process_struc_directive(i){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	m64 exit_struc;
	
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = DEBUG;
	//atStackStart();
	atStackStart();
	//IsLabelAllocated();
	IsLabelAllocated();
	//hash_table[(token_stack[token]-HASH_OFFSET)].token_type = TYPE_STRUC;
	r14 = token;
	r1 = [r15+r14*8];
	r1 = r1 - HASH_OFFSET;
	hash_table[r1].token_type = TYPE_STRUC;
	//hash_table[(token_stack[token]-HASH_OFFSET)].local_offset = 0; // At entry 0 into structure's structure.
	hash_table[r1].local_offset = 0;
	//struc_def = token_stack[token]-HASH_OFFSET;
	struc_def = r1;
	//hash_table[struc_def].struc_ptr = calloc(1, sizeof(struc_struc));
	r2 = _calloc(1, STRUC_SIZE * STRUC_ENTRY_SIZE);
	//if (hash_table[struc_def].struc_ptr == NULL)
		//abort_b0("Out of Memory!");
	r0 = 0;
	if (r2 == r0){
		abort_b0('Out of Memory error on allocating space for structure definition');
	}
	hash_table[r1].struc_ptr = r2;
	//if(DEBUG)
		//printf("Source ptr = %p\n", hash_table[struc_def].struc_ptr);
	if(r12){
		echo_string(STDOUT, 'Source ptr = ');
		echo_hex(STDOUT, r2);
		echo_cr(STDOUT);
	}
	//token++;
	r14 = r14 + 1;
	token = r14;
	//atStackEnd(i);
	atStackEnd(r13);
	//exit_struc = 0;
	r11 = 0;
	//token = 0;		// Clear the stack before we star our own little private processing run.
	r14 = r11;
	token = r14;
	//getChar();
	getChar();
	r1 = r11;
	//while (exit_struc == 0) {
	while (r11 == r1){
		//do_process = nextToken();
		r2 = nextToken();
		do_process = r2;
		r14 = token;
		//if (DEBUG) 
			//printf("do_process_struc = 0x%x, token = 0x%x\n", do_process, token);
		if(r12){
			echo_string(STDOUT, 'do_process_struc = ');
			echo_hex(STDOUT, r2);
			echo_string(STDOUT, ', token = ');
			echo_hex(STDOUT, r14);
			echo_cr(STDOUT);
		}
		//if (token != 0){
		if(r14){
			//switch(do_process){
			r0 = 1;
				//case 1 : preparse_token_stack(); 
			if(r2 == r0){
					//exit_struc = process_struc(); 
					preparse_token_stack();
					r11 = process_struc();
					r14 = token;
					r0 = 0;
					if(r2 == r0){
						//if(do_process == 0)
							//i = exit_struc;
						//break;		// get the next token, and set token variable
						r13 = r11;
						i = r13;
					}
			//	case 2 : // We have encountered a { so let's handle it gracefully.
			} else {
				r0 = 2;
				if(r2 == r0){
					//if (token_stack[0] != TOKEN_BLOCK_END)
						//abort_b0("Invalid construct");
					r0 = TOKEN_BLOCK_END;
					r3 = [r15];
					if(r3 != r0){
						abort_b0('Invalid construct');
					}
					// We have something other than ELSE
					// Becuase most items need to be at the start, we simply remove all
					// block ends, and reprocess as per normal.
					// We get lucky becuase token = our first non } character!
					//j = token - 1; // make j our count!
					r8 = r14 - 1;
					//token = 1;
					r14 = 1;
					token = r14;
					//for (k = 0; k < j; k++){
						// Quick move the stack forward
						//token_stack[k] = token_stack[token];
						//token++;
						//if (DEBUG)
							//printf("stack[%d] = 0x%x\n",k,token_stack[k]);
					//}
					r1 = 0;
					while (r1 < r8){
						r0 = [r15+r14*8];
						[r15+r1*8] = r0;
						r14 = r14 + 1;
						token = r14;
						r1 = r1 + 1;
						if(r12){
							push r0;
							echo_string(STDOUT, 'stack[');
							echo_hex(STDOUT, r1);
							echo_string(STDOUT, '] = ');
							pop r0;
							echo_hex(STDOUT, r0);
							echo_cr(STDOUT);
						}
					}
					//token = 0;		// Set our stack pointer to 0
					r14 = 0;
					token = r14;
					//i = j;			// Set our new stack size to the count!
					r13 = r8;
					i = r13;
					//exit_struc = 1;
					r11 = 1;
					//if(DEBUG)
						//printf("process stack > token = 0x%x, i = 0x%x\n", token, i);
					if(r12){
						echo_string(STDOUT, 'process stack > token = ');
						echo_hex(STDOUT, r14);
						echo_string(STDOUT, ', i = ');
						echo_hex(STDOUT, r13);
						echo_cr(STDOUT);
					}
					//block_level++;
					r0 = block_level;
					r0 = r0 + 1;
					block_level = r0;
					r1 = TOKEN_STACK_SIZE;
					//if(block_level >= TOKEN_STACK_SIZE)
						//abort_b0("INTERNAL: Block Level is too large - too many nested blocks! - Increase TOKEN_STACK_SIZE");
					if(r0 >= r1){
						abort_b0('INTERNAL: Block Level is too large - too many nested blocks! - Increase TOKEN_STACK_SIZE');
					}
					//do_process = 0;
					r2 = 0;
					do_process = r2;
					//break;
				}
			}
			//}
		//}
		}
		//if (DEBUG)
			//printf("exit_struc = 0x%x\n", exit_struc);
		if(r12){
			echo_string(STDOUT, 'exit_struc = ');
			echo_hex(STDOUT, r11);
			echo_cr(STDOUT);
		}
		r1 = 0;
	//}
	}
	//if (DEBUG) 
		//printf("final do_process_struc = 0x%x, token = 0x%x, i = %d\n", do_process, token, i);
	if(r12){
		echo_string(STDOUT, 'final do_process_struc = ');
		echo_hex(STDOUT, r11);
		echo_string(STDOUT, ', token = ');
		echo_hex(STDOUT, r14);
		echo_string(STDOUT, ', i = ');
		echo_hex(STDOUT, r13);
		echo_cr(STDOUT);
	}
	//if (do_process == 1) token = i;
	r0 = 1;
	if(r11 == r0){
		r14 = r13;
		token = r14;
	}
	//block_level--;
	r0 = block_level;
	r0 = r0 - 1;
	block_level = r0;
	
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};

proc process_macro_directive(i){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	m64 stack_has_items;
	r15 = code;
	r14 = &token_stack;
	r13 = token;
	r12 = i;
	r11 = DEBUG;

	r0 = 0;
	stack_has_items = r0;
	atStackStart();
	IsLabelAllocated();
	if(r11){ echo_string(STDOUT, 'Defining macro1\n'); }
	//if (ch != '{')	// Macro decl statements are to be followed immediately by a block.
		//abort_b0("{ Expected");
	r0 = ch;
	r1 = CHAR_OCPARAN;
	if(r0 != r1){
		abort_b0('{ Expected');
	}
	//isHash(token_stack[token]);
	r13 = token;
	r1 = [r14+r13*8];
	isHash(r1);
	//if (global != 0) 
		//abort_b0("Macros must be globally defined");
	r0 = global;
	r2 = 0;
	if(r0 != r2){ 
		abort_b0('Macros must be globally defined'); 
	}
	r1 = r1 - HASH_OFFSET;
	r0 = TYPE_MACRO;
	hash_table[r1].token_type = r0;
	r13 = r13 + 1;
	token = r13;
	TokenIs(TOKEN_PARA_START);
	r13 = r13 + 1;
	token = r13;
	TokenIs(TOKEN_NUM_INTEGER);
	r13 = r13 + 1;
	token = r13;
	r2 = [r14+r13*8];
	// this is our argument number;
	r0 = 2048;
	if(r2 > r0){
		abort_b0('Number of macro arguments is invalid');
	}
	hash_table[r1].define_int = r2;
	if(r11){
		echo_string(STDOUT, 'Defining macro: ');
		r0 = &hash_table[r1].token;
		echo_string(STDOUT, r0);
		echo_string(STDOUT, ' ; Number of args = ');
		echo_integer(STDOUT, r2);
		echo_cr(STDOUT);
	}
	r13 = r13 + 1;
	token = r13;
	TokenIs(TOKEN_PARA_END);
	r13 = r13 + 1;
	token = r13;
	atStackEnd(r13);
	// Now we need to allocate our macro definition buffer,
	// and fill it...
	r2 = _calloc(1, MACRO_DEF_SIZE * 8);
	//if (hash_table[struc_def].struc_ptr == NULL)
		//abort_b0("Out of Memory!");
	r0 = 0;
	if (r2 == r0){
		abort_b0('Out of Memory error on allocating space for macro definition');
	}
	hash_table[r1].struc_ptr = r2;
	//if(DEBUG)
		//printf("Source ptr = %p\n", hash_table[struc_def].struc_ptr);
	if(r11){
		echo_string(STDOUT, 'Macro ptr = ');
		echo_hex(STDOUT, r2);
		echo_cr(STDOUT);
	}
	
	getChar();
	r8 = 1;
	r9 = r2;	// r9 = our token stack pointer;
	r10 = 0;	// r10 = our token count;
	r4 = 0;
	token = r4;
	push r1;
	// While r8 > 0 we keep grabbing the tokens and placing them into the macro buffer
	while(r8){

		//do_process = nextToken();
		r2 = nextToken();
		do_process = r2;
		r13 = token;
		//if (DEBUG) 
			//printf("do_process_struc = 0x%x, token = 0x%x\n", do_process, token);
		if(r11){
			echo_string(STDOUT, 'do_process_macro = ');
			echo_hex(STDOUT, r2);
			echo_string(STDOUT, ', token = ');
			echo_hex(STDOUT, r13);
			echo_cr(STDOUT);
		}
		//if we have a none 0 return on nextToken, keep going;
		if(r2){
			// We have something to copy to the stack;;;
			r5 = r13;
			r13 = 0;
			while(r5 != r13){
				r1 = [r14+r13*8]; // Get our token;
				if(r11){
					echo_hex(STDOUT, r1);
					echo_string(STDOUT, ' ');
				}
				r13 = r13 + 1;  // Increment our token pointers;
				r0 = TOKEN_BLOCK_END;
				if(r0 == r1){
					r8 = r8 - 1;
				}
				r0 = HASH_struc+HASH_OFFSET;
				if(r1 == r0){
					abort_b0('Unable to define Structures within macro definitions');
				}
				r0 = HASH_lib+HASH_OFFSET;
				if(r1 == r0){
					abort_b0('Unable to define lib includes within macro definitions');
				}
				r0 = HASH_macro+HASH_OFFSET;
				if(r1 == r0){
					abort_b0('Unable to define Macros within macro definitions');
				}
				r0 = HASH_asm+HASH_OFFSET;
				if(r1 == r0){
					abort_b0('Unable to define Assembly blocks within macro definitions');
				}
				if(r8){
					[r9+r10*8] = r1;
					r10 = r10 + 1;
				} else {
					r4 = r13;
					r13 = r5;   // If we have matched all our {} together then exit
					// Now we need to copy the remaining tokens onto the stack;
					// so they can be processed; r4 holds the next token to be
					// processed;
					if(r11){
						echo_string(STDOUT, 'Macro Exit2, token = ');
						echo_hex(STDOUT, r4);
						echo_string(STDOUT, '; total tokens = ');
						echo_hex(STDOUT, r13);
						echo_cr(STDOUT);
					}
					if(r4 != r13){
						r1 = 0;
						stack_has_items = r1;
						while(r4 < r13){
							r0 = [r14+r4*8];
							[r14+r1*8] = r0;
							r4 = r4 + 1;
							r1 = r1 + 1;
						}
						stack_has_items = r1;
					}
				}
			}
			r0 = 1;
			if(r0 == r2){
				if(r8){
					// Our statement ended in a ;
					r0 = TOKEN_SEMICOLON;
					[r9+r10*8] = r0;
					r10 = r10 + 1;
					if(r11){
						echo_hex(STDOUT, r0);
						echo_string(STDOUT, ' ');
					}
				}
			}
			r0 = 2;
			if(r0 == r2){
				// Our statement ended in a {
				if(r8){
					r8 = r8 + 1;
					getChar();
					r0 = TOKEN_BLOCK_START;
					[r9+r10*8] = r0;
					r10 = r10 + 1;
					if(r11){
						echo_hex(STDOUT, r0);
						echo_string(STDOUT, ' ');
					}
				} else {
					r0 = block_level;
					r0 = r0 + 1;
					block_level = r0;
				}
			}
			if(r8){
				r4 = 0;
				token = r4;
			}
			
		}
		//if (DEBUG)
			//printf("exit_struc = 0x%x\n", exit_struc);
		if(r11){
			echo_string(STDOUT, '\nexit_macro = ');
			echo_hex(STDOUT, r8);
			echo_string(STDOUT, ' Def size = ');
			echo_hex(STDOUT, r10);
			echo_cr(STDOUT);
		}
		r0 = MACRO_DEF_SIZE;
		if(r10 >= r0){
			abort_b0('INTERNAL ERROR: Out of memory for Macro Definitions, Increase MACRO_DEF_SIZE');
		}
	}
	pop r1;
	hash_table[r1].local_offset = r10;	// Save out macro size.
	//block_level--;
	// We do this to take into account that we handled the final }; ourselves;
	r0 = block_level;
	r0 = r0 - 1;
	block_level = r0;
	r8 = 0;
	if(r11){
		echo_string(STDOUT, 'Macro: ');
		while (r8 < r10){
			r0 = [r9+r8*8];
			echo_hex(STDOUT, r0);
			echo_string(STDOUT, ' ');
			r8 = r8 + 1;
		}
		echo_cr(STDOUT);
		echo_string(STDOUT, 'Token = ');
		r0 = token;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '; Stack has items = ');
		r2 = stack_has_items;
		echo_hex(STDOUT, r2);
		echo_cr(STDOUT);
		echo_string(STDOUT, 'New stack : ');
		r1 = 0;
		while(r1 != r2){
			r0 = [r14+r1*8];
			echo_hex(STDOUT, r0);
			echo_string(STDOUT, ' ');
			r1 = r1 + 1;
		}
		echo_cr(STDOUT);
	}
	r2 = stack_has_items;
	if(r2){
		token = r2;
		process_token_stack();
	}
	r0 = i;
	token = r0;
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
}

proc process_macro(i){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	m64[256] macro_arg_offset;
	m64 args_supplied;
	m64 tmp_ch;
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = DEBUG;
	r11 = 0;  // This is our macro hash.
	r10 = 0;  // This is our macro content.
	
	r2 = HASH_OFFSET;
	r3 = TYPE_MACRO;
	// Scan the token stack for our macro name;
	while (r14 < r13){
		r0 = [r15+r14*8];
		if (r0 > r2){
			r0 = r0 - r2;
			r1 = hash_table[r0].token_type;
			if(r1 == r3){
				r11 = r0;
				r14 = r13;
			}
		}
		r14 = r14 + 1;
	}
	r0 = 0;
	if(r11 == r0){
		pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
		return(0);	
	}
	
	// r4 	
	if(r12){
		echo_string(STDOUT, 'Processing macro : ');
		r0 = &hash_table[r11].token;
		echo_string(STDOUT, r0);
		echo_cr(STDOUT);
	}
	r10 = hash_table[r11].struc_ptr;		// load r10 with our pointer to the macro contents.
	
	// Now copy the current token stack to the macro buffer.
	r1 = macro_index;
	r1 = r1 + 1;
	macro_index = r1;
	r0 = MAX_LIB_DEPTH;
	if(r1 >= r0){
		abort_b0('INTENRAL ERROR: Macro embed depth too deep, increase MAX_LIB_DEPTH');
	}

	r9 = &macro_process_table[r1];
	r0 = 0;
	r2 = 0;		// This is our argument count;
	r3 = TOKEN_PARA_START;
	r4 = TOKEN_COMMA;
	r5 = TOKEN_PARA_END;
	r8 = &macro_arg_offset;
	while(r0 < r13){
		r1 = [r15+r0*8];
		[r9+r0*8] = r1;
		r0 = r0 + 1;
		if(r1 == r3){
			// This is our first arg;
			// But check for zero argument macros;
			r1 = [r15+r0*8];			
			if (r1 != r5){
				if (r1 != r4){
					r1 = r0;
					[r8+r2*8] = r1;
					r2 = r2 + 1;
					if(r12){
						push r0;
						echo_string(STDOUT, 'New macro arg - ');
						echo_integer(STDOUT, r2);
						echo_string(STDOUT, ' ; stack pos = ');
						echo_hex(STDOUT, r1);
						echo_cr(STDOUT);
						pop r0;
					}
				} else {
					abort_b0('Invalid macro definition');
				}
			}
		} else {
			if (r1 == r4){
				// arg 2+;
				r1 = [r15+r0*8];
				if (r1 != r5){
					if(r1 != r4){
						r1 = r0;
						[r8+r2*8] = r1;
						r2 = r2 + 1;
						if(r12){
							push r0;
							echo_string(STDOUT, 'New macro arg - ');
							echo_integer(STDOUT, r2);
							echo_string(STDOUT, ' ; stack pos = ');
							echo_hex(STDOUT, r1);
							echo_cr(STDOUT);
							pop r0;
						}
					} else {
						abort_b0('Invalid macro definition');
					}
				} else {
					abort_b0('Invalid macro definition');
				}
			}
		}
	}

	r1 = 0;
	[r9+r0*8] = r1;
	[r9+r0*8+8] = r1;  // Double 0 the end of the buffer.
	[r8+r2*8] = r1;
	[r8+r2*8+8] = r1;  // Double 0 the end of the buffer.

	r4 = [r9+r0*8-8];
	if(r4 != r5){
		// Check for correct termination;
		abort_b0('Invalid macro definition');
	}

	r1 = hash_table[r11].define_int;
	args_supplied = r2;
	if(r12){
		echo_string(STDOUT, 'Provided ');
		echo_integer(STDOUT, r2);
		echo_string(STDOUT, ' args to macro which requires ');
		echo_integer(STDOUT, r1);
		echo_string(STDOUT, ' args;\n');
	}

	if(r1 > r2){
		abort_b0('Insufficient macro arguments supplied to macro');
	}
	// Now we copy the ch value to tmp_ch;
	r0 = ch;
	tmp_ch = r0;
	
	// Now continue to copy the macro to the token stack, until we are done;
	r8 = hash_table[r11].local_offset;		// Use r8 to define if we continue;
	// r15 = &token_stack;
	// r14 = token;
	// r13 = i;
	// r12 = DEBUG;
	// r11 = macro hash;
	// r10 = our token struc;
	// r9 = our token definition containing the args
	// r8 = exit loop
	r5 = TOKEN_SEMICOLON;
	r4 = TOKEN_BLOCK_START;
	r1 = 0;	//Token count to new stack;
	r2 = 0;	// Position into r10.
	while(r2 < r8){
		token = r1;
		r0 = [r10+r2*8];
		if(r0 == r5){
			r0 = CHAR_SCOLON;
			ch = r0;
			process_token_stack();
			r0 = 0;
			token = r0;
			r1 = r0;
			r2 = r2 + 1;
		} else {
			if(r0 == r4){
				r0 = CHAR_OCPARAN;
				ch = r0;
				process_token_stack();
				//block_level++;
				r0 = block_level;
				r0 = r0 + 1;
				block_level = r0;
				
				r0 = block_num;
				r0 = r0 + 1;
				block_num = r0;
				
				r0 = 0;
				token = r0;
				r1 = r0;
				r2 = r2 + 1;
			} else {
				// Copy to stack or instert arg...
				r3 = TOKEN_MACROARG;
				if(r0 == r3){
					// We need to insert a macro arg
					push r4, r5;
					r5 = &macro_arg_offset;
					r0 = [r10+r2*8+8];
					r3 = TOKEN_NUM_INTEGER;
					if(r0 != r3){
						abort_b0('Macro argument index expected');
					}
					r3 = [r10+r2*8+16];
					// r3 = our argument index.
					r0 = hash_table[r11].define_int;
					if(r3>r0){
						abort_b0('Macro argument requested greater than what was supplied');
					}
					r4 = [r5+r3*8-8];
					r5 = [r5+r3*8];
					// r4 is the pointer to the start of the argument.
					// r5 is the pointer to the end of the argument.
					if(r12){
						echo_string(STDOUT, 'Argument = ');
						echo_integer(STDOUT, r3);
						echo_string(STDOUT, '; Argument start = ');
						echo_integer(STDOUT, r4);
						echo_string(STDOUT, '; Argument end = ');
						echo_integer(STDOUT, r5);
						echo_cr(STDOUT);
					}
					// What we do is copy the argument, until
					// we get a ',' or the final ')'
					r0 = 0;
					if(r5 == r0){
						// If we don't have an end set r5 to
						// be i, which is the end of the macro definition.
						r5 = r13;
						if(r12){
							echo_string(STDOUT, 'Setting end = ');
							echo_integer(STDOUT, r5);
							echo_cr(STDOUT);
						}
					} 
					r5 = r5 - 1;
					while(r4 < r5){
						r0 = [r9+r4*8];
						[r15+r1*8] = r0;
						r1 = r1 + 1;
						r4 = r4 + 1;
					}
					token = r1;
					
					pop r5, r4;
					r2 = r2 + 3; 
					// Increment our pointer to the macro definition
					// by 3 since we have TOKEN_MACROARG, TOKEN_INTEGER, and the value. (3 tokens total)
				} else {
					[r15+r1*8] = r0;
					r1 = r1 + 1;
					token = r1;
					r2 = r2 + 1;
					
				}
			}
		}
	}
	if(r1){
		if(r12){
			echo_string(STDOUT, 'A few final cleanup items\n');
		}
		token = r1;
		r0 = CHAR_SCOLON;
		ch = r0;
		process_token_stack();
		r0 = 0;
		token = r0;
		r1 = r0;		
	} else {
		if(r12){
			echo_string(STDOUT, 'No final cleanup items\n');
		}
	}
	
	
	r1 = macro_index;
	r1 = r1 - 1;
	macro_index = r1;	
	
	r0 = tmp_ch;
	ch = r0;
	
	r0 = i;
	token = r0;
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
}

proc process_notminus_directive(i){
	push r1, r2, r3, r4, r5, r12, r13, r14, r15;
	//atStackStart();
	atStackStart();
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = DEBUG;
	//if (token_stack[token] < HASH_OFFSET)
		//abort_b0("Expected Token/Label");
	r1 = [r15+r14*8];
	r0 = HASH_OFFSET;
	if(r1 < r0){
		abort_b0('Expected Token/Label');
	}
	r1 = r1 - r0;
	r2 = hash_table[r1].token_type;
	r0 = 0;
	//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & (TYPE_REG + TYPE_REG_SHORT + TYPE_REG_FPU)) == 0 )
		//abort_b0("Expected Register");
	r3 = r2 && TYPE_REG + TYPE_REG_SHORT + TYPE_REG_FPU + TYPE_REG_XMM;
	if(r3 == r0){
		abort_b0('Expected Register');
	}
	//if (hash_table[token_stack[token]-HASH_OFFSET].token_type == TYPE_REG_FPU) {
	r0 = TYPE_REG_FPU;
	if(r2 == r0){
		//if (token_stack[0] == TOKEN_NOT){
		r0 = [r15];
		r3 = TOKEN_NOT;
		if(r0 == r3){
			//abort_b0("FPU registers do not support bitwise operations");
			abort_b0('FPU registers do not support bitwise operations');
		//} else {
		} else {
			//if (token_stack[token]-HASH_OFFSET == HASH_fp0){
				//fprintf(code, "\tfchs\n");
			//} else {
				//abort_b0("NEG can only be performing on fp0");
			//}
			r0 = HASH_fp0;
			if(r1 == r0){
				r12 = code;
				echo_string(r12, '\tfchs\n');
			} else {
				abort_b0('NEG can only be performing on fp0');
			}
		//}
		}
	//} else {
	} else {
		// Test for XMM Reg
		r0 = TYPE_REG_XMM;
		if(r2 == r0){
			// We have a XMM Register.
			//if (token_stack[0] == TOKEN_NOT){
			r0 = [r15];
			r3 = TOKEN_NOT;
			r2 = &hash_table[r1].token;
			r12 = code;
			if(r0 == r3){
				// We need to check the mode the vector register is in, an perform the correct operation based on that.
				r4 = get_xmm_register(r1);
				// get_xmm_register returns the register number, so we can look up the VectorRegTable to get the vector mode for that register.
				r5 = &VectorRegType[r4];
				r5 = [r5];
				r0 = TYPE_V4I;
				if (r0 == r5){
					r3 = &'\tpandn ';
				} else {
					r0 = TYPE_V4F;
					if (r0 == r5){
						r3 = &'\tandpsn ';
					} else { 
						// must by TYPE_V2F;
						r3 = &'\tandpdn ';
					}
				}
				
				echo_string(r12, r3);
				echo_string(r12, r2);
				echo_string(r12, ', ');
				echo_string(r12, r2);
				echo_cr(r12);
			
			} else {
				// Negate operations are not possible with sse
				abort_b0('NEG operations are not permitteded with Vector Operations');
			}
			
		} else {
		
			//if (token_stack[0] == TOKEN_NOT){
			r0 = [r15];
			r3 = TOKEN_NOT;
			r2 = &hash_table[r1].token;
			r12 = code;
			if(r0 == r3){
				//fprintf(code, "\tnot %s\n", hash_table[token_stack[token]-HASH_OFFSET].token);
				echo_string(r12, '\tnot ');
				echo_string(r12, r2);
				echo_cr(r12);
			//} else {
			} else {
				//fprintf(code, "\tneg %s\n", hash_table[token_stack[token]-HASH_OFFSET].token);
				echo_string(r12, '\tneg ');
				echo_string(r12, r2);
				echo_cr(r12);
			}			
		}				
	//}
	}
	//token++;
	r14 = r14 + 1;
	token = r14;
	//atStackEnd(i);
	atStackEnd(r13);
	pop r15, r14, r13, r12, r5, r4, r3, r2, r1;
};

proc process_exit_directive(i){
	push r1, r2, r3, r4, r5, r12, r13, r14, r15;
	//atStackStart();
	atStackStart();
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = code;
	//TokenIs(TOKEN_PARA_START);
	TokenIs(TOKEN_PARA_START);
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	r1 = [r15+r14*8];
	r2 = TOKEN_PARA_END;
	//if (token_stack[token] != TOKEN_PARA_END){
	if(r1 != r2){
		r0 = 0;
		r2 = TOKEN_NUM_INTEGER;
		if (r1 == r2) { r0 = 1; };
		r2 = TOKEN_MINUS;
		if (r1 == r2) { r0 = 1; };
		//if ((token_stack[token] < TOKEN_OFFSET) || (token_stack[token] == TOKEN_MINUS)) {
		if(r0){
			// We have an immediate load
			//fprintf(code, "\tmov r0, ");
			echo_string(r12, '\tmov r0, ');
			//if (token_stack[token] == TOKEN_MINUS) {
				//token++;
				//fprintf(code, "-");
			//}
			r0 = TOKEN_MINUS;
			if(r1 == r0){
				r14 = r14 + 1;
				token = r14;
				echo_string(r12, '-');
			}
			//outputNumber(i, NUM_INTEGER);
			outputNumber(r13, NUM_INTEGER, r12);
			//fprintf(code, "\n");
			echo_cr(r12);
		//} else {
		} else {
			// We should have a reg										
			//TokenIsLabelType(TYPE_REG);  // Only allow 64bit reg
			TokenIsLabelType(TYPE_REG);
			//if ((token_stack[token]-HASH_OFFSET) != HASH_r0)	// If the reg is r0, then don't output code!
				//fprintf(code, "\tmov r0, %s\n", hash_table[token_stack[token]-HASH_OFFSET].token);
			r0 = HASH_r0+HASH_OFFSET;
			if(r1 != r0){
				r1 = r1 - HASH_OFFSET;
				r2 = &hash_table[r1].token;
				echo_string(r12, '\tmov r0, ');
				echo_string(r12, r2);
				echo_cr(r12);
			}
			//token++;
			r14 = token;
			r14 = r14 + 1;
			token = r14;
		//}
		}
		//TokenIs(TOKEN_PARA_END);
		TokenIs(TOKEN_PARA_END);
	//} else {
	} else {
		//fprintf(code, "\tmov r0, 0\n");
		echo_string(r12, '\tmov r0, 0\n');
	//}
	}
	//if (token_stack[0] == HASH_exit+HASH_OFFSET){
		//fprintf(code, "\tjmp B0_sys_exit\n");
	//} else {
		//fprintf(code, "\tret\n");
	//}
	r1 = [r15];
	r2 = HASH_exit+HASH_OFFSET;
	if(r1 == r2){
		echo_string(r12, '\tjmp B0_sys_exit\n');
	} else {
		echo_string(r12, '\tret\n');
	}
	//token++;
	r14 = token;
	r14 = r14 + 1;
	token = r14;
	//atStackEnd(i);
	atStackEnd(r13);
	pop r15, r14, r13, r12, r5, r4, r3, r2, r1;
};

proc process_token_preparser(i){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	m64 dummy;
	r15 = &token_stack;
	r14 = token;
	r13 = i;
	r12 = DEBUG;
	r11 = &pp_GenCode;
	r10 = pp_ptr;
	//if(DEBUG)
		//printf("Preparser Command - ");
	if(r12){
		echo_string(STDOUT, 'Preparser Command - ');
	}
	//atStackStart();
	atStackStart();
	r14 = token;
	r0 = [r15+r14*8];
	//switch(token_stack[token]){
	r1 = HASH_define+HASH_OFFSET;
	if(r0 == r1){
		//case HASH_define+HASH_OFFSET:
			//if(DEBUG)
				//printf("define\n");
			if(r12){
				echo_string(STDOUT, 'define\n');
			}
			r0 = [r11+r10*8];
			r1 = 1;
			//if (pp_GenCode[pp_ptr] == 1) {
			if(r0 == r1){
				//token++;
				r14 = r14 + 1;
				token = r14;
				//if (token == i) 
					//abort_b0("Invalid Construct");	// We should have something;
				if(r14 == r13){
					abort_b0('Invalid Construct');
				}
				//IsLabelAllocated();		// Lets see if our token is already defined?
				IsLabelAllocated();
				//token++;
				r14 = token;
				r14 = r14 + 1;
				token = r14;
				//if (token != i){
				if(r14 != r13){
					//TokenIs(TOKEN_EQUATE);
					TokenIs(TOKEN_EQUATE);
					//token++;
					r14 = r14 + 1;
					token = r14;
					r0 = [r15+r14*8];
					r2 = 0;
					r1 = TOKEN_MINUS;
					if(r0 == r1){ r2 = 1; }
					r1 = TOKEN_NUM_INTEGER;
					if(r0 == r1){ r2 = 1; }
					r1 = TOKEN_NUM_DECIMAL;
					if(r0 == r1){ r2 = 1; }
					r1 = TOKEN_STRING;
					if(r0 == r1){ r2 = 1; }					
					//if ((token_stack[token] == TOKEN_MINUS) || (token_stack[token] < TOKEN_OFFSET)) {
					if(r2){
						// We have an immediate which is what is expected!
						//setDefine(token_stack[2]-HASH_OFFSET, i); // This sets the label to a define, with value!
						r0 = token_stack[2];
						r0 = r0 - HASH_OFFSET;
						setDefine(r0, r13);
						//atStackEnd(i);
						atStackEnd(r13);
					//} else {
					} else {
						//abort_b0("Invalid Construct");
						abort_b0('Invalid Construct2');
					//}
					}
				//} else {
				} else {
					// Look like a simple #define {label};
					//hash_table[token_stack[2]-HASH_OFFSET].token_type = TYPE_DEFINE; // Set the label to TYPE_DEFINE
					r0 = token_stack[2];
					r0 = r0 - HASH_OFFSET;
					hash_table[r0].token_type = TYPE_DEFINE;
				//}
				}
				//atStackEnd(i);
				atStackEnd(r13);
			//} else {
			} else {
				//token = i; // Skip the DEFINE statement
				r14 = r13;
				token = r14;
			//}
			}
			//if(DEBUG)
				//printf("#define - pp_ptr = %d, pp_GenCode = %d\n", pp_ptr, pp_GenCode[pp_ptr]);
			r10 = pp_ptr;
			if(r12){
				r1 = [r11+r10*8];
				echo_string(STDOUT, '#define - pp_ptr = ');
				echo_hex(STDOUT, r10);
				echo_string(STDOUT, ', pp_GenCode = ');
				echo_hex(STDOUT, r1);
				echo_cr(STDOUT);
			}
			//break;
	} else {
		r1 = HASH_undefine+HASH_OFFSET;
		if(r0 == r1){
		//case HASH_undefine+HASH_OFFSET:
			//if(DEBUG)
				//printf("undefine\n");
			if(r12){
				echo_string(STDOUT, 'undefine\n');
			}
			r0 = [r11+r10*8];
			r1 = 1;
			//if (pp_GenCode[pp_ptr] == 1) {
			if(r0 == r1){
				//token++;
				r14 = r14 + 1;
				token = r14;
				//if (token == i) 
					//abort_b0("Invalid Construct");	// We should have something;
				if(r14 == r13){
					abort_b0('Invalid Construct');
				}
				//isHash(token_stack[token]);
				r1 = [r15+r14*8];
				isHash(r1);
				r2 = r1 - HASH_OFFSET;
				r0 = 0;
				r1 = TYPE_DEFINE;
				r3 = hash_table[r2].token_type;
				r3 = r3 && r1;
				//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_DEFINE) == TYPE_DEFINE) {
				if(r3 == r1){
					//hash_table[token_stack[token]-HASH_OFFSET].token[0] = 0;
					hash_table[r2].token = r0;
					//hash_table[token_stack[token]-HASH_OFFSET].hash = 0;
					hash_table[r2].hash = r0;
					//hash_table[token_stack[token]-HASH_OFFSET].token_type = 0;
					hash_table[r2].token_type = r0;
					//hash_table[token_stack[token]-HASH_OFFSET].local_offset = 0;
					hash_table[r2].local_offset = r0;
					//hash_table[token_stack[token]-HASH_OFFSET].define_int = 0;
					hash_table[r2].define_int = r0;
					hash_table[r2].token_import_name = r0;
					//hash_table[token_stack[token]-HASH_OFFSET].define_fp = 0;

					dummy = r0;
					fp0 = dummy;
					hash_table[r2].define_fp = fp0;
				//}
				}
				//token++;
				r14 = r14 + 1;
				token = r14;
				//atStackEnd(i);
				atStackEnd(r13);
			//} else {
			} else {
				//token = i; // Skip the UNDEFINE statement
				r14 = r13;
				token = r14;
			//}
			}
			//if(DEBUG)
				//printf("#undefine - pp_ptr = %d, pp_GenCode = %d\n", pp_ptr, pp_GenCode[pp_ptr]);					
			if(r12){
				r10 = pp_ptr;
				r1 = [r11+r10*8];
				echo_string(STDOUT, '#undefine - pp_ptr = ');
				echo_hex(STDOUT, r10);
				echo_string(STDOUT, ', pp_GenCode = ');
				echo_hex(STDOUT, r1);
				echo_cr(STDOUT);
			}
			//break;
	} else {
		r2 = 0;
		r1 = HASH_ifdef+HASH_OFFSET;
		if(r0 == r1) { r2 = 1; };
		r1 = HASH_ifndef+HASH_OFFSET;
		if(r0 == r1) { r2 = 1; };
		if(r2){
		//case HASH_ifdef+HASH_OFFSET:
		//case HASH_ifndef+HASH_OFFSET:
			//if(DEBUG)
				//printf("ifdef or ifndef\n");
			if(r12){
				echo_string(STDOUT, 'ifdef or ifndef\n');
			}
			r10 = pp_ptr;
			r0 = [r11+r10*8];
			r1 = 1;
			//if (pp_GenCode[pp_ptr] == 1) {
			if(r0 == r1){
				//token++; // Skip the current preparser command
				//token++; // Skip the hash of the token!
				r14 = r14 + 2;
				token = r14;
				//if (i == token) {
				if(r14 == r13){
					// we are at the end of the token stack.
					//token--;
					r14 = r14 - 1;
					token = r14;
					// The value on the stack MUST be a HASH.
					//isHash(token_stack[token]);
					r1 = [r15+r14*8];
					isHash(r1);
					//pp_ptr++;
					r10 = pp_ptr;
					r10 = r10 + 1;
					pp_ptr = r10;
					//if(pp_ptr >= MAX_LIB_DEPTH) abort_b0("INTERNAL: Preprocessor depth too large - Increase MAX_LIB_DEPTH");
					// Let's see if the hash is defined
					r0 = MAX_LIB_DEPTH;
					if(r10 >= r0){
						abort_b0('INTERNAL: Preprocessor depth too large - Increase MAX_LIB_DEPTH');
					}
					r0 = 0;
					//if (hash_table[token_stack[token]-HASH_OFFSET].token_type == 0) {
					r1 = r1 - HASH_OFFSET;
					r2 = hash_table[r1].token_type;
					if(r2 == r0){
						// It hasn't been defined!
						//if (token_stack[1] == HASH_ifdef+HASH_OFFSET) {
						r1 = HASH_ifdef+HASH_OFFSET;
						r2 = token_stack[1];
						if(r2 == r1){
							//pp_GenCode[pp_ptr] = 0;
							[r11+r10*8] = r0;
						//} else {
						} else {
							//pp_GenCode[pp_ptr] = 1;
							r0 = 1;
							[r11+r10*8] = r0;
						//}
						}
					//} else {
					} else {
						// It has been defined in some way, it could be a proc, variable, keyword, or other, we don't care!
						//if (token_stack[1] == HASH_ifdef+HASH_OFFSET) {
						r1 = HASH_ifdef+HASH_OFFSET;
						r2 = token_stack[1];
						if(r2 == r1){
							//pp_GenCode[pp_ptr] = 1;
							r0 = 1;
							[r11+r10*8] = r0;
						//} else {
						} else {
							//pp_GenCode[pp_ptr] = 0;
							[r11+r10*8] = r0;
						//}
						}
					//}
					}
					//token++;
					r14 = r14 + 1;
					token = r14;
				//} else {
				} else {
					// We must have a comparison operator?
					//token--;
					r14 = r14 - 1;
					token = r14;
					//isHash(token_stack[token]);
					r1 = [r15+r14*8];
					isHash(r1);
					//target = token_stack[token] - HASH_OFFSET;
					r5 = r1 - HASH_OFFSET;
					target = r5;
					//pp_ptr++;
					r10 = pp_ptr;
					r10 = r10 + 1;
					pp_ptr = r10;
					//if(pp_ptr >= MAX_LIB_DEPTH) abort_b0("INTERNAL: Preprocessor depth too large - Increase MAX_LIB_DEPTH");
					r0 = MAX_LIB_DEPTH;
					if(r10 >= r0){
						abort_b0('INTERNAL: Preprocessor depth too large - Increase MAX_LIB_DEPTH');
					}
					//token++;
					r14 = r14 + 1;
					token = r14;
					r1 = [r15+r14*8];
					//if ((token_stack[token] >= TOKEN_EQUALS)&&(token_stack[token] <= TOKEN_GREATERTHAN)){
					r2 = r1 - TOKEN_EQUALS;
					r3 = TOKEN_GREATERTHAN - TOKEN_EQUALS;
					if (r2 <= r3){
						// We have our operator;
						//token++;
						r14 = r14 + 1;
						token = r14;
						r3 = [r15+r14*8];
						//if ((token_stack[token] > TOKEN_OFFSET)&&(token_stack[token]!=TOKEN_MINUS))
							//abort_b0("Immediate expected");
						r4 = TOKEN_MINUS;
						if(r3 != r4){
							r4 = TOKEN_NUM_INTEGER;
							if(r3 != r4){
								r4 = TOKEN_NUM_DECIMAL;
								if(r3 != r4){
									abort_b0('Immediate expected');
								}
							}
						}
						//if (token_stack[1] == HASH_ifndef+HASH_OFFSET)
							//abort_b0("Value comparisons are only available for #ifdef");
						r3 = token_stack[1];
						r4 = HASH_ifndef+HASH_OFFSET;
						if (r3 == r4){
							abort_b0('Value comparisons are only available for #ifdef');
						}
							
						//pp_GenCode[pp_ptr] = checkDefine(target, token_stack[token-1], i);
						r0 = checkDefine(r5, r1, r13);
						[r11+r10*8] = r0;
						// checkDefine returns 1 for TRUE, 0 for FAIL.
					//} else {
					} else { 
						//abort_b0("Invalid construct");
						abort_b0('Invalid construct');
					//}
					}
				//}
				}
				//atStackEnd(i);
				atStackEnd(r13);
			//} else {
			} else {
				//pp_ptr++;
				r10 = pp_ptr;
				r10 = r10 + 1;
				pp_ptr = r10;
				r0 = MAX_LIB_DEPTH;
				//if(pp_ptr >= MAX_LIB_DEPTH) abort_b0("INTERNAL: Preprocessor depth too large - Increase MAX_LIB_DEPTH");
				if (r10 >= r0){
					abort_b0('INTERNAL: Preprocessor depth too large - Increase MAX_LIB_DEPTH');
				}
				//pp_GenCode[pp_ptr] = 0;
				r0 = 0;
				[r11+r10*8] = r0;
			//}
			}
			//token = i;
			r14 = r13;
			token = r14;
			//if(DEBUG)
				//printf("#ifdef - pp_ptr = %d, pp_GenCode = %d\n", pp_ptr, pp_GenCode[pp_ptr]);
			if(r12){
				r10 = pp_ptr;
				r1 = [r11+r10*8];
				echo_string(STDOUT, '#ifdef - pp_ptr = ');
				echo_hex(STDOUT, r10);
				echo_string(STDOUT, ', pp_GenCode = ');
				echo_hex(STDOUT, r1);
				echo_cr(STDOUT);
			}
			//break;
	} else {
		r1 = HASH_else+HASH_OFFSET;
		if(r0 == r1){
		//case HASH_else+HASH_OFFSET:
			//if(DEBUG)
				//printf("else\n");
			if(r12){
				echo_string(STDOUT, 'else\n');
			}
			//token++;
			r14 = r14 + 1;
			token = r14;
			//atStackEnd(i);
			atStackEnd(r13);
			r0 = [r11+r10*8-8];
			r1 = 1;
			if(r0 == r1){
				r0 = [r11+r10*8];
				r1 = 1;
				//if (pp_GenCode[pp_ptr] == 1) {
				if(r0 == r1){
					//pp_GenCode[pp_ptr] = 0;
					r1 = 0;
					[r11+r10*8] = r1;
				//} else {
				} else {
					//pp_GenCode[pp_ptr] = 1;
					[r11+r10*8] = r1;
				//}
				}
				//if(DEBUG)
					//printf("#else - pp_ptr = %d, pp_GenCode = %d\n", pp_ptr, pp_GenCode[pp_ptr]);
				if(r12){
					echo_string(STDOUT, '#else - pp_ptr = ');
					echo_hex(STDOUT, r10);
					echo_string(STDOUT, ', pp_GenCode = ');
					echo_hex(STDOUT, r1);
					echo_cr(STDOUT);
				}
			}
			//break;
	} else {
		r1 = HASH_endif+HASH_OFFSET;
		if(r0 == r1){
		//case HASH_endif+HASH_OFFSET:
			//if(DEBUG)
				//printf("endif\n");
			if(r12){
				echo_string(STDOUT, 'endif\n');
			}
			//pp_ptr--;
			r10 = r10 - 1;
			pp_ptr = r10;
			//token++;
			r14 = r14 + 1;
			token = r14;
			//atStackEnd(i);
			atStackEnd(r13);
			//if(DEBUG)
				//printf("#endif - pp_ptr = %d, pp_GenCode = %d\n", pp_ptr, pp_GenCode[pp_ptr]);
			if(r12){
				r1 = [r11+r10*8];
				echo_string(STDOUT, '#endif - pp_ptr = ');
				echo_hex(STDOUT, r10);
				echo_string(STDOUT, ', pp_GenCode = ');
				echo_hex(STDOUT, r1);
				echo_cr(STDOUT);
			}
			//break;
	} else {
		r1 = HASH_COMPILER_OPTION+HASH_OFFSET;
		if(r0 == r1){
		
		//case HASH_COMPILER_OPTION+HASH_OFFSET:
			//if (pp_GenCode[pp_ptr] == 1){
			r0 = [r11+r10*8];
			r1 = 1;
			if(r0 == r1){
				// Only if code generation is true do we process this...
				//if(DEBUG)
					//printf("#COMPILER_OPTION:");
				if(r12){
					echo_string(STDOUT, '#COMPILER_OPTION:');
				}
				//token++;
				r14 = r14 + 1;
				token = r14;
				//while (token < i){
				while (r14 < r13){
					// We may have multiple options.
					//switch(token_stack[token]){
					r0 = [r15+r14*8];
					r1 = HASH_UTF8+HASH_OFFSET;
					if (r0 == r1){
						//case HASH_UTF8+HASH_OFFSET:
							//UTF8_STRINGS = 1;
							UTF8_STRINGS = 1;
							//CLI_UTF8_STRINGS = 1;
							CLI_UTF8_STRINGS = 1;
							//if (DEBUG)
								//printf(" UTF8")
							if(r12){
								echo_string(STDOUT, ' UTF8');
							}
							//break;
					} else {
						r1 = HASH_UTF16+HASH_OFFSET;
						if(r0 == r1){
						//case HASH_UTF16+HASH_OFFSET:
							//UTF8_STRINGS = 0;
							UTF8_STRINGS = 0;
							//CLI_UTF8_STRINGS = 1;
							CLI_UTF8_STRINGS = 1;
							//if(DEBUG)
								//printf(" UTF16");
							if(r12){
								echo_string(STDOUT, ' UTF16');
							}
							//break;
					} else {
						r3 = r0;  // Save the token for later;
						r2 = 0;
						r1 = HASH_PE+HASH_OFFSET;
						if(r0 == r1){ r2 = 1; };
						r1 = HASH_DLL+HASH_OFFSET;
						if(r0 == r1){ r2 = 1; };		
						r1 = HASH_ELF+HASH_OFFSET;
						if(r0 == r1){ r2 = 1; };
						r1 = HASH_ELFO+HASH_OFFSET;
						if(r0 == r1){ r2 = 1; };
						if(r2){
						//case HASH_PE+HASH_OFFSET:
						//case HASH_ELF+HASH_OFFSET:
						//case HASH_ELFO+HASH_OFFSET:
							//if (ftell(code))
								//abort_b0("Unable to define object format once code has been generated");
							r0 = code;
							r0 = _ftell(r0);
							if(r0){
								abort_b0('Unable to define object format once code has been generated');
							}
							r0 = SOURCE_CLI;
							//if (SOURCE_CLI){
							if(r0){
								r1 = 0;
								r0 = WarningsDisabled;
								if(r0 == r1){
									//if(HeaderPrinted == 0)
										//PrintHeader();
									r0 = HeaderPrinted;
									r1 = 0;
									if(r0 == r1){
										PrintHeader();
									}
									r0 = SOURCE_TYPE;
									///switch(SOURCE_TYPE){
									r1 = SOURCE_PE;
									if(r0 == r1){
										//case SOURCE_PE: printf("WARNING: Object Format \"PE\" already defined - Ignoring Setting\n"); break;
										echo_string(STDOUT, 'WARNING: Object Format "PE" already defined - Ignoring Setting\n');
									} else {
										r1 = SOURCE_DLL;
										if(r0 == r1){
										echo_string(STDOUT, 'WARNING: Object Format "DLL Shared Library" already defined - Ignoring Setting\n');
									} else {
										r1 = SOURCE_ELF;
										if(r0 == r1){
										//case SOURCE_ELF: printf("WARNING: Object Format \"ELF Executable\" already defined - Ignoring Setting\n"); break;
										echo_string(STDOUT, 'WARNING: Object Format "ELF Executable" already defined - Ignoring Setting\n');
									} else {
										//case SOURCE_ELFO: printf("WARNING: Object Format \"ELF Object\" already defined - Ignoring Setting\n"); break;
										echo_string(STDOUT, 'WARNING: Object Format "ELF Object" already defined - Ignoring Setting\n');
										}}}
								}
								r0 = HASH_DLL+HASH_OFFSET;
								// Better skip the DLL Definition
								if(r0 == r3){
									r14 = r14 + 1;
									token = r14;
									TokenIs(TOKEN_STRING);
									r14 = r14 + 1;
									token = r14;
									// We now have the start of the string.
									r0 = [r15+r14*8];
									r1 = TOKEN_END_STRING;
									while (r0 != r1){
										r14 = r14 + 1;
										token = r14;
										r0 = [r15+r14*8];
									}
									TokenIs(TOKEN_END_STRING);
								}
							} else {
								//SOURCE_CLI = 1;
								SOURCE_CLI = 1;
								//switch(token_stack[token]){
								r1 = HASH_PE+HASH_OFFSET;
								if(r3 == r1){
									//case HASH_PE+HASH_OFFSET:
										//SOURCE_TYPE = SOURCE_PE;
										SOURCE_TYPE = SOURCE_PE;
										//if (DEBUG)
											//printf(" PE");
										if(r12){
											echo_string(STDOUT, ' PE');
										}
										//break;
								} else {
								r1 = HASH_DLL+HASH_OFFSET;
								if(r3 == r1){
									//case HASH_PE+HASH_OFFSET:
										//SOURCE_TYPE = SOURCE_PE;
										SOURCE_TYPE = SOURCE_DLL;		
										if(r12){
											echo_string(STDOUT, ' DLL');
										}
										r14 = r14 + 1;
										token = r14;
										TokenIs(TOKEN_STRING);
										r14 = r14 + 1;
										token = r14;
										// We now have the start of the string.
										r8 = &DLL_FILENAME;
										r0 = [r15+r14*8];
										r1 = TOKEN_END_STRING;
										while (r0 != r1){
											// Copy string to DLL Filename;
											[r8] = r0;
											r8 = r8 + 1;
											r14 = r14 + 1;
											token = r14;
											r0 = [r15+r14*8];
										}
										r0 = 0;
										[r8] = r0;	// Null terminate the string
										TokenIs(TOKEN_END_STRING);
										if(r12){
											echo_string(STDOUT, ', DLL Filename = "');
											r8 = &DLL_FILENAME;
											r8 = r8 - 2;
											echo_string(STDOUT, r8);
											echo_string(STDOUT, '"');
										}
										//break;
								} else {
									r1 = HASH_ELF+HASH_OFFSET;
									if(r3 == r1){
									//case HASH_ELF+HASH_OFFSET:
										//SOURCE_TYPE = SOURCE_ELF;
										SOURCE_TYPE = SOURCE_ELF;
										//if (DEBUG)
											//printf(" ELF");
										if(r12){
											echo_string(STDOUT, ' ELF');
										}
										//break;
									} else {
									//case HASH_ELFO+HASH_OFFSET:
										//SOURCE_TYPE = SOURCE_ELFO;
										SOURCE_TYPE = SOURCE_ELFO;
										//if (DEBUG)
											//printf(" ELFO");
										if(r12){
											echo_string(STDOUT, ' ELFO');
										}
										//break;
										}}}
								//}
							//}
							}
							//break;
					} else {
						//case HASH_ENABLESTACKFRAME+HASH_OFFSET:
						r1 = HASH_ENABLESTACKFRAME+HASH_OFFSET;
						if(r0 == r1){
							//STACK_FRAME = 1;
							STACK_FRAME = 1;
							//if(DEBUG){
								//printf(" ENABLESTACKFRAME");
							//}
							if(r12){
								echo_string(STDOUT, ' ENABLESTACKFRAME');
							}
							//break;
						} else {
						//case HASH_DISABLESTACKFRAME+HASH_OFFSET:
						r1 = HASH_DISABLESTACKFRAME+HASH_OFFSET;
						if(r0 == r1){
							//STACK_FRAME = 0;
							STACK_FRAME = 0;
							//if(DEBUG){
								//printf(" DISABLESTACKFRAME");
							//}
							if(r12){
								echo_string(STDOUT, ' DISABLESTACKFRAME');
							}
							//break;
						} else {
							r1 = HASH_RSRC+HASH_OFFSET;
							if(r0 == r1){
							if(r12){
								echo_string(STDOUT, ' RSRC');
								}
								r14 = r14 + 1;
								token = r14;
								TokenIs(TOKEN_STRING);
								r14 = r14 + 1;
								token = r14;
								// We now have the start of the string.
								r8 = &RSRC_FILENAME;
								r0 = [r15+r14*8];
								r1 = TOKEN_END_STRING;
								while (r0 != r1){
									// Copy string to DLL Filename;
									[r8] = r0;
									r8 = r8 + 1;
									r14 = r14 + 1;
									token = r14;
									r0 = [r15+r14*8];
								}
								r0 = 0;
								[r8] = r0;	// Null terminate the string
								TokenIs(TOKEN_END_STRING);
								if(r12){
									echo_string(STDOUT, ', RSRC Filename = "');
									r8 = &RSRC_FILENAME;
									r8 = r8 - 2;
									echo_string(STDOUT, r8);
									echo_string(STDOUT, '"');
								}
								r0 = SOURCE_TYPE;
								r1 = SOURCE_PE;
								if(r0 != r1){
									r1 = SOURCE_DLL;
									if(r0 != r1){
										r0 = 0;
										r1 = WarningsDisabled;
										if (r1 == r0){
											r1 = HeaderPrinted;
											if(r1 == r0){
												PrintHeader();
											}
											echo_string(STDOUT, 'WARNING: Resource file defined but not PE or DLL?\n');
										}
									}
								}
						} else {
							r1 = HASH_EXPLICITEXPORT+HASH_OFFSET;
							if(r0 == r1){
								r0 = 1;
								EXPLICIT_EXPORT = r0;
						} else {
						//default:
							//abort_b0("Unknown Compiler Option");
							abort_b0('Unknown Compiler Option');
					}}}}}}}
					//}
					//token++;
					r14 = r14 + 1;
					token = r14;
				//}
				};
				//if(DEBUG)
					//printf("\n");
				if(r12){
					echo_cr(STDOUT);
				}
				//atStackEnd(i);
				atStackEnd(r13);
			//}
			} else {
				r14 = r13;
				token = r14;
			}
			//break;
	} else {
		r1 = HASH_vector+HASH_OFFSET;
		if(r0 == r1){
			//if (pp_GenCode[pp_ptr] == 1){
			r0 = [r11+r10*8];
			r1 = 1;
			if(r0 == r1){
				// Only if code generation is true do we process this...
				//if(DEBUG)
					//printf("#COMPILER_OPTION:");
				if(r12){
					echo_string(STDOUT, '#vector:');
				}
				//token++;
				r14 = r14 + 1;
				token = r14;
				r1 = [r15+r14*8];
				// Get the selected vector mode.
				r2 = TYPE_V4F;
				r0 = HASH_v4i+HASH_OFFSET;
				if(r0 == r1){
					r2 = TYPE_V4I;
					if(r12){
						echo_string(STDOUT, ' TYPE_V4I\n');
					}
				} else {
					r0 = HASH_v4f+HASH_OFFSET;
					if(r0 == r1){
						r2 = TYPE_V4F;
						if(r12){
							echo_string(STDOUT, ' TYPE_V4F\n');
						}
					} else {
						r0 = HASH_v2f+HASH_OFFSET;
						if(r0 == r1){
							r2 = TYPE_V2F;
							if(r12){
								echo_string(STDOUT, ' TYPE_V2F\n');
							}
						} else {
							abort_b0('Unknown vector mode');
						}
					}
				};
				r1 = &VectorMode;
				[r1] = r2;
				
				r14 = r14 + 1;
				token = r14;				
				atStackEnd(r13);
			}
	} else {
		abort_b0('Invalid construct - Preparser');
		//default: abort_b0("Invalid construct - Preparser"); break;
	}}}}}}}
	//break;
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;

};

proc b0_build_source(__handle){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r1 = SOURCE_TYPE;
	//switch(SOURCE_TYPE){
		//case SOURCE_PE:
	r2 = SOURCE_PE;
	r14 = __handle;
	if(r1 == r2){
			//fprintf(file[0].handle, ";; B0 EXECUTABLE\n;; PE FORMAT\n\n");
			echo_string(r14, ';; B0 EXECUTABLE\n;; PE FORMAT\n\n');
			//include_standard_output();  // Include default equates and macros.
			include_standard_output();
			//#ifndef i386
			//fprintf(file[0].handle, "format PE64 GUI 4.0\nuse64\n\nentry start\n\n");
			//#else
			//fprintf(file[0].handle, "format PE GUI 4.0\nuse32\n\nentry start\n\n");
			//#endif
			#ifndef i386;
			echo_string(r14, 'format PE64 GUI 5.0\nuse64\nstack 1000000h\n\nentry start\n\n');
			#else;
			echo_string(r14, 'format PE GUI 5.0\nuse32\nstack 1000000h\n\nentry start\n\n');
			#endif;

			//Now we do our data! (Since the data section also has our defines).
			//fprintf(file[0].handle, "\nsection '.data' data readable writeable\n\n");
			echo_string(r14, '\nsection \'.data\' data readable writeable\n\n');

			//ch = fgetc(data);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(data);
			//}
			r13 = data;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			
			//fprintf(file[0].handle, "\ndb \"EXB0 %s\",0\n\n", B0_VERSION);
			echo_string(r14, '\ndb "EXB0 ');
			r0 = &B0_VERSION;
			echo_string(r14, r0);
			echo_string(r14, '",0\n\n');
			
			//Now we do our bss!
			//ch = fgetc(bss);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(bss);
			//}
			r13 = bss;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}

			//fprintf(file[0].handle, "align 16\nDATA_END:\n");
			echo_string(r14, 'align 16\nDATA_END:\n');	
			
			//FUCKING NASTY HACK FOR PE
			//#ifndef i386
			//if ((hash_table[0x3270d].hash != 0)&&(hash_table[0x3270d].token_type == TYPE_DEFINE+TYPE_M64)) {
			//#else
			//if ((hash_table[0x3270d].hash != 0)&&(hash_table[0x3270d].token_type == TYPE_DEFINE+TYPE_M32)) {
			//#endif
				//fprintf(file[0].handle, "\trb %lxh\n", hash_table[0x3270d].define_int);
			//} else {
				//fprintf(file[0].handle, "\trb 1000000h\n");
			//} // PS. Hash 0x3270d == LOCAL_HEAP!
			
			r0 = 0;
			r1 = hash_table[HASH_LOCAL_HEAP].hash;
			if(r1 != r0){
				r2 = hash_table[HASH_LOCAL_HEAP].token_type;
				#ifndef i386;
				r3 = TYPE_DEFINE+TYPE_M64;
				#else;
				r3 = TYPE_DEFINE+TYPE_M32;
				#endif;
				if(r2 == r3){
					echo_string(r14, '\trb ');
					r0 = hash_table[HASH_LOCAL_HEAP].define_int;
					echo_hex(r14, r0);
					echo_cr(r14);
				} else {
					echo_string(r14, '\trb 1000000h\n');
				}
			}
					

			// Now we do our code...
			//fprintf(file[0].handle, "\nsection '.code' code readable executable\n\n");
			echo_string(r14, '\nsection \'.code\' code readable executable\n\n');
			
			//fprintf(file[0].handle, "\nstart:\n");
			//fprintf(file[0].handle, "\tfinit\n\tlea r6,[DATA_END]\n\tcall _B0_main\n");
			//fprintf(file[0].handle, "\nB0_sys_exit:\n");
			echo_string(r14, '\nstart:\n\tfinit\n\tlea r6,[DATA_END]\n\tcall _B0_main\n\nB0_sys_exit:\n');
			//#ifndef i386
			//fprintf(file[0].handle, "\tmov ecx,eax\n\tcall [ExitProcess]\n");
			//#else
			//fprintf(file[0].handle, "\tpush r0\n\tcall [ExitProcess]\n");
			//#endif
			#ifndef i386;
			echo_string(r14, '\tmov ecx,eax\n\tcall [ExitProcess]\n');
			#else;
			echo_string(r14, '\tand r7, -16\n\tsub r7, 30h\n\tmov [rsp+20h], r0\n\tcall [ExitProcess]\n');
			#endif;

			//ch = fgetc(code);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(code);
			//}
			r13 = code;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			
			//Now lastly, we do our import section. (This is a Windows thing, basically we list all our externs). 
			//fprintf(file[0].handle, "\nsection '.idata' import data readable writeable\n\n");
			echo_string(r14, '\nsection \'.idata\' import data readable writeable\n\n');
			//include_public_extrns_pe(); // Include the rest of the public's and externs.
			include_public_extrns_pe();
			include_resource_file_pe();
			//fprintf(file[0].handle, "\n\n;EOF\n");
			echo_string(r14, '\n\n;EOF\n');
			//break;

	} else {
		r2 = SOURCE_DLL;
		if(r1 == r2){
			echo_string(r14, ';; B0 EXECUTABLE\n;; DLL FORMAT\n\n');
			include_standard_output();
			#ifndef i386;
			echo_string(r14, 'format PE64 GUI 5.0 DLL\nuse64\nstack 1000000h\n\nentry DllEntryPoint\n\n');
			#else;
			echo_string(r14, 'format PE GUI 5.0 DLL\nuse32\nstack 1000000h\n\nentry DllEntryPoint\n\n');
			#endif;

			echo_string(r14, '\nsection \'.data\' data readable writeable\n\n');

			r13 = data;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			
			echo_string(r14, '\ndb "EXB0 ');
			r0 = &B0_VERSION;
			echo_string(r14, r0);
			echo_string(r14, '",0\n\n');
			
			r13 = bss;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}

			echo_string(r14, 'align 16\nDATA_END:\n');	
			
			r0 = 0;
			r1 = hash_table[HASH_LOCAL_HEAP].hash;
			if(r1 != r0){
				r2 = hash_table[HASH_LOCAL_HEAP].token_type;
				#ifndef i386;
				r3 = TYPE_DEFINE+TYPE_M64;
				#else;
				r3 = TYPE_DEFINE+TYPE_M32;
				#endif;
				if(r2 == r3){
					echo_string(r14, '\trb ');
					r0 = hash_table[HASH_LOCAL_HEAP].define_int;
					echo_hex(r14, r0);
					echo_cr(r14);
				} else {
					echo_string(r14, '\trb 1000000h\n');
				}
			}
					

			echo_string(r14, '\nsection \'.code\' code readable executable\n\n');
			
			echo_string(r14, '\nDllEntryPoint:\n\tmov r0, 1\n\tret\n\n\nB0_sys_exit:\n');
			#ifndef i386;
			echo_string(r14, '\tmov ecx,eax\n\tcall [ExitProcess]\n');
			#else;
			echo_string(r14, '\tand r7, -16\n\tsub r7, 30h\n\tmov [rsp+20h], r0\n\tcall [ExitProcess]\n');
			#endif;

			r13 = code;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			
			// Now we do our import section. (This is a Windows thing, basically we list all our externs). 
			echo_string(r14, '\nsection \'.idata\' import data readable writeable\n\n');
			include_public_extrns_pe();
			// Now we do our export section.
			include_public_procs_pe();
			include_resource_file_pe();
			// Finalise DLL format
			echo_string(r14, 'section \'.reloc\' fixups data discardable');
			echo_string(r14, '\n\n;EOF\n');
			
	} else {
		r2 = SOURCE_ELF;
		if(r1 == r2){
		//case SOURCE_ELF: 
		
			//if ((hash_table[0x36768].hash == 0) || (hash_table[0x36768].token_type != TYPE_PROC)){
				//if(HeaderPrinted == 0)
					//PrintHeader();
				//printf("WARNING: Procedure main(); not found?\n");
			//}
			r1 = 0;
			r2 = hash_table[HASH_main].hash;
			r0 = 0;
			if(r1 == r2) { r0 = 1; }
			r1 = TYPE_EPROC;
			r2 = hash_table[HASH_main].token_type;
			if(r1 == r2) { r0 = 1; };
			if(r0){
				r0 = 0;
				r1 = WarningsDisabled;
				if (r1 == r0){
					r1 = HeaderPrinted;
					if(r1 == r0){
						PrintHeader();
					}
					echo_string(STDOUT, 'WARNING: Procedure main(); not found?\n');
				}
			}
			
			//fprintf(file[0].handle, ";; B0 EXECUTABLE\n;; ELF FORMAT for Linux\n\n");
			echo_string(r14, ';; B0 EXECUTABLE\n;; ELF FORMAT for Linux\n\n');
			//#ifndef i386
			//fprintf(file[0].handle, "format ELF64 executable\nuse64\nentry main\n\n");
			//#else
			//fprintf(file[0].handle, "format ELF executable\nuse32\nentry main\n\n");
			//#endif
			#ifndef i386;
			echo_string(r14, 'format ELF64 executable\nuse64\nentry main\n\n');
			#else;
			echo_string(r14, 'format ELF executable\nuse32\nentry main\n\n');
			#endif;
			//include_standard_output();  // Include default equates and macros.
			include_standard_output();
			//fprintf(file[0].handle, "macro syscall\n{\n");
			//fprintf(file[0].handle, "\tint 80h\n}\n\n");
			//fprintf(file[0].handle, "macro sysret\n{\n");
			//fprintf(file[0].handle, "\tiret\n}\n\n");
			#ifdef i386;
			echo_string(r14, 'macro syscall\n{\n\tint 80h\n}\n\nmacro sysret\n{\n\tiret\n}\n\n');
			#endif;

			//fprintf(file[0].handle, "\n\nsegment readable writeable\n\n");
			echo_string(r14, '\n\nsegment readable writeable\n\n');
			//ch = fgetc(data);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(data);
			//}
			r13 = data;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\ndb \"EXB0 %s\",0\n\n", B0_VERSION);
			//fprintf(file[0].handle, "\nsegment executable\n\nmain:\n\tfinit\n\tcall _B0_main\n");
			//fprintf(file[0].handle, "\nB0_sys_exit:\n");
			//fprintf(file[0].handle, "\tmov ebx,eax ;our exit code\n\tmov eax,1\n\tint 0x80\n");
			//fprintf(file[0].handle, "\n;We assume Linux output for ELF?\n");
			echo_string(r14, '\ndb "EXB0 ');
			r0 = &B0_VERSION;
			echo_string(r14, r0);
			echo_string(r14, '",0\n\n');
			echo_string(r14, '\nsegment executable\n\nmain:\n\tfinit\n\tcall _B0_main\n\nB0_sys_exit:\n');
			echo_string(r14, '\tmov r4,r0 ;our exit code\n\tmov r0,1\n\tsyscall\n\n;We assume Linux output for ELF?\n');
			//ch = fgetc(code);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(code);
			//}
			r13 = code;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\nsegment writeable readable\n");	// BSS Segment
			echo_string(r14, '\nsegment writeable readable\n');
			//ch = fgetc(bss);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(bss);
			//}
			r13 = bss;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\nsegment writeable readable\n");	// Workaround for bug, umm updated feature in Linux Kernel 2.6.11 series.
			//fprintf(file[0].handle, "\n\n;EOF\n");
			echo_string(r14, '\nsegment writeable readable\n\n\n;EOF\n');
			//break;
			
		} else {
			r2 = SOURCE_ELFO;
			if(r1 == r2){
		//case SOURCE_ELFO: 
			//fprintf(file[0].handle, ";; B0 OBJECT\n;; ELF OBJECT FORMAT for Linux\n\n");
			echo_string(r14, ';; B0 OBJECT\n;; ELF OBJECT FORMAT for Linux\n\n');
			//#ifndef i386
			//fprintf(file[0].handle, "format ELF64\nuse64\n\n");
			//#else
			//fprintf(file[0].handle, "format ELF\nuse32\n\n");
			//#endif
			#ifndef i386;
			echo_string(r14, 'format ELF64\nuse64\n\n');
			#else;
			echo_string(r14, 'format ELF\nuse32\n\n');
			#endif;
			//include_standard_output();  // Include default equates and macros.
			include_standard_output();
			//fprintf(file[0].handle, "macro syscall\n{\n");
			//fprintf(file[0].handle, "\tint 80h\n}\n\n");
			//fprintf(file[0].handle, "macro sysret\n{\n");
			//fprintf(file[0].handle, "\tiret\n}\n\n");
			#ifdef i386;
			echo_string(r14, 'macro syscall\n{\n\tint 80h\n}\n\nmacro sysret\n{\n\tiret\n}\n\n');
			#endif;
			
			// Now include our publics and externs
			//include_public_extrns(); // Include the rest of the public's and externs.
			include_public_extrns();
			
			//fprintf(file[0].handle, "\n;Externs for exit from application\nextrn exit\n");
			echo_string(r14, '\n;Externs for exit from application\nextrn exit\n');
			
			//fprintf(file[0].handle, "\n\nsection '.data' writeable\n\n");
			echo_string(r14, '\n\nsection \'.data\' writeable\n\n');
			//ch = fgetc(data);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(data);
			//}
			r13 = data;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\ndb \"EXB0 %s\",0\n\n", B0_VERSION);
			echo_string(r14, '\ndb "EXB0 ');
			r0 = &B0_VERSION;
			echo_string(r14, r0);
			echo_string(r14, '",0\n\n');
			//fprintf(file[0].handle, "\nsection '.bss' writeable\n\n");
			echo_string(r14, '\nsection \'.bss\' writeable\n\n');
			//ch = fgetc(bss);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(bss);
			//}
			r13 = bss;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\nsection '.text' executable\n\n");
			echo_string(r14, '\nsection \'.text\' executable\n\n');
			//ch = fgetc(code);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(code);
			//}
			r13 = code;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\nB0_sys_exit:\n");
			//fprintf(file[0].handle, "\tpush r0\n\tcall exit\n");
			//fprintf(file[0].handle, "\n\n;EOF\n");
			echo_string(r14, '\nB0_sys_exit:\n\tmov r4, r0\n\tmov r0, 0\n\tcall exit\n\n\n;EOF\n');
			//break;
	//}
	}}}}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
}

proc deallocate_struc_memory(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r15 = &hash_table;
	r14 = HASH_TABLE_SIZE;
	r13 = TYPE_STRUC;
	r12 = 0;
	while (r12 < r14){
		r13 = TYPE_STRUC;
		r0 = hash_table[r12].token_type;
		r0 = r0 && r13;
		if(r0){
			r4 = hash_table[r12].struc_ptr;
			r5 = STRUC_SIZE * STRUC_ENTRY_SIZE;
			r0 = 0;
			_munmap(r4, r5);
			//echo_string(STDOUT, 'Freeing memory: ');
			//echo_hex(STDOUT, r4);
			//echo_cr(STDOUT);
		}
		r13 = TYPE_MACRO;
		r0 = hash_table[r12].token_type;
		r0 = r0 && r13;
		if(r0){
			r4 = hash_table[r12].struc_ptr;
			r5 = MACRO_DEF_SIZE * 8;
			r0 = 0;
			_munmap(r4, r5);
		}
		r12 = r12 + 1;
	}
	
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(r0);
}

proc close_open_files(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r1 = file_stack_ptr;
	r2 = 0;
	while (r1 > r2){
		r3 = file[r1].handle;
		_fclose(r3);
		r1 = r1 - 1;
	}
	r3 = file[r1].handle;
	_fclose(r3);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(r0);	
};

proc b0_close_temp_files(__handle){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//fclose(code);
	r0 = code;
	_fclose(r0);
	//fclose(data);
	r0 = data;
	_fclose(r0);
	//fclose(bss);
	r0 = bss;
	_fclose(r0);
	//remove the files;
	b0_delete_temp_files();
	r14 = __handle;
	_fclose(r14);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};

proc b0_open_source_file(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r1 = &filename;
	//file[file_stack_ptr].handle = fopen((char *)filename, "r");

	r0 = _fopen(r1, 'r');
	r2 = file_stack_ptr;
	file[r2].handle = r0;

	r3 = 0;

	//if (!file[file_stack_ptr].handle){
	if(r0 == r3){
		abort_b0('Unable to open source file');
	//} else {
	} else {
		//strcpy((char *) file[file_stack_ptr].filename, (char *)filename);
		r4 = &file[r2].filename;
		r1 = &filename;
		strcpy(r4, r1);
		//file[file_stack_ptr].line_count = 1;
		file[r2].line_count = 1;
	///};
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
}

proc b0_open_output_file(){
	m64 pdest;
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r15 = DEBUG;
	
	r1 = &output_filename;
	r0 = [r1];
	r2 = 0;
	// If our output filename is blank, construct a name for us...
	if(r0 == r2){
		r1 = &filename;
		r2 = &file[0].filename;
		strcpy(r1, r2);  //dest, src
		
		//pdest = (unsigned char *) strrchr((char *)filename, '.');
		r3 = strrchr(r1, CHAR_STOP);
		
		pdest = r3;
		//if (pdest != NULL) {
			//i = pdest - filename;
			//if (DEBUG) 
				//printf("%s = %ld\n", filename, i);
			//filename[i] = '\0';			// Truncate the string at the last '.'
		//}
		if(r3){
			if(r15){
				echo_string(STDOUT, r1);
				echo_string(STDOUT, ' = ');
				echo_hex(STDOUT, r3);
				echo_cr(STDOUT);
			}
			r4 = 0;
			[r1+r3+2] = r4b;
		}
		if(r15){
			echo_string(STDOUT, 'Trunc Filename = "');
			r0 = &filename;
			echo_string(STDOUT, r0);
			echo_string(STDOUT, '"\n');
		}
		//strcat((char *)filename, ".asm");			// Append .asm to the end!
		strcat(r1, '.asm');
		if(r15){
			echo_string(STDOUT, 'ASM Filename = "');
			r0 = &filename;
			echo_string(STDOUT, r0);
			echo_string(STDOUT, '"\n');
		}
	} else {
		r2 = &file[0].filename;
		strcpy(r2, r1);  //dest, src
		if(r15){
			echo_string(STDOUT, 'Output Filename = "');
			r0 = &file[0].filename;
			echo_string(STDOUT, r0);
			echo_string(STDOUT, '"\n');
		}

	}

	//file[0].handle = fopen((char *)filename, "w");
	r14 = _fopen(r1, 'w');
	file[0].handle = r14;
	//if (!file[0].handle){
		//printf("ERROR: Unable to create file: %s\n", filename);
		//exit(1);
	//}
	r0 = 0;
	if(r14 == r0){
		abort_b0('Unable to create output file');
	}
	r0 = r14;
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(r0);
}

proc b0_open_temp_files(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	
	_settmppath();

	r1 = 0;
	r2 = &ctmp_filename;
	r3 = &tmp_directory;
	strcpy(r2, r3);
	r2 = &dtmp_filename;
	r3 = &tmp_directory;
	strcpy(r2, r3);
	r2 = &btmp_filename;
	r3 = &tmp_directory;
	strcpy(r2, r3);
	
	r0 = _getpid();
	pid = r0;
	r2 = &pid_filename;
	itoa(r2, r0);
	
	r2 = &ctmp_filename;
	r3 = &pid_filename;
	strcat(r2, r3);
	
	r2 = &dtmp_filename;
	r3 = &pid_filename;
	strcat(r2, r3);
	
	r2 = &btmp_filename;
	r3 = &pid_filename;
	strcat(r2, r3);
	
	r2 = &ctmp_filename;
	strcat(r2, '_c_output.tmp');
	r2 = &ctmp_filename;
	r0 = _fopen(r2, 'w+');
	code = r0;
	if (r1 == r0){
		abort_b0('Unable to create code temp file\n');
	} else {
		r15 = DEBUG;
		//r15 = 1;
		if(r15){
			echo_string(STDOUT, 'Code Temp Filename: ');
			echo_string(STDOUT, r2);
			echo_cr(STDOUT);
		}
	}
	
	r2 = &dtmp_filename;
	strcat(r2, '_d_output.tmp');	
	r2 = &dtmp_filename;	
	r0 = _fopen(r2, 'w+');
	data = r0;
	if (r1 == r0){
		abort_b0('Unable to create data temp file\n');
	} else {
		r15 = DEBUG;
		//r15 = 1;
		if(r15){
			echo_string(STDOUT, 'Data Temp Filename: ');
			echo_string(STDOUT, r2);
			echo_cr(STDOUT);
		}
	}
	
	r2 = &btmp_filename;
	strcat(r2, '_b_output.tmp');
	r2 = &btmp_filename;
	r0 = _fopen(r2, 'w+');
	bss = r0;
	if (r1 == r0){
		abort_b0('Unable to create bss temp file\n');
	} else {
		r15 = DEBUG;
		//r15 = 1;
		if(r15){
			echo_string(STDOUT, 'BSS Temp Filename: ');
			echo_string(STDOUT, r2);
			echo_cr(STDOUT);
		}
	}
	
	r15 = DEBUG;
	if(r15){
		echo_string(STDOUT, 'Src Handle = ');
		r0 = file[0].handle;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '\nCode Handle = ');
		r0 = code;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '\nData Handle = ');
		r0 = data;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '\nBSS Handle = ');
		r0 = bss;
		echo_hex(STDOUT, r0);
		echo_cr(STDOUT);
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(r0);
};

proc b0_delete_temp_files(){
	r0 = &ctmp_filename;
	_remove(r0);
	r0 = &dtmp_filename;
	_remove(r0);
	r0 = &btmp_filename;
	_remove(r0);
}

proc b0_build_hashtable(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//hash_table[i].hash = 0;
	//};
	r1 = 0;
	r2 = HASH_TABLE_SIZE;
	while (r1 < r2){
		hash_table[r1].hash = 0;
		r1 = r1 + 1;
	}

	//Setup reserved labels within the hash table...
	
	//ptr = TOKEN_KEYWORD;
	//while(*ptr){
		//insert_token(ptr, TYPE_KEYWORD);
		//while(*ptr++);
	//};
	r1 = &TOKEN_KEYWORD;
	r1 = r1 + 2;  // Point to the first char.
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_KEYWORD);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	
	//ptr = TOKEN_REG;
	//while(*ptr){
		//insert_token(ptr, TYPE_REG);
		//while(*ptr++);
	//};
	r1 = &TOKEN_REG;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_REG);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_REG_SHORT;
	//while(*ptr){
		//insert_token(ptr, TYPE_REG_SHORT);
		//while(*ptr++);
	//};
	r1 = &TOKEN_REG_SHORT;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_REG_SHORT);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_REG_SHORT2;
	//while(*ptr){
		//insert_token(ptr, TYPE_REG_SHORT);
		//while(*ptr++);
	//};
	r1 = &TOKEN_REG_SHORT2;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_REG_SHORT);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_REG_FPU;
	//while(*ptr){
		//insert_token(ptr, TYPE_REG_FPU);
		//while(*ptr++);
	//};
	r1 = &TOKEN_REG_FPU;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_REG_FPU);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_FLAG;
	//while(*ptr){
		//insert_token(ptr, TYPE_FLAG);
		//while(*ptr++);
	//};
	r1 = &TOKEN_FLAG;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_FLAG);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_RESERVED;
	//while(*ptr){
		//insert_token(ptr, TYPE_RESERVED);
		//while(*ptr++);
	//};
	r1 = &TOKEN_RESERVED;
	r1 = r1 + 2; 
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_RESERVED);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}	
	
	// Add in the XMM registers.
	r1 = &TOKEN_REG_XMM;
	r1 = r1 + 2; 
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_REG_XMM);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}	

	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};

proc b0_main(){
	rsp_entry = r7;
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//echo_hex(STDOUT, r7);
	//echo_string(STDOUT, '\n');
	//#ifdef _MSC_VER
		//long long int i;
	//#else
		//long int i;
	//#endif
	//unsigned int j;
	//unsigned char *pdest;
	//const unsigned char *ptr;
	//int Help = 0;
	//int Version = 0;
	//int have_file = 0;
	m64 pdest;
	m64 ptr;
	m64 Help;
	m64 Version;
	m64 have_file;
	
	pdest = 0;
	ptr = 0;
	Help = 0;
	Version = 0;
	have_file = 0;
	VectorMode = TYPE_V4F;
	r0 = TYPE_V4F;
	VectorRegType[0] = r0;
	VectorRegType[1] = r0;
	VectorRegType[2] = r0;
	VectorRegType[3] = r0;
	VectorRegType[4] = r0;
	VectorRegType[5] = r0;
	VectorRegType[6] = r0;
	VectorRegType[7] = r0;
	VectorRegType[8] = r0;
	VectorRegType[9] = r0;
	VectorRegType[10] = r0;
	VectorRegType[11] = r0;
	VectorRegType[12] = r0;
	VectorRegType[13] = r0;
	VectorRegType[14] = r0;
	VectorRegType[15] = r0;

	//total_paths = 0;
	total_paths = 0;
	
	r0 = &DLL_FILENAME;
	r1 = 0;
	[r0] = r1;

	r0 = &RSRC_FILENAME;
	r1 = 0;
	[r0] = r1;


	//time_start = clock();
	r1 = _clock();
	time_start = r1;
	
	//pp_ptr = 0;
	//pp_GenCode[pp_ptr] = 1;				// We want to generate code.
	pp_ptr = 0;
	pp_GenCode[0] = 1;
	
	r1 = argc;
	r2 = argv;
	
	//echo_string(STDOUT, 'argc = ');
	//echo_hex(STDOUT, r1);
	//echo_string(STDOUT, '; argv = ');
	//echo_hex(STDOUT, r2);
	//echo_string(STDOUT, '\n');
	
	r0 = 1;
	//if(argc > 1){
	if(r1 > r0){
		r2 = 0;
		r3 = 0;
		r15 = argv;
		//for(i=0;i<argc;i++){
		while(r2 < r1){
			r5 = [r15+r2*8];  	// r5 is a POINTER THE STRING!
			
			push r2;
			//echo_string(STDOUT, '&argv[');
			//echo_hex(STDOUT, r2);
			//echo_string(STDOUT, '] = ');
			//echo_hex(STDOUT, r5);
			//echo_string(STDOUT, ' ; "');
			//r5 = r5 - 2;  // We do this as echo_string(); expects a b0 type string.
			//echo_string(STDOUT, r5);
			//echo_string(STDOUT, '"\n');
			//r5 = r5 + 2;
			
			//if(!strcmp(argv[i], "-DEBUG"))
				//DEBUG = 1;
			r4 = _strcmp(r5, '-DEBUG');
			if(r4 == r3){
				DEBUG = 1;
				//echo_string(STDOUT, 'DEBUG Output has been set\n');
			}

			//if(!strcmp(argv[i], "-UTF8"))
				//{ UTF8_STRINGS = 1; CLI_UTF8_STRINGS = 1; }
			r4 = _strcmp(r5, '-UTF8');
			if(r4 == r3){
				UTF8_STRINGS = 1;
				CLI_UTF8_STRINGS = 1;
				//echo_string(STDOUT, 'UTF8 encoding has been set\n');
			}
			//if(!strcmp(argv[i], "-UTF16"))
				//{ UTF8_STRINGS = 0; CLI_UTF8_STRINGS = 1; }
			r4 = _strcmp(r5, '-UTF16');
			if(r4 == r3){
				UTF8_STRINGS = 0;
				CLI_UTF8_STRINGS = 1;
				//echo_string(STDOUT, 'UTF16 encoding has been set\n');
			}
			//if(!strcmp(argv[i], "-?"))
				//Help = 1;
			r4 = _strcmp(r5, '-?');
			if(r4 == r3){
				Help = 1;
				//echo_string(STDOUT, 'Help has been set\n');
			}
			//if(!strcmp(argv[i], "-h"))
				//Help = 1;
			r4 = _strcmp(r5, '-h');
			if(r4 == r3){
				Help = 1;
				//echo_string(STDOUT, 'Help has been set\n');
			}
			//if(!strcmp(argv[i], "-v"))
				//Version = 1;
			r4 = _strcmp(r5, '-v');
			if(r4 == r3){
				Version = 1;
				//echo_string(STDOUT, 'Version has been set\n');
			}
			//if(!strcmp(argv[i], "-l")){
				//PrintHeader();
				//PrintLicense();
				//exit(0);
			//}
			r4 = _strcmp(r5, '-l');
			if(r4 == r3){
				#ifdef WIN64;
				PopUpLicense();
				#else;
				PrintHeader();
				PrintLicense();
				#endif;
				#ifdef WIN64;
				__Exit_Win64();
				#endif;
				//exit(0);
				r7 = rsp_entry;
				ret;
			}
			//if(!strcmp(argv[i], "-W"))
				//WarningsDisabled = 1;
			r4 = _strcmp(r5, '-W');
			if(r4 == r3){
				WarningsDisabled = 1;
			}
			//if(!strcmp(argv[i], "-!"))
				//ContinueOnAbort = 1;
			r4 = _strcmp(r5, '-!');
			if(r4 == r3){
				ContinueOnAbort = 1;
				//echo_string(STDOUT, 'ContinueOnAbort has been set\n');
			}
			//if((argv[i][0] == '-') && (argv[i][1] == 'i')){
				//path = &argv[i][2]; // Set pointer to the CLI environment
			//}
			r8 = r8 ^ r8;
			r8b = [r5];
			r9 = CHAR_MINUS;
			if(r8 == r9){
				r8b = [r5+1];
				r9 = CHAR_i;
				if(r8 == r9){
					r5 = r5 + 2;
					ptr_path = r5;
					//if(path) scan_env(path);
					scan_env(r5);
					//push r5;
					//echo_string(STDOUT, '&Path = ');
					//echo_hex(STDOUT, r5);
					//echo_string(STDOUT, ' or ');
					//r5 = r5 - 2;
					//echo_string(STDOUT, r5);
					//r5 = r5 + 2;
					//echo_string(STDOUT, '\n');
					//pop r5;
					r5 = r5 - 2;
				}
			}
			//if((argv[i][0] == '-') && (argv[i][1] == 'f')){
			r8 = r8 ^ r8;
			r8b = [r5];
			r9 = CHAR_MINUS;
			if(r8 == r9){
				r8b = [r5+1];
				r9 = CHAR_f;
				if(r8 == r9){
					//Set the type of Source Output = SOURCE_TYPE
					//if(!strcmp(argv[i], "-felf")){
						//SOURCE_TYPE = SOURCE_ELF;
						//SOURCE_CLI = 1;
					r4 = _strcmp(r5, '-felf');
					if(r4 == r3){
						SOURCE_TYPE = SOURCE_ELF;
						SOURCE_CLI = 1;
						//echo_string(STDOUT, 'Source is ELF\n');
					} else {
					//} else {
						//if(!strcmp(argv[i], "-fpe")){
							//SOURCE_TYPE = SOURCE_PE;
							//SOURCE_CLI = 1;
						r4 = _strcmp(r5, '-fpe');
						if(r4 == r3){
							SOURCE_TYPE = SOURCE_PE;
							SOURCE_CLI = 1;
							//echo_string(STDOUT, 'Source is PE\n');
						} else {
							r4 = _strcmp(r5, '-fdll');
							if(r4 == r3){
								SOURCE_TYPE = SOURCE_DLL;
								SOURCE_CLI = 1;
								//echo_string(STDOUT, 'Source is PE\n');
							} else {
							//} else {
								//if(!strcmp(argv[i], "-felfo")){
									//SOURCE_TYPE = SOURCE_ELFO;
									//SOURCE_CLI = 1;
								r4 = _strcmp(r5, '-felfo');
								if(r4 == r3){
									SOURCE_TYPE = SOURCE_ELFO;
									SOURCE_CLI = 1;
									//echo_string(STDOUT, 'Source is ELFO\n');
								} else {
								//} else {
									//PrintHeader();
									//printf("Error: Unknown Output Format?\n");
									//exit(1);
									PrintHeader();
									echo_string(STDOUT, 'Error: Unknown Output Format?\n');
									#ifdef WIN64;
									__Exit_Win64();
									#endif;

									//exit(-1);
									r0 = -1;
									r7 = rsp_entry;
									ret;
								//}
								}
							}
						//}
						}
					//}
					}
				}
			}

			r8 = r8 ^ r8;
			r8b = [r5];
			r9 = CHAR_MINUS;
			if(r8 == r9){
				r8b = [r5+1];
				r9 = CHAR_o;
				if(r8 == r9){
					r10 = &output_filename;
					strcpy(r10, r5);
				}
			}
			
			
			//}
			//if((argv[i][0] != '-') && (i != 0) && (have_file == 0)){
				// Else let's assume for now that it's our filename?
				//strcpy((char *) filename,argv[i]);
				//have_file = 1;
			//}

			if(r3 != r2){
				r0 = have_file;
				if(r0 == r3){
					r8 = r8 ^ r8;
					r8b = [r5];
					r9 = CHAR_MINUS;
					if(r8 != r9){
						//strcpy((char *) filename,argv[i]);
						r10 = &filename;
						r5 = r5 - 2;
						strcpy(r10, r5);
						r5 = r5 + 2;
						//have_file = 1;
						have_file = 1;
						//echo_string(STDOUT, '&Filename = ');
						//echo_hex(STDOUT, r5);
						//echo_string(STDOUT, ' or ');
						//r5 = r5 - 2;
						//echo_string(STDOUT, r5);
						//r5 = r5 + 2;
						//echo_string(STDOUT, '\n');
						//r5 = r5 - 2;
					}
				}
			}
			pop r2;
			r2 = r2 + 1;
		//}
		}
	//} else {
	} else {
		//PrintHelp();
		#ifdef WIN64;
		PopUpHelp();
		#else;
		PrintHelp();
		#endif;
	//}
	}
	//echo_hex(STDOUT, r7);
	//echo_string(STDOUT, '\n');

	//if ((Help)||(!have_file)||(Version)){
		//if(Help)
			//PrintHelp();
		
		//if((!have_file)&&(!Version))
		//	PrintHelp();
		
		//PrintHeader();
		//if(!have_file)
			//exit(0);
	//}
	r0 = 0;
	r1 = have_file;
	if(r1 == r0){ r0 = 1; }
	r1 = Help;
	if(r1){ r0 = 1; }
	r1 = Version;
	if(r1){ r0 = 1; }
	if(r0){
		r1 = Help;
		if(r1){
			#ifdef WIN64;
			PopUpHelp();
			#else;
			PrintHelp();
			#endif;
		}
		r0 = 0;
		r1 = have_file;
		if(r1 == r0){
			r1 = Version;
			if(r1 == r0){
				#ifdef WIN64;
				PopUpHelp();
				#else;
				PrintHelp();
				#endif;
			}
		}
		PrintHeader();
		r0 = 0;
		r1 = have_file;
		if(r1 == r0){
			#ifdef WIN64;
			__Exit_Win64();
			#endif;

			//exit(0);
			r0 = 0;
			r7 = rsp_entry;
			ret;
		}
	}
	
	r0 = r1;
	r0 = r1;
	r0 = r1;
	
	//b0_env = getenv("B0_INCLUDE");
	r0 = _getenv('B0_INCLUDE');
	ptr_b0_env = r0;
	
	//if(b0_env) scan_env(b0_env);
	r0 = ptr_b0_env;
	if(r0){
		scan_env(r0);
	}
	// If you have any directories to include they should already be added.
	// total_paths = number of paths we can search!
	
	//if(DEBUG){
		//PrintHeader();
		//switch(SOURCE_TYPE){
			//case SOURCE_ELF: printf("Output Format: ELF Executable\n"); break;
			//case SOURCE_ELFO: printf("Output Format: ELF Object\n"); break;
			//case SOURCE_PE: printf("Output Format: PE\n"); break;
		//}
		//if (UTF8_STRINGS == 1){
			//printf("Strings will be encoded as UTF8\n");
		//} else {
			//printf("Strings will be encoded as UTF16\n");
		//}
		//for (j=0;j<total_paths;j++){
			//printf("search path = %s\n", paths[j]);
	//}
	r15 = DEBUG;
	if(r15){
		PrintHeader();
		r1 = SOURCE_TYPE;
		r2 = SOURCE_ELF;
		if(r1 == r2){
			echo_string(STDOUT, 'Output Format: ELF Executable\n');
		} else {
			r2 = SOURCE_ELFO;
			if(r1 == r2){
				echo_string(STDOUT, 'Output Format: ELF Object\n');
			} else {
				r2 = SOURCE_PE;
				if(r1 == r2){
					echo_string(STDOUT, 'Output Format: PE\n');
				} else {
					r2 = SOURCE_DLL;
					if(r1 == r2){
						echo_string(STDOUT, 'Output Format: DLL\n');
					}
				}
			}
		}
		r1 = UTF8_STRINGS;
		r2 = 1;
		if(r1 == r2){
			echo_string(STDOUT, 'Strings will be encoded as UTF8\n');
		} else {
			echo_string(STDOUT, 'Strings will be encoded as UTF16\n');
		}
		r1 = 0;
		r2 = total_paths;
		while (r1 < r2){
			echo_string(STDOUT, 'search path = ');
			r3 = &paths[r1];
			echo_string(STDOUT, r3);
			echo_cr(STDOUT);
			r1 = r1 + 1;
		}
	}

	//}
	
	b0_build_hashtable();
	
	//state = 0;			// Reset code state to null;
	//file_stack_ptr = 0;
	//local_var_offset = 0;
	//dynamic_string_count = 0; //Number of dynamic string decl.
	
	state = 0;
	file_stack_ptr = 0;
	local_var_offset = 0;
	dynamic_string_count = 0;
 
	//if(DEBUG)
		//printf("Filename = %s\n", filename);
	
	
	if(r15){
		echo_string(STDOUT, 'Filename = "');
		r0 = &filename;
		echo_string(STDOUT, r0);
		echo_string(STDOUT, '"\n');
	};
	

	b0_open_source_file();
	b0_open_temp_files();
	
	look_ahead_ch = 0; 	// Prime the current char buffer
	token = 0;
	global = 0;			// We start from a global level
	block_level = 0;
	block_num = 0;
	
	//while (file_stack_ptr >= 0) {
		// As long as we have a file to read, let's keep going
		//block();
	//}
	r1 = 0;
	r2 = file_stack_ptr;
	while(r2 ~>= r1){
		block();
		r1 = 0;
		r2 = file_stack_ptr;
	}		
	
	//if(DEBUG){
		//printf("EOF reached\n");
		//For testing, dump the hash table!
		//printf("HASH TABLE----------\n");
		//for (i = 0; i < HASH_TABLE_SIZE; i++) {
			//if (hash_table[i].hash != 0)
				//printf("0x%lx -> 0x%lx = %s ,Type: 0x%x, Import = %s -> 0x%lx\n", i, hash_table[i].hash, hash_table[i].token, 
					//hash_table[i].token_type, hash_table[i].token_import_name, hash_table[i].token_import_lib);
		//};
	//}
	if(r15){
		echo_string(STDOUT, 'EOF reached\nHASH TABLE----------\n');
		r1 = 0;
		r2 = HASH_TABLE_SIZE;
		while (r1 < r2){
			r0 = hash_table[r1].hash;
			if(r0){
				echo_hex(STDOUT, r1);
				echo_string(STDOUT, ' -> ');
				r0 = hash_table[r1].hash;
				echo_hex(STDOUT, r0);
				echo_string(STDOUT, ' = ');
				r0 = &hash_table[r1].token;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, ' , Type: ');
				r0 = hash_table[r1].token_type;
				echo_hex(STDOUT, r0);
				echo_string(STDOUT, ', Import = ');
				r0 = &hash_table[r1].token_import_name;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, ' -> ');
				r0 = hash_table[r1].token_import_lib;
				echo_hex(STDOUT, r0);
				echo_cr(STDOUT);
			}
			r1 = r1 + 1;
		}
	}
	
	//rewind(code);
	r1 = code;
	_rewind(r1);
	//rewind(data);
	r1 = data;
	_rewind(r1);
	//rewind(bss);
	r1 = bss;
	_rewind(r1);

	r14 = b0_open_output_file();
	
	b0_build_source(r14);

	//time_end = clock();
	r0 = _clock();
	time_end = r0;
	//duration = (double)(time_end - time_start) / CLOCKS_PER_SEC;
	
	r1 = time_end;
	r2 = time_start;
	r4 = r1 - r2;
	
	//if(DEBUG || Version)
		//printf( "Processing Time: %5.3f seconds\n", duration );
	r1 = DEBUG;
	r2 = Version;
	r1 = r1 + r2;
	if(r1){
		echo_string(STDOUT, 'Processing Time: ');
		echo_integer(STDOUT, r4);
		echo_string(STDOUT, ' sec\n');
		//echo_hex(STDOUT, r4);
		//echo_string(STDOUT, ' clocks\n');
	}
	b0_close_temp_files(r14);

	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	//#ifdef UNIX_LIBC;
	//exit(0);
	//#endif;
	r0 = 0;
	return(r0);
};
